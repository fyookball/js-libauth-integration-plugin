/**
 * A simple method used throughout Libauth to format error messages. By
 * formatting errors this way, downstream consumers can detect specific error
 * types by matching the `errorType`. For example, the error:
 *
 * ```ts
 * formatError(SomeTypeOfError.exceedsMaximum, `Provided value: ${value}`);
 * ```
 *
 * Can be detected with `String.includes()`, even if the
 * `SomeTypeOfError.exceedsMaximum` error message changes:
 * ```ts
 * error.includes(SomeTypeOfError.exceedsMaximum);
 * // => true
 * ```
 *
 * Using this method ensures consistency across the library.
 *
 * @remarks
 * In Libauth, expected errors use the type `string` rather than `Error` (or
 * other objects that inherit from `Error`) to simplify the resulting types and
 * typechecking requirements. This ensures consistency of returned errors in all
 * environments, avoids exposing internal details like stack traces and line
 * numbers, and allows error messages to be recorded or used as text without an
 * intermediate `toString()` method.
 *
 * @param errorType - the error enum member representing this error type
 * @param errorDetails - optional, additional details to include in the error
 * message
 * @param throwError - if `true`, the function will throw an `Error` rather than
 * returning the string (defaults to `false`).
 */
const formatError = (errorType, errorDetails, throwError = false) => {
    const message = `${errorType}${errorDetails === undefined ? '' : ` ${errorDetails}`}`;
    if (throwError) {
        // eslint-disable-next-line functional/no-throw-statements
        throw new Error(message);
    }
    return message;
};
/**
 *
 * @param value - the unexpected value
 * @param message - an optional error message
 */
const unknownValue = (value, message = `Received an unknown value; this should have been caught by TypeScript - are your types correct?`) => formatError(message, String(value), true);
/**
 * A utility to handle error results by throwing an `Error` object.
 *
 * If the provided value is of type `string`, the contents of the string are
 * thrown as a new `Error`, otherwise, the value is returned unmodified.
 *
 * This method is useful for eliminating `string` as a possible type from a
 * resulting value, particularly in places where an error is never expected to
 * occur in practice (i.e. no user or runtime input is involved), e.g.:
 *
 * ```ts
 * import { assertSuccess, decodeCashAddress, binToHex } from '@bitauth/libauth';
 * const address = 'bitcoincash:zq2azmyyv6dtgczexyalqar70q036yund5j2mspghf';
 *
 * // Might be either a string or a decoded address:
 * const decoded = decodeCashAddress(address);
 * // Now guaranteed to be a decoded address (error messages are thrown):
 * const tokenAddress = assertSuccess(decoded);
 * // The result can be used immediately:
 * console.log(binToHex(tokenAddress.payload));
 * ```
 *
 * @param result - A result which might be a string.
 * @param expectation - An optional, descriptive prefix for the error message
 * thrown in failure cases. By default,
 * `Expected a successful result, but encountered an error: `.
 */
const assertSuccess = (result, expectation = 'Expected a successful result, but encountered an error: ') => {
    // eslint-disable-next-line functional/no-throw-statements
    if (typeof result === 'string')
        throw new Error(`${expectation}${result}`);
    return result;
};

var BaseConverterCreationError;
(function (BaseConverterCreationError) {
    BaseConverterCreationError["tooLong"] = "Base converter creation error: an alphabet may be no longer than 254 characters.";
    BaseConverterCreationError["ambiguousCharacter"] = "Base converter creation error: a character code may only appear once in a single alphabet.";
})(BaseConverterCreationError || (BaseConverterCreationError = {}));
var BaseConversionError;
(function (BaseConversionError) {
    BaseConversionError["unknownCharacter"] = "Base conversion error: encountered an unknown character for this alphabet.";
})(BaseConversionError || (BaseConversionError = {}));
/**
 * Create a {@link BaseConverter}, exposing methods for encoding and decoding
 * `Uint8Array`s using bitcoin-style padding: each leading zero in the input is
 * replaced with the zero-index character of the `alphabet`, then the remainder
 * of the input is encoded as a large number in the specified alphabet.
 *
 * For example, using the alphabet `01`, the input `[0, 15]` is encoded `01111`
 * – a single `0` represents the leading padding, followed by the base2 encoded
 * `0x1111` (15). With the same alphabet, the input `[0, 0, 255]` is encoded
 * `0011111111` - only two `0` characters are required to represent both
 * leading zeros, followed by the base2 encoded `0x11111111` (255).
 *
 * **This is not compatible with `RFC 3548`'s `Base16`, `Base32`, or `Base64`.**
 *
 * If the alphabet is malformed, this method returns the error as a `string`.
 *
 * @param alphabet - an ordered string that maps each index to a character,
 * e.g. `0123456789`.
 */
// Algorithm from the `base-x` implementation (derived from the original Satoshi implementation): https://github.com/cryptocoinjs/base-x
const createBaseConverter = (alphabet) => {
    const undefinedValue = 255;
    const uint8ArrayBase = 256;
    if (alphabet.length >= undefinedValue)
        return formatError(BaseConverterCreationError.tooLong, `Alphabet length: ${alphabet.length}`);
    const alphabetMap = new Uint8Array(uint8ArrayBase).fill(undefinedValue);
    // eslint-disable-next-line functional/no-loop-statements, functional/no-let, no-plusplus
    for (let index = 0; index < alphabet.length; index++) {
        const characterCode = alphabet.charCodeAt(index);
        if (alphabetMap[characterCode] !== undefinedValue) {
            return formatError(BaseConverterCreationError.ambiguousCharacter, `Ambiguous character: ${alphabetMap[characterCode]}`);
        }
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        alphabetMap[characterCode] = index;
    }
    const base = alphabet.length;
    const paddingCharacter = alphabet.charAt(0);
    const factor = Math.log(base) / Math.log(uint8ArrayBase);
    const inverseFactor = Math.log(uint8ArrayBase) / Math.log(base);
    return {
        // eslint-disable-next-line complexity
        decode: (input) => {
            if (input.length === 0)
                return Uint8Array.of();
            const firstNonZeroIndex = input
                .split('')
                .findIndex((character) => character !== paddingCharacter);
            if (firstNonZeroIndex === -1) {
                return new Uint8Array(input.length);
            }
            const requiredLength = Math.floor((input.length - firstNonZeroIndex) * factor + 1);
            const decoded = new Uint8Array(requiredLength);
            /* eslint-disable functional/no-let, functional/no-expression-statements */
            let nextByte = firstNonZeroIndex;
            let remainingBytes = 0;
            // eslint-disable-next-line functional/no-loop-statements
            while (input[nextByte] !== undefined) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                let carry = alphabetMap[input.charCodeAt(nextByte)];
                if (carry === undefinedValue)
                    return formatError(BaseConversionError.unknownCharacter, `Unknown character: "${input[nextByte]}".`);
                let digit = 0;
                // eslint-disable-next-line functional/no-loop-statements
                for (let steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1; 
                // eslint-disable-next-line no-plusplus
                steps--, digit++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    carry += Math.floor(base * decoded[steps]);
                    // eslint-disable-next-line functional/immutable-data
                    decoded[steps] = Math.floor(carry % uint8ArrayBase);
                    carry = Math.floor(carry / uint8ArrayBase);
                }
                remainingBytes = digit;
                // eslint-disable-next-line no-plusplus
                nextByte++;
            }
            /* eslint-enable functional/no-let, functional/no-expression-statements */
            const firstNonZeroResultDigit = decoded.findIndex((value) => value !== 0);
            const bin = new Uint8Array(firstNonZeroIndex + (requiredLength - firstNonZeroResultDigit));
            // eslint-disable-next-line functional/no-expression-statements
            bin.set(decoded.slice(firstNonZeroResultDigit), firstNonZeroIndex);
            return bin;
        },
        // eslint-disable-next-line complexity
        encode: (input) => {
            if (input.length === 0)
                return '';
            const firstNonZeroIndex = input.findIndex((byte) => byte !== 0);
            if (firstNonZeroIndex === -1) {
                return paddingCharacter.repeat(input.length);
            }
            const requiredLength = Math.floor((input.length - firstNonZeroIndex) * inverseFactor + 1);
            const encoded = new Uint8Array(requiredLength);
            /* eslint-disable functional/no-let, functional/no-expression-statements */
            let nextByte = firstNonZeroIndex;
            let remainingBytes = 0;
            // eslint-disable-next-line functional/no-loop-statements
            while (nextByte !== input.length) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                let carry = input[nextByte];
                let digit = 0;
                // eslint-disable-next-line functional/no-loop-statements
                for (let steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1; 
                // eslint-disable-next-line no-plusplus
                steps--, digit++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    carry += Math.floor(uint8ArrayBase * encoded[steps]);
                    // eslint-disable-next-line functional/immutable-data
                    encoded[steps] = Math.floor(carry % base);
                    carry = Math.floor(carry / base);
                }
                remainingBytes = digit;
                // eslint-disable-next-line no-plusplus
                nextByte++;
            }
            /* eslint-enable functional/no-let, functional/no-expression-statements */
            const firstNonZeroResultDigit = encoded.findIndex((value) => value !== 0);
            const padding = paddingCharacter.repeat(firstNonZeroIndex);
            return encoded
                .slice(firstNonZeroResultDigit)
                .reduce((all, digit) => all + alphabet.charAt(digit), padding);
        },
    };
};
const bitcoinBase58Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const base58 = createBaseConverter(bitcoinBase58Alphabet);
/**
 * Convert a bitcoin-style base58-encoded string to a Uint8Array.
 *
 * For the reverse, see {@link binToBase58}.
 *
 * See {@link createBaseConverter} for format details.
 * @param input - a valid base58-encoded string to decode
 */
const base58ToBin = base58.decode;
/**
 * Convert a Uint8Array to a bitcoin-style base58-encoded string.
 *
 * For the reverse, see {@link base58ToBin}.
 *
 * See {@link createBaseConverter} for format details.
 * @param input - the Uint8Array to base58 encode
 */
const binToBase58 = base58.encode;

// base64 encode/decode derived from: https://github.com/niklasvh/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const base64GroupLength = 4;
const nonBase64Chars = new RegExp(`[^${chars}=]`, 'u');
/**
 * For use before {@link base64ToBin}. Returns true if the provided string is
 * valid base64 (length is divisible by 4, only uses base64 characters).
 * @param maybeBase64 - a string to test
 */
const isBase64 = (maybeBase64) => maybeBase64.length % base64GroupLength === 0 &&
    !nonBase64Chars.test(maybeBase64);
/* eslint-disable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-magic-numbers, no-bitwise, no-plusplus, @typescript-eslint/no-non-null-assertion */
/**
 * Convert a base64-encoded string to a Uint8Array.
 *
 * Note, this method always completes. If `validBase64` is not valid base64, an
 * incorrect result will be returned. If `validBase64` is potentially malformed,
 * check it with {@link isBase64} before calling this method.
 *
 * For the reverse, see {@link binToBase64}.
 *
 * @param validBase64 - a valid base64-encoded string to decode
 */
const base64ToBin = (validBase64) => {
    const lookup = new Uint8Array(123);
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements
    for (let i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
    }
    const bufferLengthEstimate = validBase64.length * 0.75;
    const stringLength = validBase64.length;
    const bufferLength = validBase64[validBase64.length - 1] === '=' // eslint-disable-line @typescript-eslint/prefer-string-starts-ends-with
        ? validBase64[validBase64.length - 2] === '='
            ? bufferLengthEstimate - 2
            : bufferLengthEstimate - 1
        : bufferLengthEstimate;
    const buffer = new ArrayBuffer(bufferLength);
    const bytes = new Uint8Array(buffer);
    // eslint-disable-next-line functional/no-let
    let p = 0;
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements
    for (let i = 0; i < stringLength; i += 4) {
        const encoded1 = lookup[validBase64.charCodeAt(i)];
        const encoded2 = lookup[validBase64.charCodeAt(i + 1)];
        const encoded3 = lookup[validBase64.charCodeAt(i + 2)];
        const encoded4 = lookup[validBase64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return bytes;
};
/**
 * Convert a Uint8Array to a base64-encoded string.
 *
 * For the reverse, see {@link base64ToBin}.
 *
 * @param bytes - the Uint8Array to base64 encode
 */
const binToBase64 = (bytes) => {
    // eslint-disable-next-line functional/no-let
    let result = '';
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements
    for (let i = 0; i < bytes.length; i += 3) {
        result += chars[bytes[i] >> 2];
        result += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        result += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        result += chars[bytes[i + 2] & 63];
    }
    const padded = bytes.length % 3 === 2
        ? `${result.substring(0, result.length - 1)}=`
        : bytes.length % 3 === 1
            ? `${result.substring(0, result.length - 2)}==`
            : result;
    return padded;
};
/* eslint-enable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-magic-numbers, no-bitwise, no-plusplus, @typescript-eslint/no-non-null-assertion */

/**
 * Returns an array of incrementing values starting at `begin` and incrementing
 * by one for `length`.
 *
 * E.g.: `range(3)` → `[0, 1, 2]` and `range(3, 1)` → `[1, 2, 3]`
 *
 * @param length - the number of elements in the array
 * @param begin - the index at which the range starts (default: `0`)
 */
const range = (length, begin = 0) => Array.from({ length }, (_, index) => begin + index);
/**
 * Split a string into an array of `chunkLength` strings. The final string may
 * have a length between 1 and `chunkLength`.
 *
 * E.g.: `splitEvery('abcde', 2)` → `['ab', 'cd', 'e']`
 */
const splitEvery = (input, chunkLength) => range(Math.ceil(input.length / chunkLength))
    .map((index) => index * chunkLength)
    .map((begin) => input.slice(begin, begin + chunkLength));
const hexByteWidth = 2;
const hexadecimal = 16;
/**
 * Decode a hexadecimal-encoded string into a Uint8Array.
 *
 * E.g.: `hexToBin('2a64ff')` → `new Uint8Array([42, 100, 255])`
 *
 * Note, this method always completes. If `validHex` is not divisible by 2,
 * the final byte will be parsed as if it were prepended with a `0` (e.g. `aaa`
 * is interpreted as `aa0a`). If `validHex` is potentially malformed, check
 * it with {@link isHex} before calling this method.
 *
 * For the reverse, see {@link binToHex}.
 *
 * @param validHex - a string of valid, hexadecimal-encoded data
 */
const hexToBin = (validHex) => Uint8Array.from(splitEvery(validHex, hexByteWidth).map((byte) => parseInt(byte, hexadecimal)));
/**
 * For use before {@link hexToBin}. Returns true if the provided string is valid
 * hexadecimal (length is divisible by 2, only uses hexadecimal characters).
 * @param maybeHex - a string to test
 */
const isHex = (maybeHex) => maybeHex.length % hexByteWidth === 0 && !/[^a-fA-F0-9]/u.test(maybeHex);
/**
 * Encode a Uint8Array into a hexadecimal-encoded string.
 *
 * E.g.: `binToHex(new Uint8Array([42, 100, 255]))` → `'2a64ff'`
 *
 * For the reverse, see {@link hexToBin}.
 *
 * @param bytes - a Uint8Array to encode
 */
const binToHex = (bytes) => bytes.reduce((str, byte) => str + byte.toString(hexadecimal).padStart(hexByteWidth, '0'), '');
/**
 * Decode a hexadecimal-encoded string into bytes, reverse it, then re-encode.
 *
 * @param validHex - a string of valid, hexadecimal-encoded data. See
 * {@link hexToBin} for more information.
 */
const swapEndianness = (validHex) => binToHex(hexToBin(validHex).reverse());
/**
 * Reduce an array of `Uint8Array`s into a single `Uint8Array`.
 * @param array - the array of `Uint8Array`s to flatten
 */
const flattenBinArray = (array) => {
    const totalLength = array.reduce((total, bin) => total + bin.length, 0);
    const flattened = new Uint8Array(totalLength);
    // eslint-disable-next-line functional/no-expression-statements
    array.reduce((index, bin) => {
        // eslint-disable-next-line functional/no-expression-statements
        flattened.set(bin, index);
        return index + bin.length;
    }, 0);
    return flattened;
};
/**
 * Compare to `Uint8Array`s, return true if their contents are exactly the same,
 * otherwise return false.
 * @param a - the first Uint8Array
 * @param b - the second Uint8Array
 */
const binsAreEqual = (a, b) => {
    if (a.length !== b.length) {
        return false;
    }
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
};

const binaryByteWidth = 8;
const binary = 2;
/**
 * Decode a binary-encoded string into a Uint8Array.
 *
 * E.g.: `binStringToBin('0010101001100100')` → `new Uint8Array([42, 100])`
 *
 * Note, this method always completes. If `binaryDigits` is not divisible by 8,
 * the final byte will be parsed as if it were prepended with `0`s (e.g. `1`
 * is interpreted as `00000001`). If `binaryDigits` is potentially malformed,
 * check it with `isBinString` before calling this method.
 *
 * For the reverse, see {@link binToBinString}.
 *
 * @param binaryDigits - a string of `0`s and `1`s with a length divisible by 8
 */
const binStringToBin = (binaryDigits) => Uint8Array.from(splitEvery(binaryDigits, binaryByteWidth).map((byteString) => parseInt(byteString, binary)));
/**
 * Encode a Uint8Array into a binary-encoded string.
 *
 * E.g.: `binToBinString(Uint8Array.from([42, 100]))` → `'0010101001100100'`
 *
 * For the reverse, see {@link binStringToBin}.
 *
 * @param bytes - a Uint8Array to encode
 */
const binToBinString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(binary).padStart(binaryByteWidth, '0'), '');
/**
 * For use before {@link binStringToBin}. Returns true if the provided string is
 * a valid binary string (length is divisible by 8 and only uses the characters
 * `0` and `1`).
 * @param maybeBinString - a string to test
 */
const isBinString = (maybeBinString) => maybeBinString.length % binaryByteWidth === 0 &&
    !/[^01]/u.test(maybeBinString);

const defaultStringifySpacing = 2;
/**
 * A safe method to `JSON.stringify` a value, useful for debugging and logging
 * purposes.
 *
 * @remarks
 * Without modifications, `JSON.stringify` has several shortcomings in
 * debugging and logging usage:
 * - throws when serializing anything containing a `bigint`
 * - `Uint8Array`s are often encoded in base 10 with newlines between each
 *   index item
 * - `functions` and `symbols` are not clearly marked
 *
 * This method is more helpful in these cases:
 * - `bigint`: `0n` → `<bigint: 0n>`
 * - `Uint8Array`: `Uint8Array.of(0,0)` → `<Uint8Array: 0x0000>`
 * - `function`: `(x) => x * 2` → `<function: (x) => x * 2>`
 * - `symbol`: `Symbol(A)` → `<symbol: Symbol(A)>`
 *
 * @param value - the data to stringify
 * @param spacing - the number of spaces to use in
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const stringify = (value, spacing = defaultStringifySpacing) => JSON.stringify(value, 
// eslint-disable-next-line complexity
(_, item) => {
    const type = typeof item;
    const name = typeof item === 'object' && item !== null
        ? item.constructor.name
        : type;
    switch (name) {
        case 'Uint8Array':
            return `<Uint8Array: 0x${binToHex(item)}>`;
        case 'bigint':
            return `<bigint: ${item.toString()}n>`;
        case 'function':
        case 'symbol':
            // eslint-disable-next-line @typescript-eslint/ban-types
            return `<${name}: ${item.toString()}>`;
        default:
            return item;
    }
}, spacing);
/**
 * Given a value, recursively sort the keys of all objects it references
 * (without sorting arrays).
 *
 * @param objectOrArray - the object or array in which to sort object keys
 */
const sortObjectKeys = (objectOrArray) => {
    if (Array.isArray(objectOrArray)) {
        return objectOrArray.map(sortObjectKeys);
    }
    if (typeof objectOrArray !== 'object' ||
        objectOrArray === null ||
        objectOrArray.constructor.name !== 'Object') {
        return objectOrArray;
    }
    // eslint-disable-next-line functional/immutable-data
    const keys = Object.keys(objectOrArray).sort((a, b) => a.localeCompare(b, 'en'));
    return keys.reduce((all, key) => ({
        ...all,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        [key]: sortObjectKeys(objectOrArray[key]),
    }), {});
};
const uint8ArrayRegex = /"<Uint8Array: 0x(?<hex>[0-9a-f]*)>"/gu;
const bigIntRegex = /"<bigint: (?<bigint>[0-9]*)n>"/gu;
/**
 * An alternative to {@link stringify} that produces valid JavaScript for use
 * as a test vector in this library. `Uint8Array`s are constructed using
 * {@link hexToBin} and `bigint` values use the `BigInt` constructor. If
 * `alphabetize` is `true`, all objects will be sorted in the output.
 *
 * Note, this assumes all strings that match the expected regular expressions
 * are values of type `Uint8Array` and `bigint` respectively. String values
 * that otherwise happen to match these regular expressions will be converted
 * incorrectly.
 *
 * @param value - the value to stringify
 * @param alphabetize - whether or not to alphabetize object keys, defaults
 * to true
 */
const stringifyTestVector = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
value, alphabetize = true) => {
    const stringified = alphabetize
        ? stringify(sortObjectKeys(value))
        : stringify(value);
    return stringified
        .replace(uint8ArrayRegex, "hexToBin('$1')")
        .replace(bigIntRegex, '$1n');
};

/**
 * Encode a positive integer as a little-endian Uint8Array. For values exceeding
 * `Number.MAX_SAFE_INTEGER` (`9007199254740991`),
 * use {@link bigIntToBinUintLE}.
 *
 * Negative values will return the same result as `0`.
 *
 * For the reverse, see {@link binToNumberUintLE}.
 *
 * @param value - the number to encode
 */
const numberToBinUintLE = (value) => {
    const baseUint8Array = 256;
    const result = [];
    // eslint-disable-next-line functional/no-let
    let remaining = value;
    // eslint-disable-next-line functional/no-loop-statements
    while (remaining >= baseUint8Array) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        result.push(remaining % baseUint8Array);
        // eslint-disable-next-line functional/no-expression-statements
        remaining = Math.floor(remaining / baseUint8Array);
    }
    // eslint-disable-next-line functional/no-conditional-statements, functional/no-expression-statements, functional/immutable-data
    if (remaining > 0)
        result.push(remaining);
    return Uint8Array.from(result);
};
/**
 * Fill a new Uint8Array of a specific byte-length with the contents of a given
 * Uint8Array, truncating or padding the Uint8Array with zeros.
 *
 * @param bin - the Uint8Array to resize
 * @param bytes - the desired byte-length
 */
const binToFixedLength = (bin, bytes) => {
    const fixedBytes = new Uint8Array(bytes);
    const maxValue = 255;
    // eslint-disable-next-line functional/no-expression-statements, @typescript-eslint/no-unused-expressions
    bin.length > bytes ? fixedBytes.fill(maxValue) : fixedBytes.set(bin);
    return fixedBytes;
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array, clamping the
 * results – values exceeding `0xffff` (`65535`) return the same result as
 * `0xffff`, negative values will return the same result as `0`.
 *
 * For an alternative overflow behavior, see {@link numberToBinUint16LE}.
 *
 * For the reverse, see {@link binToNumberUint16LE}.
 *
 * @param value - the number to encode
 */
const numberToBinUint16LEClamped = (value) => {
    const uint16 = 2;
    return binToFixedLength(numberToBinUintLE(value), uint16);
};
/**
 * Encode a positive integer as a 4-byte Uint32LE Uint8Array, clamping the
 * results – values exceeding `0xffffffff` (`4294967295`) return the same result
 * as `0xffffffff`, negative values will return the same result as `0`.
 *
 * For an alternative overflow behavior, see {@link numberToBinUint32LE}.
 *
 * For the reverse, see {@link binToNumberUint32LE}.
 *
 * @param value - the number to encode
 */
const numberToBinUint32LEClamped = (value) => {
    const uint32 = 4;
    return binToFixedLength(numberToBinUintLE(value), uint32);
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff` (`65535`). If applicable, applications should handle such
 * cases prior to calling this method.
 *
 * For an alternative overflow behavior, see {@link numberToBinUint16LEClamped}.
 *
 * For the reverse, see {@link binToNumberUint16LE}.
 *
 * @param value - the number to encode
 */
const numberToBinUint16LE = (value) => {
    const uint16Length = 2;
    const bin = new Uint8Array(uint16Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statements
    view.setUint16(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode an integer as a 2-byte Int16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0x0000` to `0xffff` (`65535`). If applicable, applications should handle
 * such cases prior to calling this method.
 *
 * For the reverse, see {@link binToNumberInt16LE}.
 *
 * @param value - the number to encode
 */
const numberToBinInt16LE = (value) => {
    const int16Length = 2;
    const bin = new Uint8Array(int16Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statements
    view.setInt16(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode an integer as a 4-byte Uint32LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0x00000000` to `0xffffffff` (`4294967295`). If applicable, applications
 * should handle such cases prior to calling this method.
 *
 * For the reverse, see {@link binToNumberInt32LE}.
 *
 * @param value - the number to encode
 */
const numberToBinInt32LE = (value) => {
    const int32Length = 4;
    const bin = new Uint8Array(int32Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statements
    view.setInt32(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Decode a 2-byte Int16LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 2 bytes.
 *
 * For the reverse, see {@link numberToBinInt16LE}.
 *
 * @param bin - the Uint8Array to decode
 */
const binToNumberInt16LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getInt16(0, readAsLittleEndian);
};
/**
 * Decode a 4-byte Int32LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 4 bytes.
 *
 * For the reverse, see {@link numberToBinInt32LE}.
 *
 * @param bin - the Uint8Array to decode
 */
const binToNumberInt32LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getInt32(0, readAsLittleEndian);
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff` (`65535`). If applicable, applications should handle such
 * cases prior to calling this method.
 *
 * For the reverse, reverse the result of {@link binToNumberUint16LE}.
 *
 * @param value - the number to encode
 */
const numberToBinUint16BE = (value) => {
    const uint16Length = 2;
    const bin = new Uint8Array(uint16Length);
    const writeAsLittleEndian = false;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statements
    view.setUint16(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive number as a 4-byte Uint32LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffffffff` (`4294967295`). If applicable, applications should handle
 * such cases prior to calling this method.
 *
 * For an alternative overflow behavior, see {@link numberToBinUint32LEClamped}.
 *
 * For the reverse, see {@link binToNumberUint32LE}.
 *
 * @param value - the number to encode
 */
const numberToBinUint32LE = (value) => {
    const uint32Length = 4;
    const bin = new Uint8Array(uint32Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statements
    view.setUint32(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive number as a 4-byte Uint32BE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffffffff` (`4294967295`). If applicable, applications should handle
 * such cases prior to calling this method.
 *
 * For the reverse, reverse the result of {@link binToNumberUint32LE}.
 *
 * @param value - the number to encode
 */
const numberToBinUint32BE = (value) => {
    const uint32Length = 4;
    const bin = new Uint8Array(uint32Length);
    const writeAsLittleEndian = false;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statements
    view.setUint32(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive BigInt as little-endian Uint8Array. Negative values will
 * return the same result as `0`.
 *
 * For the reverse, see {@link binToBigIntUintLE}.
 *
 * @param value - the number to encode
 */
const bigIntToBinUintLE = (value) => {
    const baseUint8Array = 256;
    const base = BigInt(baseUint8Array);
    const result = [];
    // eslint-disable-next-line functional/no-let
    let remaining = value;
    // eslint-disable-next-line functional/no-loop-statements
    while (remaining >= base) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        result.push(Number(remaining % base));
        // eslint-disable-next-line functional/no-expression-statements
        remaining /= base;
    }
    // eslint-disable-next-line functional/no-conditional-statements, functional/no-expression-statements, functional/immutable-data
    if (remaining > 0n)
        result.push(Number(remaining));
    return Uint8Array.from(result.length > 0 ? result : [0]);
};
/**
 * Encode a positive BigInt as an 8-byte Uint64LE Uint8Array, clamping the
 * results – values exceeding `0xffff_ffff_ffff_ffff` (`18446744073709551615`)
 * return the same result as `0xffff_ffff_ffff_ffff`, negative values return the
 * same result as `0`.
 *
 * For an alternative overflow behavior, see {@link bigIntToBinUint64LE}.
 *
 * For the reverse, see {@link binToBigIntUint64LE}.
 *
 * @param value - the number to encode
 */
const bigIntToBinUint64LEClamped = (value) => {
    const uint64 = 8;
    return binToFixedLength(bigIntToBinUintLE(value), uint64);
};
/**
 * Encode a positive BigInt as an 8-byte Uint64LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff_ffff_ffff_ffff` (`18446744073709551615`).
 *
 * For an alternative overflow behavior, see {@link bigIntToBinUint64LEClamped}.
 *
 * For the reverse, see {@link binToBigIntUint64LE}.
 *
 * @param value - the number to encode
 */
const bigIntToBinUint64LE = (value) => {
    const uint64LengthInBits = 64;
    const valueAsUint64 = BigInt.asUintN(uint64LengthInBits, value);
    const fixedLengthBin = bigIntToBinUint64LEClamped(valueAsUint64);
    return fixedLengthBin;
};
/**
 * Encode an integer as a 4-byte, little-endian Uint8Array using the number's
 * two's compliment representation (the format used by JavaScript's bitwise
 * operators).
 *
 * @remarks
 * The C++ bitcoin implementations sometimes represent short vectors using
 * signed 32-bit integers (e.g. `sighashType`). This method can be used to test
 * compatibility with those implementations.
 *
 * @param value - the number to encode
 */
const numberToBinInt32TwosCompliment = (value) => {
    const bytes = 4;
    const bitsInAByte = 8;
    const bin = new Uint8Array(bytes);
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let index = 0; index < bytes; index++) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        bin[index] = value;
        // eslint-disable-next-line functional/no-expression-statements, no-bitwise, no-param-reassign
        value >>>= bitsInAByte;
    }
    return bin;
};
/**
 * Decode a little-endian Uint8Array of any length into a number. For numbers
 * larger than `Number.MAX_SAFE_INTEGER` (`9007199254740991`), use
 * `binToBigIntUintLE`.
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * For the reverse, see {@link numberToBinUintLE}.
 *
 * @privateRemarks
 * We avoid a bitwise strategy here because JavaScript uses 32-bit signed
 * integers for bitwise math, so larger numbers are converted incorrectly. E.g.
 * `2147483648 << 8` is `0`, while `2147483648n << 8n` is `549755813888n`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
const binToNumberUintLE = (bin, bytes = bin.length) => {
    const base = 2;
    const bitsInAByte = 8;
    if (bin.length !== bytes) {
        // eslint-disable-next-line functional/no-throw-statements
        throw new TypeError(`Bin length must be ${bytes}.`);
    }
    return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce((accumulated, byte, i) => accumulated + byte * base ** (bitsInAByte * i), 0);
};
/**
 * Decode a 2-byte Uint16LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 2 bytes.
 *
 * For the reverse, see {@link numberToBinUint16LE}.
 *
 * @param bin - the Uint8Array to decode
 */
const binToNumberUint16LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getUint16(0, readAsLittleEndian);
};
/**
 * Decode a 4-byte Uint32LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 4 bytes.
 *
 * For the reverse, see {@link numberToBinUint32LE}.
 *
 * @param bin - the Uint8Array to decode
 */
const binToNumberUint32LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getUint32(0, readAsLittleEndian);
};
/**
 * Decode a big-endian Uint8Array of any length into a BigInt. If starting from
 * a hex value, consider using the BigInt constructor instead:
 * ```
 * BigInt(`0x${hex}`)
 * ```
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * For the reverse, see {@link bigIntToBinUintBE}.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
const binToBigIntUintBE = (bin, bytes = bin.length) => {
    const bitsInAByte = 8;
    const shift = BigInt(bitsInAByte);
    if (bin.length !== bytes) {
        // eslint-disable-next-line functional/no-throw-statements
        throw new TypeError(`Bin length must be ${bytes}.`);
    }
    return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce(
    // eslint-disable-next-line no-bitwise
    (accumulated, byte) => (accumulated << shift) | BigInt(byte), 0n);
};
/**
 * Encode a positive BigInt as big-endian Uint8Array. Negative values will
 * return the same result as `0`.
 *
 * For the reverse, see {@link binToBigIntUintBE}.
 *
 * @param value - the number to encode
 */
const bigIntToBinUintBE = (value) => bigIntToBinUintLE(value).reverse();
/**
 * Decode an unsigned, 32-byte big-endian Uint8Array into a BigInt. This can be
 * used to decode Uint8Array-encoded cryptographic primitives like private
 * keys, public keys, curve parameters, and signature points.
 *
 * If starting from a hex value, consider using the BigInt constructor instead:
 * ```
 * BigInt(`0x${hex}`)
 * ```
 *
 * For the reverse, see {@link bigIntToBinUint256BEClamped}.
 *
 * @param bin - the Uint8Array to decode
 */
const binToBigIntUint256BE = (bin) => {
    const uint256Bytes = 32;
    return binToBigIntUintBE(bin, uint256Bytes);
};
/**
 * Encode a positive BigInt into an unsigned 32-byte big-endian Uint8Array. This
 * can be used to encoded numbers for cryptographic primitives like private
 * keys, public keys, curve parameters, and signature points.
 *
 * Negative values will return the same result as `0`, values higher than
 * 2^256-1 will return the maximum expressible unsigned 256-bit value
 * (`0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff`).
 *
 * For the reverse, see {@link binToBigIntUint256BE}.
 *
 * @param value - the BigInt to encode
 */
const bigIntToBinUint256BEClamped = (value) => {
    const uint256Bytes = 32;
    return binToFixedLength(bigIntToBinUintLE(value), uint256Bytes).reverse();
};
/**
 * Decode a little-endian Uint8Array of any length into a BigInt.
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * For the reverse, see {@link bigIntToBinUintLE}.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
const binToBigIntUintLE = (bin, bytes = bin.length) => {
    const bitsInAByte = 8;
    if (bin.length !== bytes) {
        // eslint-disable-next-line functional/no-throw-statements
        throw new TypeError(`Bin length must be ${bytes}.`);
    }
    return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduceRight(
    // eslint-disable-next-line no-bitwise
    (accumulated, byte) => (accumulated << BigInt(bitsInAByte)) | BigInt(byte), 0n);
};
/**
 * Decode an 8-byte Uint64LE Uint8Array into a BigInt.
 *
 * Throws if `bin` is shorter than 8 bytes.
 *
 * For the reverse, see {@link bigIntToBinUint64LE}
 * or {@link bigIntToBinUint64LEClamped}.
 *
 * @param bin - the Uint8Array to decode
 */
const binToBigIntUint64LE = (bin) => {
    const uint64LengthInBytes = 8;
    const truncatedBin = bin.length > uint64LengthInBytes ? bin.slice(0, uint64LengthInBytes) : bin;
    return binToBigIntUintLE(truncatedBin, uint64LengthInBytes);
};
/**
 * Decode an {@link Output.valueSatoshis} into a `BigInt`. This is an alias for
 * {@link binToBigIntUint64LE}.
 *
 * Throws if the provided value is shorter than 8 bytes.
 *
 * For the reverse, see {@link valueSatoshisToBin}.
 */
const binToValueSatoshis = binToBigIntUint64LE;
/**
 * Encode a `BigInt` into an {@link Output.valueSatoshis}. This is an alias for
 * {@link bigIntToBinUint64LE}.
 *
 * This method will return an incorrect result for values outside of the range 0
 * to 0xffff_ffff_ffff_ffff (`18446744073709551615`).
 *
 * For the reverse, see {@link binToValueSatoshis}.
 */
const valueSatoshisToBin = bigIntToBinUint64LE;
/**
 * Get the expected byte length of a CompactUint given a first byte.
 *
 * @param firstByte - the first byte of the CompactUint
 */
const compactUintPrefixToLength = (firstByte) => {
    switch (firstByte) {
        case 253 /* CompactUint.uint16Prefix */:
            return 2 /* CompactUint.uint16 */ + 1;
        case 254 /* CompactUint.uint32Prefix */:
            return 4 /* CompactUint.uint32 */ + 1;
        case 255 /* CompactUint.uint64Prefix */:
            return 8 /* CompactUint.uint64 */ + 1;
        default:
            return 1 /* CompactUint.uint8 */;
    }
};
var CompactUintError;
(function (CompactUintError) {
    CompactUintError["noPrefix"] = "Error reading CompactUint: requires at least one byte.";
    CompactUintError["insufficientBytes"] = "Error reading CompactUint: insufficient bytes.";
    CompactUintError["nonMinimal"] = "Error reading CompactUint: CompactUint is not minimally encoded.";
    CompactUintError["excessiveBytes"] = "Error decoding CompactUint: unexpected bytes after CompactUint.";
})(CompactUintError || (CompactUintError = {}));
/**
 * Read a non-minimally-encoded `CompactUint` (see {@link bigIntToCompactUint})
 * from the provided {@link ReadPosition}, returning either an error message (as
 * a string) or an object containing the value and the
 * next {@link ReadPosition}.
 *
 * Rather than this function, most applications should
 * use {@link readCompactUintMinimal}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * `CompactUint`
 */
const readCompactUint = (position) => {
    const { bin, index } = position;
    const prefix = bin[index];
    if (prefix === undefined) {
        return formatError(CompactUintError.noPrefix);
    }
    const bytes = compactUintPrefixToLength(prefix);
    if (bin.length - index < bytes) {
        return formatError(CompactUintError.insufficientBytes, `CompactUint prefix ${prefix} requires at least ${bytes} bytes. Remaining bytes: ${bin.length - index}`);
    }
    const hasPrefix = bytes !== 1;
    const contents = hasPrefix
        ? bin.subarray(index + 1, index + bytes)
        : bin.subarray(index, index + bytes);
    return {
        position: { bin, index: index + bytes },
        result: binToBigIntUintLE(contents),
    };
};
/**
 * Encode a positive BigInt as a `CompactUint` (Satoshi's variable-length,
 * positive integer format).
 *
 * Note: the maximum value of a CompactUint is `0xffff_ffff_ffff_ffff`
 * (`18446744073709551615`). This method will return an incorrect result for
 * values outside of the range `0` to `0xffff_ffff_ffff_ffff`. If applicable,
 * applications should handle such cases prior to calling this method.
 *
 * For the reverse, see {@link compactUintToBigInt}.
 *
 * @param value - the BigInt to encode (must be no larger than
 * `0xffff_ffff_ffff_ffff`)
 */
const bigIntToCompactUint = (value) => value <= BigInt(252 /* CompactUint.uint8MaxValue */)
    ? Uint8Array.of(Number(value))
    : value <= BigInt(65535 /* CompactUint.uint16MaxValue */)
        ? Uint8Array.from([
            253 /* CompactUint.uint16Prefix */,
            ...numberToBinUint16LE(Number(value)),
        ])
        : value <= BigInt(4294967295 /* CompactUint.uint32MaxValue */)
            ? Uint8Array.from([
                254 /* CompactUint.uint32Prefix */,
                ...numberToBinUint32LE(Number(value)),
            ])
            : Uint8Array.from([
                255 /* CompactUint.uint64Prefix */,
                ...bigIntToBinUint64LE(value),
            ]);
/**
 * Read a minimally-encoded `CompactUint` from the provided
 * {@link ReadPosition}, returning either an error message (as a string) or an
 * object containing the value and the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * `CompactUint`
 */
const readCompactUintMinimal = (position) => {
    const read = readCompactUint(position);
    if (typeof read === 'string') {
        return read;
    }
    const readLength = read.position.index - position.index;
    const canonicalEncoding = bigIntToCompactUint(read.result);
    if (readLength !== canonicalEncoding.length) {
        return formatError(CompactUintError.nonMinimal, `Value: ${read.result.toString()}, encoded length: ${readLength}, canonical length: ${canonicalEncoding.length}`);
    }
    return read;
};
/**
 * Decode a minimally-encoded `CompactUint` (Satoshi's variable-length, positive
 * integer format) from a Uint8Array, returning the value as a BigInt. This
 * function returns an error if the entire input is not consumed – to read a
 * `CompactUint` from a position within a larger `Uint8Array`,
 * use {@link readCompactUintMinimal} or {@link readCompactUint}.
 *
 * For the reverse, see {@link bigIntToCompactUint}.
 *
 * @param bin - the Uint8Array from which to read the CompactUint
 */
const compactUintToBigInt = (bin) => {
    const read = readCompactUintMinimal({ bin, index: 0 });
    if (typeof read === 'string') {
        return read;
    }
    if (read.position.index !== bin.length) {
        return formatError(CompactUintError.excessiveBytes, `CompactUint ends at index ${read.position.index}, but input includes ${bin.length} bytes.`);
    }
    return read.result;
};
/**
 * Convert a signed integer into it's two's compliment unsigned equivalent, e.g.
 * `0b11111111111111111111111111111110` is `-2` as a signed integer or
 * `4294967294` as an unsigned integer.
 *
 * For the reverse, see {@link int32UnsignedToSigned}.
 *
 * @param int32 - the number to convert
 */
const int32SignedToUnsigned = (int32) => 
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
Uint32Array.from(Int32Array.of(int32))[0];
/**
 * Convert an unsigned integer into it's two's compliment signed equivalent,
 * e.g. `0b11111111111111111111111111111110` is `4294967294` as an unsigned
 * integer or `-2` as a signed integer.
 *
 * For the reverse, see {@link int32SignedToUnsigned}.
 *
 * @param int32 - the number to convert
 */
const int32UnsignedToSigned = (int32) => 
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
Int32Array.from(Uint32Array.of(int32))[0];

/**
 * Given an initial {@link ReadPosition} and a list of {@link ReadFunction}s,
 * apply each {@link ReadFunction} in order, aggregating each result and passing
 * the next {@link ReadPosition} into the next {@link ReadFunction}. If an error
 * occurs, immediately return the error message (`string`), otherwise, return
 * the array of results.
 *
 * @param position - the {@link ReadPosition} at which to start the first read
 * @param readFunctions - the ordered list of {@link ReadFunction}s to apply to
 * the {@link ReadPosition}
 */
const readMultiple = (position, readFunctions) => {
    // eslint-disable-next-line functional/no-let
    let nextPosition = position;
    const results = [];
    // eslint-disable-next-line functional/no-loop-statements
    for (const readFunction of readFunctions) {
        const out = readFunction(nextPosition);
        if (typeof out === 'string') {
            return out;
        }
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        results.push(out.result);
        // eslint-disable-next-line functional/no-expression-statements
        nextPosition = out.position;
    }
    return {
        position: nextPosition,
        result: results,
    };
};
var ReadItemCountError;
(function (ReadItemCountError) {
    ReadItemCountError["itemCount"] = "Error reading item count.";
    ReadItemCountError["item"] = "Error reading item.";
})(ReadItemCountError || (ReadItemCountError = {}));
/**
 * Read a count of items indicated by the CompactUint at {@link ReadPosition}.
 * The CompactUint will be read to determine the number of items, and the read
 * function will be applied in series, aggregated each result and passing the
 * next {@link ReadPosition} into each iteration. If an error occurs,
 * immediately return the error message (`string`), otherwise, return the array
 * of results.
 */
const readItemCount = (position, readFunction) => {
    const countRead = readCompactUintMinimal(position);
    if (typeof countRead === 'string') {
        return formatError(ReadItemCountError.itemCount, countRead);
    }
    // eslint-disable-next-line functional/no-let
    let nextPosition = countRead.position;
    const result = [];
    // eslint-disable-next-line functional/no-loop-statements, functional/no-let, no-plusplus
    for (let remaining = Number(countRead.result); remaining > 0; remaining--) {
        const read = readFunction(nextPosition);
        if (typeof read === 'string') {
            return formatError(ReadItemCountError.item, read);
        }
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        result.push(read.result);
        // eslint-disable-next-line functional/no-expression-statements
        nextPosition = read.position;
    }
    return { position: nextPosition, result };
};

const msPerLocktimeSecond = 1000;
/**
 * The minimum Unix timestamp (inclusive) that can be encoded by a
 * transaction's `locktime`.
 */
const minimumLocktimeTimestamp = 500000000;
/**
 * The maximum Unix timestamp (inclusive) that can be encoded by a
 * transaction's `locktime`.
 */
const maximumLocktimeTimestamp = 0xffffffff;
/**
 * The minimum Date (inclusive) that can be encoded by a transaction's
 * `locktime`.
 */
const minimumLocktimeDate = new Date(minimumLocktimeTimestamp * msPerLocktimeSecond);
/**
 * The maximum Date (inclusive) that can be encoded by a transaction's
 * `locktime`.
 */
const maximumLocktimeDate = new Date(maximumLocktimeTimestamp * msPerLocktimeSecond);
var LocktimeError;
(function (LocktimeError) {
    LocktimeError["dateOutOfRange"] = "The provided Date is outside of the range that can be encoded in locktime.";
    LocktimeError["locktimeOutOfRange"] = "The provided locktime is outside of the range that can be encoded as a Date (greater than or equal to 500000000 and less than or equal to 4294967295).";
    LocktimeError["incorrectLength"] = "The provided locktime is not the correct length (4 bytes).";
})(LocktimeError || (LocktimeError = {}));
/**
 * Convert a JavaScript `Date` object to its equivalent transaction `locktime`
 * representation. The `date` is rounded to the nearest second (the precision of
 * `locktime` Dates).
 *
 * Note, a locktime values greater than or equal to `500000000`
 * See {@link Transaction.locktime} for details.
 *
 * For the reverse, see {@link locktimeToDate}.
 *
 * @param date - the Date to convert to a locktime number
 */
const dateToLocktime = (date) => date < minimumLocktimeDate || date > maximumLocktimeDate
    ? LocktimeError.dateOutOfRange
    : Math.round(date.getTime() / msPerLocktimeSecond);
/**
 * Convert a transaction `locktime` to its equivalent JavaScript `Date` object.
 * If locktime is outside the possible range (greater than or equal to
 * `500000000` and less than or equal to `4294967295`), an error message is
 * returned.
 *
 * For the reverse, see {@link dateToLocktime}.
 *
 * @param locktime - a positive integer between `500000000` and `4294967295`,
 * inclusive
 */
const locktimeToDate = (locktime) => locktime < minimumLocktimeTimestamp || locktime > maximumLocktimeTimestamp
    ? LocktimeError.locktimeOutOfRange
    : new Date(locktime * msPerLocktimeSecond);
/**
 * Convert a JavaScript `Date` object to its equivalent transaction `locktime`
 * bytecode representation. The `date` is rounded to the nearest second (the
 * precision of `locktime` Dates).
 *
 * Note: a block-based locktime can simply be encoded with
 * {@link numberToBinUint32LE} (provided it is no larger than the
 * maximum, `499999999`).
 *
 * @param date - the Date to convert to a locktime Uint8Array
 */
const dateToLocktimeBin = (date) => {
    const result = dateToLocktime(date);
    return typeof result === 'string' ? result : numberToBinUint32LE(result);
};
const locktimeByteLength = 4;
/**
 * Decode a locktime, returning a `number` for block heights, a `Date` for block
 * times, or a string for parsing errors.
 *
 * @param bin - the 4-byte Uint8Array locktime to parse
 */
const decodeLocktime = (bin) => {
    if (bin.length !== locktimeByteLength)
        return LocktimeError.incorrectLength;
    const parsed = binToNumberUint32LE(bin);
    return parsed >= minimumLocktimeTimestamp
        ? new Date(parsed * msPerLocktimeSecond)
        : parsed;
};

const utf8Encoder = new TextEncoder();
/**
 * Interpret a string as UTF-8 and encode it as a Uint8Array.
 *
 * For the reverse, see {@link binToUtf8}.
 *
 * @param utf8 - the string to encode
 */
const utf8ToBin = (utf8) => utf8Encoder.encode(utf8);
const utf8Decoder = new TextDecoder();
/**
 * Decode a Uint8Array as a UTF-8 string.
 *
 * For the reverse, see {@link utf8ToBin}.
 *
 * @param bytes - the Uint8Array to decode
 */
const binToUtf8 = (bytes) => utf8Decoder.decode(bytes);
/**
 * Normalize a string using Unicode Normalization Form KC (NFKC): compatibility
 * decomposition, followed by canonical composition. NFKC is the preferred form
 * for applications in which disambiguation between characters is critical. In
 * Libauth, all message formats designed for transmission between trust centers
 * are NFKC-normalized to hinder exploits in which lookalike characters are used
 * to deceive counterparties.
 *
 * E.g.:
 * ```
 * console.log(lossyNormalize('ﬁt🚀👫👨‍👩‍👧‍👦')); // 'fit🚀👫👨‍👩‍👧‍👦'
 * ```
 */
const lossyNormalize = (utf8) => utf8.normalize('NFKC');
/**
 * Return the user-perceived character segments of the given string, e.g.:
 *
 * ```js
 * const test = 'ﬁt🚀👫👨‍👩‍👧‍👦';
 * console.log([...test]); // '["ﬁ","t","🚀","👫","👨","‍","👩","‍","👧","‍","👦"]'
 * console.log(segment(test)); // '["ﬁ","t","🚀","👫","👨‍👩‍👧‍👦"]'
 * ```
 *
 * Note, this utility segments the string into grapheme clusters using
 * `Intl.Segmenter`, a TC39 proposal which reached stage 4 in 2022, and may not
 * be supported in older environments.
 *
 * @param utf8 - the string for which to segment characters.
 */
const segment = (utf8) => [...new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(utf8)].map((item) => item.segment);
/**
 * Return the user-perceived character length of the given string, e.g.:
 *
 * ```js
 * const test = 'ﬁt🚀👫👨‍👩‍👧‍👦'
 * console.log(test.length); // 17
 * console.log(length(test)); // 5
 * ```
 *
 * Note, this utility segments the string into grapheme clusters using
 * `Intl.Segmenter`, a TC39 proposal which reached stage 4 in 2022, and may not
 * be supported in older environments.
 *
 * @param utf8 - the string for which to count the character length.
 */
const length = (utf8) => segment(utf8).length;

/* eslint-disable functional/no-conditional-statements, functional/no-let, functional/no-expression-statements, no-underscore-dangle, functional/no-try-statements, @typescript-eslint/no-magic-numbers, @typescript-eslint/max-params, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion */
/**
 * Note, most of this method is translated and boiled-down from the wasm-pack
 * workflow. Significant changes to wasm-bindgen or wasm-pack build will likely
 * require modifications to this method.
 */
const instantiateRustWasm = async (webassemblyBytes, expectedImportModuleName, hashExportName, initExportName, updateExportName, finalExportName) => {
    const wasm = (await WebAssembly.instantiate(webassemblyBytes, {
        [expectedImportModuleName]: {
            /**
             * This would only be called in cases where a `__wbindgen_malloc` failed.
             * Since `__wbindgen_malloc` isn't exposed to consumers, this error
             * can only be encountered if the code below is broken.
             */
            /* c8 ignore next 10 */
            // eslint-disable-next-line camelcase, @typescript-eslint/naming-convention
            __wbindgen_throw: (ptr, len) => {
                // eslint-disable-next-line functional/no-throw-statements
                throw new Error(
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                Array.from(getUint8Memory().subarray(ptr, ptr + len))
                    .map((num) => String.fromCharCode(num))
                    .join(''));
            },
        },
    })).instance.exports; // eslint-disable-line @typescript-eslint/no-explicit-any
    let cachedUint8Memory; // eslint-disable-line @typescript-eslint/init-declarations
    let cachedUint32Memory; // eslint-disable-line @typescript-eslint/init-declarations
    let cachedGlobalArgumentPtr; // eslint-disable-line @typescript-eslint/init-declarations
    const globalArgumentPtr = () => {
        if (cachedGlobalArgumentPtr === undefined) {
            cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();
        }
        return cachedGlobalArgumentPtr;
    };
    /**
     * Must be hoisted for `__wbindgen_throw`.
     */
    // eslint-disable-next-line func-style
    function getUint8Memory() {
        if (cachedUint8Memory === undefined ||
            cachedUint8Memory.buffer !== wasm.memory.buffer) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            cachedUint8Memory = new Uint8Array(wasm.memory.buffer);
        }
        return cachedUint8Memory;
    }
    const getUint32Memory = () => {
        if (cachedUint32Memory === undefined ||
            cachedUint32Memory.buffer !== wasm.memory.buffer) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            cachedUint32Memory = new Uint32Array(wasm.memory.buffer);
        }
        return cachedUint32Memory;
    };
    const passArray8ToWasm = (array) => {
        const ptr = wasm.__wbindgen_malloc(array.length);
        getUint8Memory().set(array, ptr);
        return [ptr, array.length];
    };
    const getArrayU8FromWasm = (ptr, len) => getUint8Memory().subarray(ptr, ptr + len);
    const hash = (input) => {
        const [ptr0, len0] = passArray8ToWasm(input);
        const retPtr = globalArgumentPtr();
        try {
            wasm[hashExportName](retPtr, ptr0, len0);
            const mem = getUint32Memory();
            const ptr = mem[retPtr / 4];
            const len = mem[retPtr / 4 + 1];
            const realRet = getArrayU8FromWasm(ptr, len).slice();
            wasm.__wbindgen_free(ptr, len);
            return realRet;
        }
        finally {
            wasm.__wbindgen_free(ptr0, len0);
        }
    };
    const init = () => {
        const retPtr = globalArgumentPtr();
        wasm[initExportName](retPtr);
        const mem = getUint32Memory();
        const ptr = mem[retPtr / 4];
        const len = mem[retPtr / 4 + 1];
        const realRet = getArrayU8FromWasm(ptr, len).slice();
        wasm.__wbindgen_free(ptr, len);
        return realRet;
    };
    const update = (rawState, input) => {
        const [ptr0, len0] = passArray8ToWasm(rawState);
        const [ptr1, len1] = passArray8ToWasm(input);
        const retPtr = globalArgumentPtr();
        try {
            wasm[updateExportName](retPtr, ptr0, len0, ptr1, len1);
            const mem = getUint32Memory();
            const ptr = mem[retPtr / 4];
            const len = mem[retPtr / 4 + 1];
            const realRet = getArrayU8FromWasm(ptr, len).slice();
            wasm.__wbindgen_free(ptr, len);
            return realRet;
        }
        finally {
            rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
            wasm.__wbindgen_free(ptr0, len0);
            wasm.__wbindgen_free(ptr1, len1);
        }
    };
    const final = (rawState) => {
        const [ptr0, len0] = passArray8ToWasm(rawState);
        const retPtr = globalArgumentPtr();
        try {
            wasm[finalExportName](retPtr, ptr0, len0);
            const mem = getUint32Memory();
            const ptr = mem[retPtr / 4];
            const len = mem[retPtr / 4 + 1];
            const realRet = getArrayU8FromWasm(ptr, len).slice();
            wasm.__wbindgen_free(ptr, len);
            return realRet;
        }
        finally {
            rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
            wasm.__wbindgen_free(ptr0, len0);
        }
    };
    return {
        final,
        hash,
        init,
        update,
    };
};
/* eslint-enable functional/no-conditional-statements, functional/no-let, functional/no-expression-statements, no-underscore-dangle, functional/no-try-statements, @typescript-eslint/no-magic-numbers, @typescript-eslint/max-params, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion */

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
const ripemd160Base64Bytes = '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AgQMBQsgAEH8EigCACACaiICQQFyNgIEQYQTIAA2AgBB/BIgAjYCACAAIAJqIAI2AgAMBAsgAxAgDAELQewPQewPKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RB9A9qIQJB7A8oAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAhDAILQewPIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBgBMgACACayIBNgIAQYgTQYgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEGMFBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUH0DDYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJQALuAEBAX8jAEHgAWsiAyQAIANBOGpBzAgoAgA2AgAgA0EwakHECCkCADcDACADQgA3AyAgA0G8CCkCADcDKCADQTxqQQBBxAAQKhogA0EgaiABIAIQCSADQYABaiADQSBqQeAAECgaIANBCGogA0GAAWoQCiADQSBqIANBCGpBFBADIANBiAFqIANBKGooAgA2AgAgAyADKQMgNwOAASADIANBgAFqEAsgACADKQMANwIAIANB4AFqJAALlwMBBH8jAEFAaiIDJAAgACAAKQMAIAKtfDcDACADIABBCGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAhwiBQRAQcAAIAVrIgQgAk0NASADQRhqIAUgBSACaiIEIABBIGoQFiADKAIcIAJHDQUgAygCGCABIAIQKBoMAwsgAiEEDAELIANBMGogASACIAQQFyADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQSBqIgYgACgCHBAYIAIgAygCJEcNBCADKAIgIAUgAhAoGiAAQRxqQQA2AgAgA0EsaiAGEBkLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAXIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAaIANBLGogAygCCBAZDAALAAsgA0EQaiAAQSBqIAQQGyADKAIUIARHDQEgAygCECABIAQQKBoLIABBHGogBDYCACADQUBrJAAPC0H0ExAHAAtB9BMQBwALQfQTEAcAC+MCAgR/AX4jAEFAaiICJAAgAiABQQhqIgU2AiQgASkDACEGIAEoAhwhAyACIAJBJGo2AigCQCADQT9NBEAgAUEgaiIEIANqQYABOgAAIAEgASgCHEEBaiIDNgIcIAJBGGogBCADEBggAigCGEEAIAIoAhwQKhpBwAAgASgCHGtBB00EQCACQShqIAQQGSACQRBqIAQgAUEcaigCABAbIAIoAhBBACACKAIUECoaCyACQQhqIARBOBAYIAIoAgxBCEcNASACKAIIIAZCA4Y3AAAgAkEoaiAEEBkgAUEcakEANgIAIAJBADYCKEEEIQECQANAIAFBGEYNASACQShqIAFqQQA6AAAgAiACKAIoQQFqNgIoIAFBAWohAQwACwALIAAgBSkAADcAACAAQRBqIAVBEGooAAA2AAAgAEEIaiAFQQhqKQAANwAAIAJBQGskAA8LQcwTIANBwAAQHQALQdwTEAcAC2MBAn8gASgCACECAkACQCABKAIEIgMgASgCCCIBRgRAIAMhAQwBCyADIAFJDQEgAQRAIAIgARATIgINAQALIAIgAxARQQEhAkEAIQELIAAgATYCBCAAIAI2AgAPC0G0ExAHAAuQAQEBfyMAQYABayIBJAAgAUEwakHECCkCADcDACABQThqQcwIKAIANgIAIAFCADcDICABQbwIKQIANwMoIAFBPGpBAEHEABAqGiABQRBqIAFBIGpB4AAQAyABQShqIAFBGGooAgA2AgAgASABKQMQNwMgIAFBCGogAUEgahALIAAgASkDCDcCACABQYABaiQAC4YB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';

// cSpell:ignore noncefp, ndata, outputlen
/**
 * bitflags used in secp256k1's public API (translated from secp256k1.h)
 */
/* eslint-disable no-bitwise, @typescript-eslint/no-magic-numbers, @typescript-eslint/prefer-literal-enum-member */
/** All flags' lower 8 bits indicate what they're for. Do not use directly. */
// const SECP256K1_FLAGS_TYPE_MASK = (1 << 8) - 1;
const SECP256K1_FLAGS_TYPE_CONTEXT = 1 << 0;
const SECP256K1_FLAGS_TYPE_COMPRESSION = 1 << 1;
/** The higher bits contain the actual data. Do not use directly. */
const SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 1 << 8;
const SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 1 << 9;
const SECP256K1_FLAGS_BIT_COMPRESSION = 1 << 8;
/** Flags to pass to secp256k1_context_create. */
const SECP256K1_CONTEXT_VERIFY = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
const SECP256K1_CONTEXT_SIGN = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
const SECP256K1_CONTEXT_NONE = SECP256K1_FLAGS_TYPE_CONTEXT;
/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */
const SECP256K1_EC_COMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION;
const SECP256K1_EC_UNCOMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION;
/**
 * Flag to pass to a Secp256k1.contextCreate method.
 *
 * The purpose of context structures is to cache large precomputed data tables
 * that are expensive to construct, and also to maintain the randomization data
 * for blinding.
 *
 * You can create a context with only VERIFY or only SIGN capabilities, or you
 * can use BOTH. (NONE can be used for conversion/serialization.)
 */
var ContextFlag;
(function (ContextFlag) {
    ContextFlag[ContextFlag["NONE"] = SECP256K1_CONTEXT_NONE] = "NONE";
    ContextFlag[ContextFlag["VERIFY"] = SECP256K1_CONTEXT_VERIFY] = "VERIFY";
    ContextFlag[ContextFlag["SIGN"] = SECP256K1_CONTEXT_SIGN] = "SIGN";
    ContextFlag[ContextFlag["BOTH"] = SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY] = "BOTH";
})(ContextFlag || (ContextFlag = {}));
/**
 * Flag to pass a Secp256k1 public key serialization method.
 *
 * You can indicate COMPRESSED (33 bytes, header byte 0x02 or 0x03) or
 * UNCOMPRESSED (65 bytes, header byte 0x04) format.
 */
var CompressionFlag;
(function (CompressionFlag) {
    CompressionFlag[CompressionFlag["COMPRESSED"] = SECP256K1_EC_COMPRESSED] = "COMPRESSED";
    CompressionFlag[CompressionFlag["UNCOMPRESSED"] = SECP256K1_EC_UNCOMPRESSED] = "UNCOMPRESSED";
})(CompressionFlag || (CompressionFlag = {}));

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
const secp256k1Base64Bytes = 'AGFzbQEAAAABXg5gAn9/AGAGf39/f39/AX9gAX8AYAABf2AAAGADf39/AX9gAX8Bf2ACf38Bf2AEf39/fwF/YAV/f39/fwF/YAN/f38AYAd/f39/f39/AX9gBH9/f38AYAV/f39/fwAC5wEMA2VudgZtZW1vcnkCAYACgAIDZW52BXRhYmxlAXABBgYDZW52CXRhYmxlQmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudgVhYm9ydAACA2Vudg1lbmxhcmdlTWVtb3J5AAMDZW52DmdldFRvdGFsTWVtb3J5AAMDZW52F2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAMDZW52C19fX3NldEVyck5vAAIDZW52Bl9hYm9ydAAEA2VudhZfZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAUDSUgAAAYKBQAKCgIMAAYABwACBgUNCgAKAAoAAAcHAAAAAgYMCgoFAAUFAAULAQYFAwcBCAgBCAgKBwUFBQUHAQEIBQUFCAUICQgGCwJ/ASMBC38BIwILB/QGGxFfX19lcnJub19sb2NhdGlvbgA1BV9mcmVlACYHX21hbGxvYwAnGV9zZWNwMjU2azFfY29udGV4dF9jcmVhdGUAMxxfc2VjcDI1NmsxX2NvbnRleHRfcmFuZG9taXplAD4fX3NlY3AyNTZrMV9lY19wcml2a2V5X3R3ZWFrX2FkZABCH19zZWNwMjU2azFfZWNfcHJpdmtleV90d2Vha19tdWwAQBtfc2VjcDI1NmsxX2VjX3B1YmtleV9jcmVhdGUAMBpfc2VjcDI1NmsxX2VjX3B1YmtleV9wYXJzZQBOHl9zZWNwMjU2azFfZWNfcHVia2V5X3NlcmlhbGl6ZQBNHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX2FkZABBHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX211bAA/G19zZWNwMjU2azFfZWNfc2Vja2V5X3ZlcmlmeQBDGF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcgA5NF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcmFibGVfc2lnbmF0dXJlX3BhcnNlX2NvbXBhY3QAPDhfc2VjcDI1NmsxX2VjZHNhX3JlY292ZXJhYmxlX3NpZ25h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iCEuIAogLadJIAkgLKdJaiALICinSWogISAbRXFqIBkgE0VxaiAaIBRFcWogDiAbSWogByATSWogBSAUSWogECAISWogESAGSSAqQgGGpyIJciAiaiITaiIOIBIgBEkgK0IBhqciCnIgF2oiFGoiByAMIANJICVCAYanIgtyIBVqIhBqIgUgDSACSSAkQgGGpyIIciAWaiIRaiIGICOnIgRBAXQiEmoiASASSSEZIB8oAgCtICd+IiNCIIghLCABICOnIgNBAXQiDGoiASAMSSEaIBgoAgCtICZ+IiNCIIghKCABICOnIgJBAXQiDWoiASANSSEbIAogK6dJIAkgKqdJaiALICWnSWogCCAkp0lqICIgE0VxaiAOIBNJaiAXIBRFcWogByAUSWogFSAQRXFqIAUgEElqIBYgEUVxaiAGIBFJaiASIARJIC5CAYanIg5yIBlqIhVqIgogDCADSSAsQgGGpyIHciAaaiIWaiILIA0gAkkgKEIBhqciBXIgG2oiEGoiCCABIB4oAgCtIiQgJH4iI6ciAmoiASACSSAjQiCIp2oiBmohESAPIAE2AiAgICgCAK0iKSAcKAIArX4iI0IgiCEtIBEgI6ciBEEBdCIMaiIBIAxJIRMgHygCAK0iJyAdKAIArSImfiIjQiCIISogASAjpyIDQQF0Ig1qIgEgDUkhFCAYKAIArSIlICR+IiNCIIghJCABICOnIgJBAXQiCWoiASAJSSESIA8gATYCJCApICZ+IiNCIIghKyAHICynSSAOIC6nSWogBSAop0lqIBkgFUVxaiAaIBZFcWogGyAQRXFqIAogFUlqIAsgFklqIAggEElqIBEgBklqIAwgBEkgLUIBhqciB3IgE2oiDGoiCyANIANJICpCAYanIgVyIBRqIg1qIgggCSACSSAkQgGGpyIGciASaiIJaiIEICOnIgNBAXQiDmoiASAOSSEQICcgHigCAK0iJn4iI0IgiCEoIAEgI6ciAkEBdCIKaiIBIApJIREgBSAqp0kgByAtp0lqIAYgJKdJaiATIAxFcWogCyAMSWogFCANRXFqIAggDUlqIBIgCUVxaiAEIAlJaiAOIANJICtCAYanIgtyIBBqIhJqIgUgCiACSSAoQgGGpyIIciARaiIMaiIGIAEgJSAlfiIjpyICaiIBIAJJICNCIIinaiIEaiENIA8g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QUBrIAJB////H3EiAkHRB2pBGnZqQf///x9LIAYgAXEgB3EgCHEgBEH///8fcSIEcSAJcSALcUH///8fRiAFQf///wFGcXFyIgprQdEHcSACaiECIApBBnQgA2ogAkEadmoiA0EadiABQf///x9xaiIKQRp2IAZB////H3FqIgZBGnYgB0H///8fcWoiB0EadiAIQf///x9xaiIIQRp2IARqIgRBGnYgCUH///8fcWoiCUEadiALQf///x9xaiEBIAAgAkH///8fcTYCACANIANB////H3E2AgAgDiAKQf///x9xNgIAIA8gBkH///8fcTYCACAQIAdB////H3E2AgAgESAIQf///x9xNgIAIBIgBEH///8fcTYCACATIAlB////H3E2AgAgFCABQf///x9xNgIAIAwgAUEadiAFakH///8BcTYCAAuhFwEnfyMEIQQjBEHAA2okBCACKAJQIQYgASgCeARAIAAgBjYCeCAAIAIpAgA3AgAgACACKQIINwIIIAAgAikCEDcCECAAIAIpAhg3AhggACACKQIgNwIgIABBKGoiAyACQShqIgEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIABBATYCUCAAQdQAaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgIAQkBA8LIAYEQCADBEAgA0EBNgIAIANBBGoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJBADYCIAsgACABKQIANwIAIAAgASkCCDcCCCAAIAEpAhA3AhAgACABKQIYNwIYIAAgASkCIDcCICAAIAEpAig3AiggACABKQIwNwIwIAAgASkCODcCOCAAQUBrIAFBQGspAgA3AgAgACABKQJINwJIIAAgASkCUDcCUCAAIAEpAlg3AlggACABKQJgNwJgIAAgASkCaDcCaCAAIAEpAnA3AnAgACABKAJ4NgJ4IAQkBA8LIARB+ABqIQwgBEHQAGohJCAEQShqIQogAEH4AGoiKUEANgIAIARBkANqIiUgAUHQAGoiJhAHIARB6AJqIgggASkCADcCACAIIAEpAgg3AgggCCABKQIQNwIQIAggASkCGDcCGCAIIAEpAiA3AiAgCEEkaiIdKAIAIhNBFnYiBkHRB2wgCCgCAGohGyAGQQZ0IAhBBGoiFygCAGogG0EadmoiGEEadiAIQQhqIhkoAgBqIhpBGnYgCEEMaiIFKAIAaiIHQRp2IAhBEGoiDSgCAGoiFEEadiAIQRRqIhUoAgBqIg5BGnYgCEEYaiIPKAIAaiIQQRp2IAhBHGoiESgCAGoiEkEadiAIQSBqIgYoAgBqIRwgCCAbQf///x9xIio2AgAgFyAYQf///x9xIgs2AgAgGSAaQf///x9xIh42AgAgBSAHQf///x9xIh82AgAgDSAUQf///x9xIiA2AgAgFSAOQf///x9xIiE2AgAgDyAQQf///x9xIiI2AgAgESASQf///x9xIiM2AgAgBiAcQf///x9xIhs2AgAgHSAcQRp2IBNB////AXFqIhw2AgAgBEHAAmoiFiACICUQCiAEQZgCaiIJIAFBKGoiBikCADcCACAJIAYpAgg3AgggCSAGKQIQNwIQIAkgBikCGDcCGCAJIAYpAiA3AiAgCUEkaiInKAIAIh1BFnYiBkHRB2wgCSgCAGohDSAGQQZ0IAlBBGoiEygCAGogDUEadmoiFEEadiAJQQhqIhcoAgBqIhVBGnYgCUEMaiIYKAIAaiIOQRp2IAlBEGoiGSgCAGoiD0EadiAJQRRqIhooAgBqIhBBGnYgCUEYaiIFKAIAaiIRQRp2IAlBHGoiBygCAGoiEkEadiAJQSBqIgYoAgBqISggCSANQf///x9xIg02AgAgEyAUQf///x9xIhQ2AgAgFyAVQf///x9xIhU2AgAgGCAOQf///x9xIg42AgAgGSAPQf///x9xIg82AgAgGiAQQf///x9xIhA2AgAgBSARQf///x9xIhE2AgAgByASQf///x9xIhI2AgAgBiAoQf///x9xIgY2AgAgJyAoQRp2IB1B////AXFqNgIAIARB8AFqIgcgAkEoaiAlEAogByAHICYQCiAEQcgBaiIFQbzh//8AICprIBYoAgBqNgIAIAVB/P3//wAgC2sgFigCBGo2AgQgBUH8////ACAeayAWKAIIajYCCCAFQfz///8AIB9rIBYoAgxqNgIMIAVB/P///wAgIGsgFigCEGo2AhAgBUH8////ACAhayAWKAIUajYCFCAFQfz///8AICJrIBYoAhhqNgIYIAVB/P///wAgI2sgFigCHGo2AhwgBUH8////ACAbayAWKAIgajYCICAFQfz//wcgHGsgFigCJGo2AiRB/P//ByAnKAIAayECIARBoAFqIgtBvOH//wAgDWsgBygCAGo2AgAgC0H8/f//ACAUayAHKAIEajYCBCALQfz///8AIBVrIAcoAghqNgIIIAtB/P///wAgDmsgBygCDGo2AgwgC0H8////ACAPayAHKAIQajYCECALQfz///8AIBBrIAcoAhRqNgIUIAtB/P///wAgEWsgBygCGGo2AhggC0H8////ACASayAHKAIcajYCHCALQfz///8AIAZrIAcoAiBqNgIgIAsgAiAHKAIkajYCJCAFEBdFBEAgDCALEAcgJCAFEAcgCiAFICQQCiADBEAgAyAFKQIANwIAIAMgBSkCCDcCCCADIAUpAhA3AhAgAyAFKQIYNwIYIAMgBSkCIDcCIAsgAEHQAGogJiAFEAogBCAIICQQCiAAIAQpAgA3AgAgACAEKQIINwIIIAAgBCkCEDcCECAAIAQpAhg3AhggACAEKQIgNwIgQfj7//8BIABBBGoiEygCAEEBdCAKQQRqIh4oAgBqayEOQfj///8BIABBCGoiFygCAEEBdCAKQQhqIh8oAgBqayEPQfj///8BIABBDGoiGCgCAEEBdCAKQQxqIiAoAgBqayEQQfj///8BIABBEGoiGSgCAEEBdCAKQRBqIiEoAgBqayERQfj///8BIABBFGoiGigCAEEBdCAKQRRqIiIoAgBqayESQfj///8BIABBGGoiBSgCAEEBdCAKQRhqIiMoAgBqayEGQfj///8BIABBHGoiBygCAEEBdCAKQRxqIhsoAgBqayEDQfj///8BIABBIGoiDSgCAEEBdCAKQSBqIhwoAgBqayECQfj//w8gAEEkaiIUKAIAQQF0IApBJGoiHSgCAGprIQEgAEH4wv//ASAAKAIAQQF0IAooAgBqayAMKAIAaiIVNgIAIBMgDiAMKAIEaiIONgIAIBcgDyAMKAIIaiIPNgIAIBggECAMKAIMaiIQNgIAIBkgESAMKAIQaiIRNgIAIBogEiAMKAIUaiISNgIAIAUgBiAMKAIYaiIGNgIAIAcgAyAMKAIcaiIDNgIAIA0gAiAMKAIgaiICNgIAIBQgASAMKAIkaiIBNgIAIABBKGoiE0G0pP//AiAVayAEKAIAajYCACAAQSxqIhdB9Pn//wIgDmsgBCgCBGo2AgAgAEEwaiIYQfT///8CIA9rIAQoAghqNgIAIABBNGoiGUH0////AiAQayAEKAIMajYCACAAQThqIhpB9P///wIgEWsgBCgCEGo2AgAgAEE8aiIFQfT///8CIBJrIAQoAhRqNgIAIABBQGsiB0H0////AiAGayAEKAIYajYCACAAQcQAaiINQfT///8CIANrIAQoAhxqNgIAIABByABqIhRB9P///wIgAmsgBCgCIGo2AgAgAEHMAGoiFUH0//8XIAFrIAQoAiRqNgIAIBMgEyALEAogCiAKIAkQCiAKQbzh//8AIAooAgBrIg42AgAgHkH8/f//ACAeKAIAayIPNgIAIB9B/P///wAgHygCAGsiEDYCACAgQfz///8AICAoAgBrIhE2AgAgIUH8////ACAhKAIAayISNgIAICJB/P///wAgIigCAGsiBjYCACAjQfz///8AICMoAgBrIgM2AgAgG0H8////ACAbKAIAayICNgIAIBxB/P///wAgHCgCAGsiATYCACAdQfz//wcgHSgCAGsiADYCACATIBMoAgAgDmo2AgAgFyAXKAIAIA9qNgIAIBggGCgCACAQajYCACAZIBkoAgAgEWo2AgAgGiAaKAIAIBJqNgIAIAUgBSgCACAGajYCACAHIAcoAgAgA2o2AgAgDSANKAIAIAJqNgIAIBQgFCgCACABajYCACAVIBUoAgAgAGo2AgAgBCQEDwsgCxAXBEAgACABIAMQGiAEJAQPCyADBEAgA0IANwIAIANCADcCCCADQgA3AhAgA0IANwIYIANCADcCIAsgKUEBNgIAIAQkBAuvAwEBfyAAIAFBHGoiAigCAEEYdjoAACAAIAIoAgBBEHY6AAEgACACKAIAQQh2OgACIAAgAigCADoAAyAAIAFBGGoiAigCAEEYdjoABCAAIAIoAgBBEHY6AAUgACACKAIAQQh2OgAGIAAgAigCADoAByAAIAFBFGoiAigCAEEYdjoACCAAIAIoAgBBEHY6AAkgACACKAIAQQh2OgAKIAAgAigCADoACyAAIAFBEGoiAigCAEEYdjoADCAAIAIoAgBBEHY6AA0gACACKAIAQQh2OgAOIAAgAigCADoADyAAIAFBDGoiAigCAEEYdjoAECAAIAIoAgBBEHY6ABEgACACKAIAQQh2OgASIAAgAigCADoAEyAAIAFBCGoiAigCAEEYdjoA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BxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgByAGEAogBEHIAWoiBSAHKQIANwIAIAUgBykCCDcCCCAFIAcpAhA3AhAgBSAHKQIYNwIYIAUgBykCIDcCICAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUgBxAKIARBoAFqIgIgBSkCADcCACACIAUpAgg3AgggAiAFKQIQNwIQIAIgBSkCGDcCGCACIAUpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACIAUQCiAEQfgAaiIJIAIpAgA3AgAgCSACKQIINwIIIAkgAikCEDcCECAJIAIpAhg3AhggCSACKQIgNwIgQQAhBgNAIAkgCRAHIAZBAWoiBkHYAEcNAAsgCSAJIAIQCiADIAkpAgA3AgAgAyAJKQIINwIIIAMgCSkCEDcCECADIAkpAhg3AhggAyAJKQIgNwIgIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAyAFEAogCCADKQIANwIAIAggAykCCDcCCCAIIAMpAhA3AhAgCCADKQIYNwIYIAggAykCIDcCICAIIAgQByAIIAgQByAIIAgQByAIIAggChAKIAQgCCkCADcCACAEIAgpAgg3AgggBCAIKQIQNwIQIAQgCCkCGDcCGCAEIAgpAiA3AiAgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAcQCiAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQgARAKIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCALEAogBCAEEAcgBCAEEAcgACABIAQQCiAEJAQL7gQBG38gAEEkaiILKAIAIgJBFnYiAUHRB2wgACgCAGohBCABQQZ0IABBBGoiDCgCAGogBEEadmoiBUEadiAAQQhqIg0oAgBqIgZB////H3EhByAGQRp2IABBDGoiDigCAGoiCEEadiAAQRBqIg8oAgBqIQEgCEH///8fcSEJIAFB////H3EhCiABQRp2IABBFGoiECgCAGoiEUEadiAAQRhqIhIoAgBqIRMgEUH///8fcSEUIBNBGnYgAEEcaiIVKAIAaiIWQRp2IABBIGoiFygCAGohAyAWQf///x9xIRggA0H///8fcSEZIANBGnYgAkH///8BcWoiAkEWdiAFQf///x9xIgVBQGsgBEH///8fcSIEQdEHaiIaQRp2IhtqQf///x9LIAggBnEgAXEgEXEgE0H///8fcSIBcSAWcSADcUH///8fRiACQf///wFGcXFyIgNFBEAgACAENgIAIAwgBTYCACANIAc2AgAgDiAJNgIAIA8gCjYCACAQIBQ2AgAgEiABNgIAIBUgGDYCACAXIBk2AgAgCyACNgIADwsgGyAFaiADQQZ0aiIDQRp2IAdqIgRBGnYgCWoiBkEadiAKaiIHQRp2IBRqIghBGnYgAWoiAUEadiAYaiIJQRp2IBlqIgpBGnYgAmpB////AXEhAiAAIBpB////H3E2AgAgDCADQf///x9xNgIAIA0gBEH///8fcTYCACAOIAZB////H3E2AgAgDyAHQf///x9xNgIAIBAgCEH///8fcTYCACASIAFB////H3E2AgAgFSAJQf///x9xNgIAIBcgCkH///8fcTYCACALIAI2AgALsAIBCn8gACgCJCIBQRZ2IgJB0QdsIAAoAgBqIgNB////H3EiBEHQB3MhBSAEQQBHIAVB////H0dxBEBBAA8LIANBGnYgAkEGdHIgACgCBGoiAkEadiAAKAIIaiIDQRp2IAAoAgxqIgZBGnYgACgCEGoiB0EadiAAKAIUaiIIQRp2IAAoAhhqIglBGnYgACgCHGoiCkEadiAAKAIgaiIAQRp2IAFB////AXFqIQEgAkHAAHMgBXEgA3EgBnEgB3EgCHEgCXEgCnEgAHEgAUGAgIAec3FB////H0YEf0EBBSACQf///x9xIARyIANB////H3FyIAZB////H3FyIAdB////H3FyIAhB////H3FyIAlB////H3FyIApB////H3FyIABB////H3FyIAFyRQtBAXELmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyAEQXxxIgVBQGohBiABIAFBCHRyIAFBEHRyIAFBGHRyIQMDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIMIAAgAzYCECAAIAM2AhQgACADNgIYIAAgAzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBQGshAAwBCwsDQCAAIAVIBEAgACADNgIAIABBBGohAAwBCwsLA0AgACAESARAIAAgAToAACAAQQFqIQAMAQsLIAQgAmsLqy8BnwF/IwQhDSMEQbAmaiQEIA1BgCZqIQ4gDUHYJWohESANQdgkaiEGIA1BhCRqIRIgDUGwI2ohDCANQcgfaiEWIA1ByBdqIUkgDUHoD2ohBSANQagNaiEJIA1BiAhqIQsCfwJAIAMoAgQgAygCAHIgAygCCHIgAygCDHIgAygCEHIgAygCFHIgAygCGHIgAygCHHJFDQAgAigCeA0AIA1BhAhqIgpBADYCACANQYAIaiANIANBBRArIgM2AgAgBiACIAooAgAiD0H8AGxqIhBBABAaIAwgBikCADcCACAMIAYpAgg3AgggDCAGKQIQNwIQIAwgBikCGDcCGCAMIAYpAiA3AiAgDEEoaiIKIAZBKGoiCCkCADcCACAKIAgpAgg3AgggCiAIKQIQNwIQIAogCCkCGDcCGCAKIAgpAiA3AiAgDEEANgJQIA4gBkHQAGoiChAHIBEgDiAKEAogEiAQIA4QCiASQShqIgggAiAPQfwAbGpBKGogERAKIBIgAiAPQfwAbGooAng2AlAgBSASKQIANwIAIAUgEikCCDcCCCAFIBIpAhA3AhAgBSASKQIYNwIYIAUgEikCIDcCICAFQShqIhAgCCkCADcCACAQIAgpAgg3AgggECAIKQIQNwIQIBAgCCkCGDcCGCAQIAgpAiA3AiAgBUHQAGoiCCACIA9B/ABsakHQAGoiAikCADcCACAIIAIpAgg3AgggCCACKQIQNwIQIAggAikCGDcCGCAIIAIpAiA3AiAgBUH4AGoiE0EANgIAIAkgCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgBUH8AGoiAiAFIAwgCUEoaiIUEBAgBUH4AWoiCCACIAwgCUHQAGoiBxAQIAVB9AJqIgIgCCAMIAlB+ABqIh0QECAFQfADaiIIIAIgDCAJQaABaiIeEBAgBUHsBGoiAiAIIAwgCUHIAWoiHxAQIAVB6AVqIg8gAiAMIAlB8AFqIiEQECAFQeQGaiIIIA8gDCAJQZgCaiIPEBAgBUG0B2oiAiACIAoQCiALQcwEaiIJIAgpAgA3AgAgCSAIKQIINwIIIAkgCCkCEDcCECAJIAgpAhg3AhggCSAIKQIgNwIgIAtB9ARqIgkgBUGMB2oiCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgC0GYBWoiIigCACIjQRZ2IghB0QdsIAkoAgBqIQogCEEGdCALQfgEaiIkKAIAaiAKQRp2aiIlQRp2IAtB/ARqIiYoAgBqIidBGnYgC0GABWoiKCgCAGoiKUEadiALQYQFaiIqKAIAaiIrQRp2IAtBiAVqIiwoAgBqIi1BGnYgC0GMBWoiLigCAGoiL0EadiALQZAFaiIwKAIAaiIxQRp2IAtBlAVqIjIoAgBqIQggCSAKQf///x9xNgIAICQgJUH///8fcTYCACAmICdB////H3E2AgAgKCApQf///x9xNgIAICogK0H///8fcTYCACAsIC1B////H3E2AgAgLiAvQf///x9xNgIAIDAgMUH///8fcTYCACAyIAhB////H3E2AgAgIiAIQRp2ICNB////AXFqNgIAIBYgAikCADcCACAWIAIpAgg3AgggFiACKQIQNwIQIBYgAikCGDcCGCAWIAIpAiA3AiAgC0EANgKcBSAGIA8pAgA3AgAgBiAPKQIINwIIIAYgDykCEDcCECAGIA8pAhg3AhggBiAPKQIgNwIgIA4gBhAHIBEgDiAGEAogC0H4A2ogBUHoBWogDhAKIAtBoARqIAVBkAZqIBEQCiALIAUoAuAGNgLIBCAGIAYgIRAKIA4gBhAHIBEgDiAGEAogC0GkA2ogBUHsBGogDhAKIAtBzANqIAVBlAVqIBEQCiALIAUoAuQFNgL0AyAGIAYgHxAKIA4gBhAHIBEgDiAGEAogC0HQAmogBUHwA2ogDhAKIAtB+AJqIAVBmARqIBEQCiALIAUoAugENgKgAyAGIAYgHhAKIA4gBhAHIBEgDiAGEAogC0H8AWogBUH0AmogDhAKIAtBpAJqIAVBnANqIBEQCiALIAUoAuwDNgLMAiAGIAYgHRAKIA4gBhAHIBEgDiAGEAogC0GoAWogBUH4AWogDhAKIAtB0AFqIAVBoAJqIBEQCiALIAUoAvACNgL4ASAGIAYgBxAKIA4gBhAHIBEgDiAGEAogC0HUAGogBUH8AGogDhAKIAtB/ABqIAVBpAFqIBEQCiALIAUoAvQBNgKkASAGIAYgFBAKIA4gBhAHIBEgDiAGEAogCyAFIA4QCiALQShqIBAgERAKIAsgEygCADYCUEEBIUogA0EASgR/IAMFQQALDAELIBZBATYCACAWQQRqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiBBASFLQQALIQIgBARAIEkgBEEPECsiAyFMIAMgAkoEQCADIQILCyABQfgAaiIdQQE2AgAgAUIANwIAIAFCADcCCCABQgA3AhAgAUIANwIYIAFCADcCICABQgA3AiggAUIANwIwIAFCADcCOCABQUBrQgA3AgAgAUIANwJIIAFCADcCUCABQgA3AlggAUIANwJgIAFCADcCaCABQgA3AnAgAkEATARAIA0kBA8LIA1B6CFqISsgDUHwIGohLCANQcggaiFNIA1B8B9qIgVB0ABqIWogAUHQAGohHiAGQQRqIU4gBkEIaiFPIAZBDGohUCAGQRBqIVEgBkEUaiFSIAZBGGohUyAGQRxqIVQgBkEgaiFVIAZBJGohViABQShqIRMgDEEEaiFXIAxBCGohWCAMQQxqIVkgDEEQaiFaIAxBFGohWyAMQRhqIVwgDEEcaiFdIAxBIGohXiAMQSRqIV8gBUEoaiFgIA1B4CJqIghBBGohayAIQQhqIWwgCEEMaiFtIAhBEGohbiAIQRRqIW8gCEEYaiFwIAhBHGohcSAIQSBqIXIgCEEkaiFzIBJBBGohdCASQQhqIXUgEkEMaiF2IBJBEGohdyASQRRqIXggEkEYaiF5IBJBHGoheiASQSBqIXsgEkEkaiF8IA1BuCJqIhBBBGohfSAQQQhqIX4gEEEMaiF/IBBBEGohgAEgEEEUaiGBASAQQRhqIYIBIBBBHGohgwEgEEEgaiGEASAQQSRqIYUBIA1BiCNqIg9BBGohhgEgD0EIaiGHASAPQQxqIYgBIA9BEGohiQEgD0EUaiGKASAPQRhqIYsBIA9BHGohjAEgD0EgaiGNASAPQSRqIY4BIAFBBGohYSABQQhqIWIgAUEMaiFjIAFBEGohZCABQRRqIWUgAUEYaiFmIAFBHGohZyABQSBqIWggAUEkaiFpIA1BwCFqIgpBBGohLSAKQQhqIS4gCkEMaiEvIApBEGohMCAKQRRqITEgCkEYaiEyIApBHGohOSAKQSBqITogCkEkaiE7IA1BkCJqIhRBBGohjwEgFEEIaiGQASAUQQxqIZEBIBRBEGohkgEgFEEUaiGTASAUQRhqIZQBIBRBHGohlQEgFEEgaiGWASAUQSRqIZcBIAFBLGohPCABQTBqIT0gAUE0aiE+IAFBOGohPyABQTxqIUAgAUFAayFBIAFBxABqIUIgAUHIAGohQyABQcwAaiFEIA1BmCFqIglBBGohmAEgCUEIaiGZASAJQQxqIZoBIAlBEGohmwEgCUEUaiGcASAJQRhqIZ0BIAlBHGohngEgCUEgaiGfASAJQSRqIaABIAFB0ABqIaEBIAFB1ABqIR8gBUEoaiEhIAVBLGohIiAFQTBqISMgBUE0aiEkIAVBOGohJSAFQTxqISYgBUFAayEnIAVBxABqISggBUHIAGohKSAFQcwAaiEqIA1BgAhqKAIAIaIBA0AgAkF/aiEEIAEgAUEAEBogSyACIKIBSnJFBEBBACEDA0AgDSADQYgIbGogBEECdGooAgAiBwRAIAsgA0EDdEHUAGxqIRUgB0EASgRAIAUgFSAHQX9qQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAFIAUgFSAHQX9zQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAgIUG84f//ACAhKAIAazYCACAiQfz9//8AICIoAgBrNgIAICNB/P///wAgIygCAGs2AgAgJEH8////ACAkKAIAazYCACAlQfz///8AICUoAgBrNgIAICZB/P///wAgJigCAGs2AgAgJ0H8////ACAnKAIAazYCACAoQfz///8AICgoAgBrNgIAIClB/P///wAgKSgCAGs2AgAgKkH8//8HICooAgBrNgIACyABIAEgBUEAEBALIANBAWoiAyBKRw0ACwsgAiBMTARAIEkgBEECdGooAgAiAwRAIAAoAgAhByADQQBKBEAgBSAHIANBf2pBAm1BBnRqECMFIAUgByADQX9zQQJtQQZ0ahAjICFBvOH//wAgISgCAGs2AgAgIkH8/f//ACAiKAIAazYCACAjQfz///8AICMoAgBrNgIAICRB/P///wAgJCgCAGs2AgAgJUH8////ACAlKAIAazYCACAmQfz///8AICYoAgBrNgIAICdB/P///wAgJygCAGs2AgAgKEH8////ACAoKAIAazYCACApQfz///8AICkoAgBrNgIAICpB/P//ByAqKAIAazYCAAsCQCBqKAIARQRAIB0oAgAEQCAdQQA2AgAgLCAWEAcgTSAsIBYQCiABIAUgLBAKIBMgYCBNEAogoQFBATYCACAfQgA3AgAgH0IANwIIIB9CADcCECAfQgA3AhggH0EANgIgDAILIB1BADYCACAOIB4gFhAKIBEgDhAHIAYgASkCADcCACAGIAEpAgg3AgggBiABKQIQNwIQIAYgASkCGDcCGCAGIAEpAiA3AiAgVigCACIVQRZ2IgdB0QdsIAYoAgBqIQMgB0EGdCBOKAIAaiADQRp2aiIXQRp2IE8oAgBqIhhBGnYgUCgCAGoiGUEadiBRKAIAaiIaQRp2IFIoAgBqIhtBGnYgUygCAGoiHEEadiBUKAIAaiIgQRp2IFUoAgBqIQcgBiADQf///x9xIkU2AgAgTiAXQf///x9xIhc2AgAgTyAYQf///x9xIhg2AgAgUCAZQf///x9xIhk2AgAgUSAaQf///x9xIho2AgAgUiAbQf///x9xIhs2AgAgUyAcQf///x9xIhw2AgAgVCAgQf///x9xIiA2AgAgVSAHQf///x9xIkY2AgAgViAHQRp2IBVB////AXFqIhU2AgAgEiAFIBEQCiAMIBMpAgA3AgAgDCATKQIINwIIIAwgEykCEDcCECAMIBMpAhg3AhggDCATKQIgNwIgIF8oAgAiR0EWdiIHQdEHbCAMKAIAaiEDIAdBBnQgVygCAGogA0EadmoiM0EadiBYKAIAaiI0QRp2IFkoAgBqIjVBGnYgWigCAGoiNkEadiBbKAIAaiI3QRp2IFwoAgBqIjhBGnYgXSgCAGoiSEEadiBeKAIAaiEHIAwgA0H///8fcSIDNgIAIFcgM0H///8fcSIzNgIAIFggNEH///8fcSI0NgIAIFkgNUH///8fcSI1NgIAIFogNkH///8fcSI2NgIAIFsgN0H///8fcSI3NgIAIFwgOEH///8fcSI4NgIAIF0gSEH///8fcSJINgIAIF4gB0H///8fcSKjATYCACBfIAdBGnYgR0H///8BcWoiBzYCACAPIGAgERAKIA8gDyAOEAogCEG84f//ACBFayASKAIAajYCACBrQfz9//8AIBdrIHQoAgBqNgIAIGxB/P///wAgGGsgdSgCAGo2AgAgbUH8////ACAZayB2KAIAajYCACBuQfz///8AIBprIHcoAgBqNgIAIG9B/P///wAgG2sgeCgCAGo2AgAgcEH8////ACAcayB5KAIAajYCACBxQfz///8AICBrIHooAgBqNgIAIHJB/P///wAgRmsgeygCAGo2AgAgc0H8//8HIBVrIHwoAgBqNgIAIBBBvOH//wAgA2sgDygCAGo2AgAgfUH8/f//ACAzayCGASgCAGo2AgAgfkH8////ACA0ayCHASgCAGo2AgAgf0H8////ACA1ayCIASgCAGo2AgAggAFB/P///wAgNmsgiQEoAgBqNgIAIIEBQfz///8AIDdrIIoBKAIAajYCACCCAUH8////ACA4ayCLASgCAGo2AgAggwFB/P///wAgSGsgjAEoAgBqNgIAIIQBQfz///8AIKMBayCNASgCAGo2AgAghQFB/P//ByAHayCOASgCAGo2AgAgCBAXRQRAIBQgEBAHICsgCBAHIAogCCArEAogHiAeIAgQCiAJIAYgKxAKIAEgCSkCADcCACABIAkpAgg3AgggASAJKQIQNwIQIAEgCSkCGDcCGCABIAkpAiA3AiAgLSgCACEDIC4oAgAhByAvKAIAIRUgMCgCACEXIDEoAgAhGCAyKAIAIRkgOSgCACEaIDooAgAhGyA7KAIAIRwgYSgCAEF+bCEgIGIoAgBBfmwhRSBjKAIAQX5sIUYgZCgCAEF+bCFHIGUoAgBBfmwhMyBmKAIAQX5sITQgZygCAEF+bCE1IGgoAgBBfmwhNiBpKAIAQX5sITcgASABKAIAQX5sQfjC//8BaiAKKAIAayAUKAIAaiI4NgIAIGEgIEH4+///AWogA2sgjwEoAgBqIgM2AgAgYiBFQfj///8BaiAHayCQASgCAGoiBzYCACBjIEZB+P///wFqIBVrIJEBKAIAaiIVNgIAIGQgR0H4////AWogF2sgkgEoAgBqIhc2AgAgZSAzQfj///8BaiAYayCTASgCAGoiGDYCACBmIDRB+P///wFqIBlrIJQBKAIAaiIZNgIAIGcgNUH4////AWogGmsglQEoAgBqIho2AgAgaCA2Qfj///8BaiAbayCWASgCAGoiGzYCACBpIDdB+P//D2ogHGsglwEoAgBqIhw2AgAgE0G0pP//AiA4ayAJKAIAajYCACA8QfT5//8CIANrIJgBKAIAajYCACA9QfT///8CIAdrIJkBKAIAajYCACA+QfT///8CIBVrIJoBKAIAajYCACA/QfT///8CIBdrIJsBKAIAajYCACBAQfT/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NwIIIAAgAykCEDcCECAAIAMpAhg3AhggACADKQIgNwIgQfb6/78CIABBBGoiASgCAEECdGshD0H2//+/AiAAQQhqIhAoAgBBAnRrIRFB9v//vwIgAEEMaiIbKAIAQQJ0ayEcQfb//78CIABBEGoiHSgCAEECdGshHkH2//+/AiAAQRRqIh8oAgBBAnRrISBB9v//vwIgAEEYaiIhKAIAQQJ0ayEiQfb//78CIABBHGoiIygCAEECdGshJEH2//+/AiAAQSBqIiUoAgBBAnRrISZB9v//EyAAQSRqIicoAgBBAnRrISggAEHWs/+/AiAAKAIAQQJ0ayAHKAIAIilqNgIAIAEgDyAHQQRqIg8oAgAiAWo2AgAgECARIAdBCGoiECgCACIRajYCACAbIBwgB0EMaiIbKAIAIhxqNgIAIB0gHiAHQRBqIh0oAgAiHmo2AgAgHyAgIAdBFGoiHygCACIgajYCACAhICIgB0EYaiIhKAIAIiJqNgIAICMgJCAHQRxqIiMoAgAiJGo2AgAgJSAmIAdBIGoiJSgCACImajYCACAnICggB0EkaiInKAIAIihqNgIAIAIoAgBBBmwhKiAGKAIAQQZsISsgCCgCAEEGbCEsIAkoAgBBBmwhLSAKKAIAQQZsIS4gCygCAEEGbCEvIAwoAgBBBmwhMCANKAIAQQZsITEgDigCAEEGbCEyIAMgAygCAEEGbEG84f//ACApa2o2AgAgAiAqQfz9//8AIAFrajYCACAGICtB/P///wAgEWtqNgIAIAggLEH8////ACAca2o2AgAgCSAtQfz///8AIB5rajYCACAKIC5B/P///wAgIGtqNgIAIAsgL0H8////ACAia2o2AgAgDCAwQfz///8AICRrajYCACANIDFB/P///wAgJmtqNgIAIA4gMkH8//8HIChrajYCACAAQShqIgEgBSADEAogB0Ga0v+/ASAEKAIAayICNgIAIA9B+vz/vwEgEigCAGsiAzYCACAQQfr//78BIBMoAgBrIgU2AgAgG0H6//+/ASAUKAIAayIHNgIAIB1B+v//vwEgFSgCAGsiBjYCACAfQfr//78BIBYoAgBrIgg2AgAgIUH6//+/ASAXKAIAayIJNgIAICNB+v//vwEgGCgCAGsiCjYCACAlQfr//78BIBkoAgBrIgs2AgAgJ0H6//8LIBooAgBr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BGohBCAGIAgQDEEBIANrIgNBwABJBH8gBAUgAkGBf2oiDUFAcSIOIAJrQcSSBGohBSADIQIgBCEDA0AgCCADKQAANwAAIAggAykACDcACCAIIAMpABA3ABAgCCADKQAYNwAYIAggAykAIDcAICAIIAMpACg3ACggCCADKQAwNwAwIAggAykAODcAOCADQUBrIQMgBiAIEAwgAkFAaiICQcAATw0ACyANIA5rIQMgBQshAiADBEAgAiEEQQAhAgwCCwsMAQsgCCACaiAEIAMQCxoLIAogECgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCAQIAJBNyACa0E/cUEBaiIDajYCACAGQSBqIQUCQAJAIANBwAAgAkE/cSICayIESQRAQfmMBCEEDAEFIAUgAmpB+YwEIAQQCxogBEH5jARqIQIgBiAFEAwgAyAEayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAIAIhBEEAIQIMAgsLDAELIAUgAmogBCADEAsaCyAQKAIAIgJBP3EhBCAQIAJBCGo2AgAgBkEgaiEFAkACQEHAACAEayIDQQhLBEAgCiECQQghAwwBBSAFIARqIAogAxALGiAKIANqIQIgBiAFEAxBCCADayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAQQAhBAwCCwsMAQsgBSAEaiACIAMQCxoLIAYoAgAQCSESIAZBADYCACAGQQRqIh4oAgAQCSEIIB5BADYCACAGQQhqIh8oAgAQCSENIB9BADYCACAGQQxqIiAoAgAQCSEOICBBADYCACAGQRBqIiEoAgAQCSEFICFBADYCACAGQRRqIiMoAgAQCSEEICNBADYCACAGQRhqIhMoAgAQCSEDIBNBADYCACAGQRxqIh0oAgAQ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EAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADIAIQDSAEQaABaiICIAMQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAJEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAKEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBhANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAsQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAMEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAEQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCAAIAIgBxANIAQkBAvYAwETfyMEIQIjBEHQAGokBCACIAFB0ABqEAcgAiACIAAQCiABKAIkIgZBFnYiAEHRB2wgASgCAGohBCAAQQZ0IAEoAgRqIARBGnZqIgdBGnYgASgCCGoiCEEadiABKAIMaiIJQRp2IAEoAhBqIgpBGnYgASgCFGoiC0EadiABKAIYaiIMQRp2IAEoAhxqIg1BGnYgASgCIGohBUH8/f//ACACKAIEayEOQfz///8AIAIoAghrIQ9B/P///wAgAigCDGshEEH8////ACACKAIQayERQfz///8AIAIoAhRrIRJB/P///wAgAigCGGshE0H8////ACACKAIcayEUQfz///8AIAIoAiBrIQEgAigCJCEAIAJBKGoiA0G84f//ACACKAIAayAEQf///x9xajYCACADIA4gB0H///8fcWo2AgQgAyAPIAhB////H3FqNgIIIAMgECAJQf///x9xajYCDCADIBEgCkH///8fcWo2AhAgAyASIAtB////H3FqNgIUIAMgEyAMQf///x9xajYCGCADIBQgDUH///8fcWo2AhwgAyABIAVB////H3FqNgIgIAMgBkH///8BcUH8//8HaiAAayAFQRp2ajYCJCADEBchACACJAQgAAuXEAEKfyMEIQQjBEHgA2okBCAEQdAAaiEDIARBKGohCCAEQbgDaiILIAEQByALIAsgARAKIARBkANqIgogCxAHIAogCiABEAogBEHoAmoiBiAKKQIANwIAIAYgCikCCDcCCCAGIAopAhA3AhAgBiAKKQIYNwIYIAYgCikCIDcCICAGIAYQByAGIAYQByAGIAYQByAGIAYgChAKIARBwAJqIgIgBikCADcCACACIAYpAgg3AgggAiAGKQIQNwIQIAIgBikCGDcCGCACIAYpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACIAoQCiAEQZgCaiIGIAIpAgA3AgAgBiACKQIINwIIIAYgAikCEDcCECAGIAIpAhg3AhggBiACKQIgNwIgIAYgBhAHIAYgBhAHIAYgBiALEAogBEHwAWoiByAGKQIANwIAIAcgBikCCDcCCCAHIAYpAhA3AhAgByAGKQIYNwIYIAcgBikCIDcCICAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcgBhAKIARByAFqIgUgBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFIAcQCiAEQaABaiICIAUpAgA3AgAgAiAFKQIINwIIIAIgBSkCEDcCECACIAUpAhg3AhggAiAFKQIgNwIgIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAiAFEAogBEH4AGoiCSACKQIANwIAIAkgAikCCDcCCCAJIAIpAhA3AhAgCSACKQIYNwIYIAkgAikCIDcCIEEAIQYDQCAJIAkQByAGQQFqIgZB2ABHDQALIAkgCSACEAogAyAJKQIANwIAIAMgCSkCCDcCCCADIAkpAhA3AhAgAyAJKQIYNwIYIAMgCSkCIDcCICADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMgBRAKIAggAykCADcCACAIIAMpAgg3AgggCCADKQIQNwIQIAggAykCGDcCGCAIIAMpAiA3AiAgCCAIEAcgCCAIEAcgCCAIEAcgCCAIIAoQCiAEIAgpAgA3AgAgBCAIKQIINwIIIAQgCCkCEDcCECAEIAgpAhg3AhggBCAIKQIgNwIgIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCAHEAogBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAsQCiAEIAQQByAAIAQQByAEIAAQB0G84f//ACAEKAIAayABKAIAaiABKAIkQfz//wcgBCgCJGtqIgpBFnYiBkHRB2xqIQBB/P///wAgBCgCIGsgASgC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ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEAwgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQCxoLIAYoAgAQCSEIIAZBADYCACAKKAIAEAkhCSAKQQA2AgAgCygCABAJIQogC0EANgIAIAwoAgAQCSELIAxBADYCACANKAIAEAkhByANQQA2AgAgDigCABAJIQMgDkEANgIAIA8oAgAQCSECIA9BADYCACARKAIAEAkhASAFIAg2AgAgBSAJNgIEIAUgCjYCCCAFIAs2AgwgBSAHNgIQIAUgAzYCFCAFIAI2AhggBSABNgIcIAAgBSAQEA4gBSQEC+YBAQN/IABB4ABqIgMoAgAiBEE/cSEFIAMgBCACajYCAEHAACAFayIEIAJNBEAgAEEgaiIDIAVqIAEgBBALGiABIARqIQEgACADEAwgAiAEayICQcAASQRAQQAhBQUDQCADIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABggAyABKQAgNwAgIAMgASkAKDcAKCADIAEpADA3ADAgAyABKQA4NwA4IAFBQGshASAAIAMQDCACQUBqIgJBwABPDQBBACEFCwsLIAJFBEAPCyAAQSBqIAVqIAEgAhALGgvASwEzfyMEIQkjBEHwAWokBCAAQoGChIiQoMCAATcCACAAQoGChIiQoMCAATcCCCAAQoGChIiQoMCAATcCECAAQoGChIiQoMCAATcCGCAAQSBqIhlCADcCACAZQgA3AgggGUIANwIQIBlCADcCGCAJIgogGRATIApB4ABqIg0oAgAiCUE/cSEEIA0gCUEgajYCACAKQSBqIQsCQAJAQcAAIARrIglBIEsEQCAAIQkgBCEDQSAhCAwBBSALIARqIAAgCRALGiAAIAlqIQMgCiALEAxBICAJayIIQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCAIIQkgAyEIA0AgCyAIKQAANwAAIAsgCCkACDcACCALIAgpABA3ABAgCyAIKQAYNwAYIAsgCCkAIDcAICALIAgpACg3ACggCyAIKQAwNwAwIAsgCCkAODcAOCAIQUBrIQggCiALEAwgCUFAaiIJQcAATw0ACyAHIAZrIQggBAshCSAIBEBBACEDDAILCwwBCyAL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cXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYCAAJAAkBBwAAgA2siBEEgSwRAIAghASADIQJBICEDDAEFIAUgA2ogCCAEEAsaIAggBGohAiAMIAUQDEEgIARrIgFBwABJBH8gASEDIAIFIANBoH9qIgNBBnZBAXQhBiAEQUBqIQQDQCAFIAIpAAA3AAAgBSACKQAINwAIIAUgAikAEDcAECAFIAIpABg3ABggBSACKQAgNwAgIAUgAikAKDcAKCAFIAIpADA3ADAgBSACKQA4NwA4IAJBQGshAiAMIAUQDCABQUBqIgFBwABPDQALIANBP3EhAyAIIAZBBGpBBXRqIARqCyEBIAMEQEEAIQIMAgsLDAELIAUgAmogASADEAsaCyAJIBEoAgAiAUEddkEYdDYCACAJIAFBC3RBgID8B3EgAUEbdHIgAUEFdkGA/gNxciABQRV2Qf8BcXI2AgQgESABQTcgAWtBP3FBAWoiAmo2AgACQAJAIAJBwAAgAUE/cSIBayIDSQRAQfmMBCEDDAEFIAUgAWpB+YwEIAMQCxogA0H5jARqIQEgDCAFEAwgAiADayICQcAATwRAA0AgBSABKQAANwAAIAUgASkACDcACCAFIAEpABA3ABAgBSABKQAYNwAYIAUgASkAIDcAICAFIAEpACg3ACggBSABKQAwNwAwIAUgASkAODcAOCABQUBrIQEgDCAFEAwgAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAUgAWogAyACEAsaCyARKAIAIgFBP3EhAyARIAFBCGo2AgACQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAUgA2ogCSACEAsaIAkgAmohASAMIAUQDEEIIAJrIgJBwABPBEADQCAFIAEpAAA3AAAgBSABKQAINwAIIAUgASkAEDcAECAFIAEpABg3ABggBSABKQAgNwAgIAUgASkAKDcAKCAFIAEpADA3ADAgBSABKQA4NwA4IAFBQGshASAMIAUQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAFIANqIAEgAhALGgsgDCgCABAJIQ4gDEEANgIAIBMoAgAQCSELIBNBADYCACAUKAIAEAkhByAUQQA2AgAgFSgCABAJIQYgFUEANgIAIBYoAgAQCSEEIBZBADYCACAXKAIAEAkhAyAXQQA2AgAgGCgCABAJIQIgGEEANgIAICEoAgAQCSEBICFBADYCACAuIA42AAAgLyALNgAAIDAgBzYAACAxIAY2AAAgMiAENgAAIDMgAzYAACA0IAI2AAAgNSABNgAAIAogGRATIA0oAgAiAUE/cSEEIA0gAUEgajYCACAKQSBqIQsCQAJAQcAAIARrIgFBIEsEQCAAIQEgBCEDQSAhAgwBBSALIARqIAAgARALGiAAIAFqIQMgCiALEAxBICABayICQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCACIQEgAyECA0AgCyACKQAANwAAIAsgAikACDcACCALIAIpABA3ABAgCyACKQAYNwAYIAsgAikAIDcAICALIAIpACg3ACggCyACKQAwNwAwIAsgAikAODcAOCACQUBrIQIgCiALEAwgAUFAaiIBQcAATw0ACyAHIAZrIQIgBAshASACBEBBACEDDAILCwwBCyALIANqIAEgAhALGgsgCSANKAIAIgFBHXZBGHQ2AgAgCSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYC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AEIANwIQIABCADcCGAsgASABKAIAIARqNgIAIAMkBEEBC9YDAQN/IwQhAyMEQYABaiQEIAAgASkCADcCACAAIAEpAgg3AgggACABKQIQNwIQIAAgASkCGDcCGCAAIAEpAiA3AiAgA0HQAGoiBSABEAcgA0EoaiIEIAEgBRAKIABBADYCUCADIAQoAgBBB2o2AgAgAyAEKAIENgIEIAMgBCgCCDYCCCADIAQoAgw2AgwgAyAEKAIQNgIQIAMgBCgCFDYCFCADIAQoAhg2AhggAyAEKAIcNgIcIAMgBCgCIDYCICADIAQoAiQ2AiQgAEEoaiIFIAMQIkUEQCADJARBAA8LIAUQFiAFKAIAIgFBAXEgAkYEQCADJARBAQ8LIAVBvOH//wAgAWs2AgAgAEEsaiIBQfz9//8AIAEoAgBrNgIAIABBMGoiAUH8////ACABKAIAazYCACAAQTRqIgFB/P///wAgASgCAGs2AgAgAEE4aiIBQfz///8AIAEoAgBrNgIAIABBPGoiAUH8////ACABKAIAazYCACAAQUBrIgFB/P///wAgASgCAGs2AgAgAEHEAGoiAUH8////ACABKAIAazYCACAAQcgAaiIBQfz///8AIAEoAgBrNgIAIABBzABqIgBB/P//ByAAKAIAazYCACADJARBAQv2CwIRfwJ+IwQhBSMEQaADaiQEIAVBuAJqIgJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUUEQCAAQQA2ApwBIABBJGoiA0GQiAQpAgA3AgAgA0GYiAQpAgA3AgggA0GgiAQpAgA3AhAgA0GoiAQpAgA3AhggA0GwiAQpAgA3AiAgAEEBNgJ0IABB+ABqIgNCADcCACADQgA3AgggA0IANwIQIANCADcCGCADQQA2AiAgAEGEuLznADYCTCAAQf61r/AANgJQIABBuMz59QA2AlQgAEHny/X2ADYCWCAAQcjQi/gANgJcIABB0vvu4wA2AmAgAEG8gMHtADYCZCAAQYbVuecANgJoIABB2bKj7AA2AmwgAEHG4rcHNgJwIABBATYCBCAAQQhqIgNCADcCACADQgA3AgggA0IANwIQIANBADYCGAsgBUH4AmoiBiAAQQRqIg8QESACIAYpAAA3AAAgAiAGKQAINwAIIAIgBikAEDcAECACIAYpABg3ABggAUEARyIHBEAgAkEgaiIDIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABgLIAVBkAJqIQggBUHwAWohBCAFQfAAaiEDIAVByABqIQEgBUEEaiIQIAIgBwR/QcAABUEgCxAqIAJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUEEaiECIAFBCGohByABQQxqIQkgAUEQaiEKIAFBFGohCyABQRhqIQwgAUEcaiENIAFBIGohESABQSRqIRIDQCAQIAYQHyAFIAEgBhAURSIONgIAIA4EQCAFQQE2AgAMAQUgBSACKAIAIAEoAgByIAcoAgByIAkoAgByIAooAgByIAsoAgByIAwoAgByIA0oAgByIBEoAgByIBIoAgByRSIONgIAIA4NAQsLIAggARAHIABBJGoiAiACIAgQCiAAQcwAaiIHIAcgCBAKIAcgByABEAogAEH0AGoiCCAIIAEQCiABQgA3AgAgAUIANwIIIAFCADcCECABQgA3AhggAUIANwIgIARBBGohASAEQQhqIQggBEEMaiEHIARBEGohCSAEQRRqIQogBEEYaiELIARBHGohDANAIBAgBhAfIAQgBiAFEA4gBSgCAARAIAVBATYCAAwBBSAFIAEoAgAgBCgCAHIgCCgCAHIgBygCAHIgCSgCAHIgCigCAHIgCygCAHIgDCgCAHJFIg02AgAgDQ0BCwsgBkIANwAAIAZCADcACCAGQgA3ABAgBkIANwAYIAAgAyAEEB4gBCAEKAIAIgBBf3OtQsKC2YENfCITIAEoAgAiBiAAciAIKAIAIgByIAcoAgAiEHIgCSgCACINciAKKAIAIhFyIAsoAgAiEnIgDCgCACIOckEAR0EfdEEfda0iFIM+AgAgASATQiCIQoy9yf4LhCAGQX9zrXwiEyAUgz4CACAIIABBf3OtQrvAovoKfCATQiCIfCITIBSDPgIAIAcgEEF/c61C5rm71Qt8IBNCIIh8IhMgFIM+AgAgCSANQX9zrUL+////D3wgE0IgiHwiEyAUgz4CACAKIBFBf3OtQv////8PfCATQiCIfCITIBSDPgIAIAsgEkF/c61C/////w98IBNCIIh8IhMgFIM+AgAgDCAO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KSAGQQhqISogBkEMaiErIAZBEGohLCAGQRRqIS0gBkEYaiEuIAZBHGohLyAGQSBqITAgBkEkaiExIANBBGohMiADQQhqITMgA0EMaiE0IANBEGohNSADQRRqITYgA0EYaiE3IANBHGohOCADQSBqITkgA0EkaiE6IARBBGohOyAEQQhqIQkgBEEMaiEMIARBEGohDiAEQRRqIQ8gBEEYaiERIARBHGohEiAEQSBqIRMgBEEkaiEVIA0oAgBBvOH//wBqIRYgDSgCBEH8/f//AGohFyANKAIIQfz///8AaiEYIA0oAgxB/P///wBqIRkgDSgCEEH8////AGohGiANKAIUQfz///8AaiEbIA0oAhhB/P///wBqIRwgDSgCHEH8////AGohHSANKAIgQfz///8AaiEeIA0oAiRB/P//B2ohH0H/PyEBA0AgBiAHIAFBf2oiAkEGdGoiIBAjIBAgECAGEAogFCAQEAcgKCAUIBAQCiAGIAYgFBAKICkoAgAhISAqKAIAISIgKygCACEjICwoAgAhJCAtKAIAISUgLigCACEmIC8oAgAhJyAwKAIAIQsgMSgCACEFIAYgFiAGKAIAazYCACApIBcgIWs2AgAgKiAYICJrNgIAICsgGSAjazYCACAsIBogJGs2AgAgLSAbICVrNgIAIC4gHCAmazYCACAvIB0gJ2s2AgAgMCAeIAtrNgIAIDEgHyAFazYCACAKIAogKBAKIAMgBikCADcCACADIAYpAgg3AgggAyAGKQIQNwIQIAMgBikCGDcCGCADIAYpAiA3AiAgAxAPIAQgCikCADcCACAEIAopAgg3AgggBCAKKQIQNwIQIAQgCikCGDcCGCAEIAopAiA3AiAgBBAPICAgMigCACILQRp0IAMoAgByNgIAIAcgAkEGdGogMygCACIFQRR0IAtBBnZyNgIEIAcgAkEGdGogNCgCACILQQ50IAVBDHZyNgIIIAcgAkEGdGogNSgCACIFQQh0IAtBEnZyNgIMIAcgAkEGdGogNigCAEECdCAFQRh2ciA3KAIAIgVBHHRyNgIQIAcgAkEGdGogOCgCACILQRZ0IAVBBHZyNgIUIAcgAkEGdGogOSgCACIFQRB0IAtBCnZyNgIYIAcgAkEGdGogOigCAEEKdCAFQRB2cjYCHCAHIAJBBnRqIDsoAgAiC0EadCAEKAIAcjYCICAHIAJBBnRqIAkoAgAiBUEUdCALQQZ2cjYCJCAHIAJBBnRqIAwoAgAiC0EOdCAFQQx2cjYCKCAHIAJBBnRqIA4oAgAiBUEIdCALQRJ2cjYCLCAHIAJBBnRqIA8oAgBBAnQgBUEYdnIgESgCACIFQRx0cjYCMCAHIAJBBnRqIBIoAgAiC0EWdCAFQQR2cjYCNCAHIAJBBnRqIBMoAgAiBUEQdCALQQp2cjYCOCAHIAJBBnRqIBUoAgBBCnQgBUEQdnI2AjwgAUEBSgRAIAIhAQwBCwsLIAgkBCAAC5wSAhl/An4jBCEKIwRBoARqJAQgAEEEaiIeKAIARQRAQbqLBCAAKAKoASAAKAKkAUEDcUECahEAACAKJARBAA8LIAJFBEBBrIsEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAokBEEADwsgAUUEQEHMjAQgACgCqAEgACgCpAFBA3FBAmoRAAAgCiQEQQAPCyADRQRAQYiMBCAAKAKoASAAKAKkAUEDcUECahEAACAKJARBAA8LIAAgCkHYAGoiCSADEDBFBEAgCiQEQQAPCyAJKAIEIRMgCSgCCCEUIAkoAgwhDCAJKAIQIQ0gCSgCFCEOIAkoAhghDyAJKAIcIRIgCSgCICEYIAkoAiQhGSAJKAIoIRogCSgCLCEbIAkoAjAhESAJKAI0IRwgCSgCOCEdIAkoAjwhFSAKIgcgCSgCACIKQf///x9xNgIAIAcgE0EGdEHA//8fcSAKQRp2ciIWNgIEIAcgFEEMdEGA4P8fcSATQRR2ciIXNgIIIAcgDEESdEGAgPAfcSAUQQ52ciIJNgIMIAcgDUEYdEGAgIAYcSAMQQh2ciITNgIQIAcgDUECdkH///8fcSIUNgIUIAcgDkEEdEHw//8fcSANQRx2ciIMNgIYIAcgD0EKdEGA+P8fcSAOQRZ2ciIONgIcIAcgEkEQdEGAgPwfcSAPQRB2ciIPNgIgIAcgEkEKdiIKNgIkIAcgGEH///8fcTYCKCAHIBlBBnRBwP//H3EgGEEadnI2AiwgByAaQQx0QYDg/x9xIBlBFHZyNgIwIAcgG0ESdEGAgPAfcSAaQQ52cjYCNCAHIBFBGHRBgICAGHEgG0EIdnI2AjggByARQQJ2Qf///x9xNgI8IAdBQGsgHEEEdEHw//8fcSARQRx2cjYCACAHIB1BCnRBgPj/H3EgHEEWdnI2AkQgByAVQRB0QYCA/B9xIB1BEHZyNgJIIAcgFUEKdjYCTCAHQdAAaiIZQQA2AgAgFiAHKAIAciAXciAJciATciAUciAMciAOciAPciAKckUEQEHajAQgACgCqAEgACgCpAFBA3FBAmoRAAALIAdB8ANqIREgB0HIA2ohEiAHQagDaiEGIAdBrAJqIRAgB0HYAWohDSAHQbgBaiEIIAdBmAFqIgsgA0EAEA4CfwJAIAtBBGoiGCgCACALKAIAciALQQhqIhooAgAiDHIgC0EMaiIbKAIAIg5yIAtBEGoiHCgCACIPciALQRRqIh0oAgAiCnIgC0EYaiIVKAIAIgNyIAtBHGoiFigCACIAckUNACARQQA2AgAgBiAAQRh2OgAAIAYgAEEQdjoAASAGIABBCHY6AAIgBiAAOgADIAYgA0EYdjoABCAGIANBEHY6AAUgBiADQQh2OgAGIAYgAzoAByAGIApBGHY6AAggBiAKQRB2OgAJIAYgCkEIdjoACiAGIAo6AAsgBiAPQRh2OgAMIAYgD0EQdjoADSAGIA9BCHY6AA4gBiAPOgAPIAYgDkEYdjoAECAGIA5BEHY6ABEgBiAOQQh2OgASIAYgDjoAEyAGIAxBGHY6ABQgBiAMQRB2OgAVIAYgDEEIdjoAFiAGIAw6ABcgBiAYKAIAIgBBGHY6ABggBiAAQRB2OgAZIAYgAEEIdjoAGiAGIAA6ABsgBiALKAIAIgBBGHY6ABwgBiAAQRB2OgAdIAYgAEEIdjoAHiAGIAA6AB8CQCASIAIgBkG5jQQgBUEAIAQEfyAEBUEBCyIKQQFxEQEAIgAEQCAIQQRqIRcgCEEIaiEJIAhBDGohEyAIQRBqIRQgCEEUaiEMIAhBGGohDiAIQRxqIQ9BASEEA0AgCCASIBEQDiARKAIARQRAIBcoAgAgCCgCAHIgCSgCAHIgEygCAHIgFCgCAHIgDCgCAHIgDigCAHIgDygCAHINAwsgCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIARBAWohAyASIAIgBkG5jQQgBSAEIApBAXERAQAiAARAIAMhBAwBBUEAIQALCwVBACEACwsgAEUNACAeIBAgCBAeIA0gECgCeDYCUCAQQdAAaiIAIAAQFSARIAAQByASIAAgERAKIBAgECAREAogEEEoaiIDIAMgEhAKIABBATYCACAQQdQAaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgIA0gECkCADcCACANIBApAgg3AgggDSAQKQIQNwIQIA0gECkCGDcCGCANIBApAiA3AiAgDUEoaiIAIAMpAgA3AgAgACADKQIINwIIIAAgAykCEDcCECAAIAMpAhg3AhggACADKQIgNwIgIBgoAgAgCygCAHIgGigCAHIgGygCAHIgHCgCAHIgHSgCAHIgFSgCAHIgFigCAHIEQCAIQQRqIhUoAgAgCCgCAHIgCEEIaiIWKAIAciAIQQxqIhcoAgByIAhBEGoiCSgCAHIgCEEUaiITKAIAciAIQRhqIhQoAgByIAhBHGoiDCgCAHJBAEcgGSgCAEVxBEAgESAAECJFBEAgCCAIKAIAIgBBf3OtQsKC2YENfCIfIBUoAgAiDiAAciAWKAIAIg9yIBcoAgAiCnIgCSgCACIFciATKAIAIgRyIBQoAgAiA3IgDCgCACIAckEAR0EfdEEfda0iIIM+AgAgFSAfQiCIQoy9yf4LhCAOQX9zrXwiHyAggz4CACAWIA9Bf3OtQrvAovoKfCAfQiCIfCIfICCDPgIAIBcgCkF/c61C5rm71Qt8IB9CIIh8Ih8gIIM+AgAgCSAFQX9zrUL+////D3wgH0IgiHwiHyAggz4CACATIARBf3OtQv////8PfCAfQiCIfCIfICCDPgIAIBQgA0F/c61C/////w98IB9CIIh8Ih8gIIM+AgAgDCAAQX9zrUL/////D3wgH0IgiHwgIIM+AgALIA0QDyABIA0QHSASIAEgByACECggBiASIAsQDSAGIAYgCBAcIAFBIGogBhARQQEMAwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4QQALIQAgC0IANwIAIAtCADcCCCALQgA3AhAgC0IANwIYIAckBCAAC7MLAhR/An4jBCEEIwRBkARqJAQgACgCAEUEQEH4igQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyACRQRAQayLBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAA8LIAFFBEBBzIwEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgA0UEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyADKAAEIQggAygACCEJIAMoAAwhCiADKAAQIQUgAygAFCELIAMoABghDCADKAAcIQ0gAygAICEOIAMoACQhDyADKAAoIRAgAygALCERIAMoADAhByADKAA0IRIgAygAOCETIAMoADwhFCAEIAMoAAAiA0H///8fcTYCACAEIAhBBnRBwP//H3EgA0EadnIiFTYCBCAEIAlBDHRBgOD/H3EgCEEUdnIiFjYCCCAEIApBEnRBgIDwH3EgCUEOdnIiFzYCDCAEIAVBGHRBgICAGHEgCkEIdnIiCDYCECAEIAVBAnZB////H3EiCTYCFCAEIAtBBHRB8P//H3EgBUEcdnIiCjYCGCAEIAxBCnRBgPj/H3EgC0EWdnIiCzYCHCAEIA1BEHRBgID8H3EgDEEQdnIiDDYCICAEIA1BCnYiAzYCJCAEIA5B////H3E2AiggBCAPQQZ0QcD//x9xIA5BGnZyNgIsIAQgEEEMdEGA4P8fcSAPQRR2cjYCMCAEIBFBEnRBgIDwH3EgEEEOdnI2AjQgBCAHQRh0QYCAgBhxIBFBCHZyNgI4IAQgB0ECdkH///8fcTYCPCAEQUBrIBJBBHRB8P//H3EgB0EcdnI2AgAgBCATQQp0QYD4/x9xIBJBFnZyNgJEIAQgFEEQdEGAgPwfcSATQRB2cjYCSCAEIBRBCnY2AkwgBEHQAGoiD0EANgIAIBUgBCgCAHIgFnIgF3IgCHIgCXIgCnIgC3IgDHIgA3JFBEBB2owEIAAoAqgBIAAoAqQBQQNxQQJqEQAACyAEQeADaiEQIARBuANqIQ0gBEG8AmohBSAEQcABaiEHIARBmAFqIQ4gBEH4AGohBiAEQdQAaiIDQQA2AgAgBEHYAGoiESABQSBqIAMQDiADKAIABH9BAAUgDiABEBQEfyAGIAEgBCACECggBiAGKAIAIgFBf3OtQsKC2YENfCIYIAZBBGoiEigCACITIAFyIAZBCGoiFCgCACIVciAGQQxqIhYoAgAiF3IgBkEQaiIIKAIAIglyIAZBFGoiCigCACILciAGQRhqIgwoAgAiA3IgBkEcaiICKAIAIgFyQQBHQR90QR91rSIZgz4CACASIBhCIIhCjL3J/guEIBNBf3OtfCIYIBmDPgIAIBQgFUF/c61Cu8Ci+gp8IBhCIIh8IhggGYM+AgAgFiAXQX9zrULmubvVC3wgGEIgiHwiGCAZgz4CACAIIAlBf3OtQv7///8PfCAYQiCIfCIYIBmDPgIAIAogC0F/c61C/////w98IBhCIIh8IhggGYM+AgAgDCADQX9zrUL/////D3wgGEIgiHwiGCAZgz4CACACIAFBf3OtQv////8PfCAYQiCIfCAZgz4CACAFIA8oAgA2AnggBSAEKQIANwIAIAUgBCkCCDcCCCAFIAQpAhA3AhAgBSAEKQIYNwIYIAUgBCkCIDcCICAFQShqIgIgBEEoaiIBKQIANwIAIAIgASkCCDcCCCACIAEpAhA3AhAgAiABKQIYNwIYIAIgASkCIDcCICAFQQE2AlAgBUHUAGoiAUIANwIAIAFCADcCCCABQgA3AhAgAUIANwIYIAFBADYCICAAIAcgBSAGIBEQGSAHQfgAaiIAKAIABH9BAAUgDiAHECEEfyAAKAIABH9BAAUgDSAHQShqIAdB0ABqEAogECANECJBAEcLBUEACwsFQQALCyEAIAQkBCAAC+cPAhZ/An4jBCEFIwRBgAZqJAQgACgCAEUEQEH4igQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyADRQRAQayLBCAAKAKoASAAKAKkAUEDcUECahEAACAFJARBAA8LIAJFBEBB9osEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgAUUEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyAFQbAFaiEVIAVBiAVqIRggBUHYBWohBCAFQeAEaiEGIAVBjARqIQwgBUGQA2ohDSAFQfACaiEWIAVB0AJqIQsgBUGwAmohGSAFQbQBaiEIIAVB4ABqIQ4gBUFAayIHIAIpAAA3AAAgByACKQAINwAIIAcgAikAEDcAECAHIAIpABg3ABggBUEgaiIJIAJBIGoiCikAADcAACAJIAopAAg3AAggCSAKKQAQNwAQIAkgCikAGDcAGCACQUBrLQAAIRQgBSADQQAQDgJAIAcoAgQiAiAHKAIAciAHKAIIIgNyIAcoAgwiCnIgBygCECIPciAHKAIUIhByIAcoAhgiEXIgBygCHCIScgRAIAkoAgQgCSgCAHIgCSgCCHIgCSgCDHIgCSgCEHIgCSgCFHIgCSgCGHIgCSgCHHJFDQEgBCASQRh2OgAAIAQgEkEQdjoAASAEIBJBCHY6AAIgBCASOgADIAQgEUEYdjoABCAEIBFBEHY6AAUgBCARQQh2OgAGIAQgEToAByAEIBBBGHY6AAggBCAQQRB2OgAJIAQgEEEIdjoACiAEIBA6AAsgBCAPQRh2OgAMIAQgD0EQdjoADSAEIA9BCHY6AA4gBCAPOgAPIAQgCkEYdjoAECAEIApBEHY6ABEgBCAKQQh2OgASIAQgCjoAEyAEIANBGHY6ABQgBCADQRB2OgAVIAQgA0EIdjoAFiAEIAM6ABcgBCACQRh2OgAYIAQgAkEQdjoAGSAEIAJBCHY6ABogBCACOgAbIAQgBygCACICQRh2OgAcIAQgAkEQdjoAHSAEIAJBCHY6AB4gBCACOgAfIAYgBBAUGiAUQQJxBEAgBkEkaiIEKAIADQIgBkEgaiIKKAIADQIgBkEcaiIPKAIADQIgBkEYaiIQKAIADQIgBkEUaiIRKAIADQIgBkEQaiISKAIAIgNBo6KVCksNAiAGQQxqIhcoAgAhAgJAIANBo6KVCkYEQCACQd2FlQNLDQQgAkHdhZUDRgRAIAYoAggiAkGCiPEPSw0FIAJBgojxD0cEQEHdhZUDIQIMAwsgBigCBCICQYu5oRtLDQUgAkGLuaEbRwRAQd2FlQMhAgwDCyAGKAIAQe31ph5NBEBB3YWVAyECDAMLDAULCwsgBiAGKAIAQcGC2QFqNgIAIAZBBGoiEyATKAIAQbTG3gRqNgIAIAZBCGoiEyATKAIAQf33jhBqNgIAIBcgAkGi+uocajYCACASIANB3N3qFWo2AgAgEUH///8fNgIAIBBB////HzYCACAPQf///x82AgAgCkH///8fNgIAIARB////ATYCAAsgDCAGIBRBAXEQLkUNASANIAwoAlA2AnggDSAMKQIANwIAIA0gDCkCCDcCCCANIAwpAhA3AhAgDSAMKQIYNwIYIA0gDCkCIDcCICANQShqIgIgDEEoaiIDKQIANwIAIAIgAykCCDcCCCACIAMpAhA3AhAgAiADKQIYNwIYIAIgAykCIDcCICANQQE2AlAgDUHUAGoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJBADYCICAWIAcQICALIBYgBRANIAsgCygCACICQX9zrULCgtmBDXwiGiALQQRqIgMoAgAiBCACciALQQhqIgIoAgAiBnIgC0EMaiIHKAIAIgxyIAtBEGoiCigCACIPciALQRRqIhAoAgAiEXIgC0EYaiISKAIAIhRyIAtBHGoiFygCACITckEAR0EfdEEfda0iG4M+AgAgAyAaQiCIQoy9yf4LhCAEQX9zrXwiGiAbgz4CACACIAZBf3OtQrvAovoKfCAaQiCIfCIaIBuDPgIAIAcgDEF/c61C5rm71Qt8IBpCIIh8IhogG4M+AgAgCiAPQX9zrUL+////D3wgGkIgiHwiGiAbgz4CACAQIBFBf3OtQv////8PfCAaQiCIfCIaIBuDPgIAIBIgFEF/c61C/////w98IBpCIIh8IhogG4M+AgAgFyATQX9zrUL/////D3wgGkIgiHwgG4M+AgAgGSAWIAkQDSAAIAggDSAZIAsQGSAOIAhB+ABqIgMoAgAiADYCUCAARQRAIAhB0ABqIgIgAhAVIBUgAhAHIBggAiAVEAogCCAIIBUQCiAIQShqIgAgACAYEAogAkEBNgIAIAhB1ABqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiAgDiAIKQIANwIAIA4gCCkCCDcCCCAOIAgpAhA3AhAgDiAIKQIYNwIYIA4gCCkCIDcCICAOQShqIgIgACkCADcCACACIAApAgg3AgggAiAAKQIQNwIQIAIgACkCGDcCGCACIAApAiA3AiAgAygCACEACyAARQRAIAEgDhAbIAUkBEEBDwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAUkBEEAC6AGARF/IwQhBiMEQdABaiQEIAZBADYCACAAQQRqIg8oAgBFBEBBuosEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAYkBEEADwsgAkUEQEGsiwQgACgCqAEgACgCpAFBA3FBAmoRAAAgBiQEQQAPCyABRQRAQfaLBCAAKAKoASAAKAKkAUEDcUECahEAACAGJARBAA8LIANFBEBBiIwEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAYkBEEADwsgBkGIAWohCiAGQegAaiELIAZByABqIQcgBkEoaiEIIAZBCGohCSAGQQRqIQ0gBkGoAWohDCAEBH8gBAVBAQshDiAHIAMgBhAOIAYoAgBFBEAgBygCBCAHKAIAciAHKAIIciAHKAIMciAHKAIQciAHKAIUciAHKAIYciAHKAIccgRAIAkgAkEAEA4CQCAMIAIgA0EAIAVBACAOQQFxEQEAIgAEQCAIQQRqIRAgCEEIaiERIAhBDGohEiAIQRBqIRMgCEEUaiEUIAhBGGohFSAIQRxqIRZBACEEA0AgCCAMIAYQDiAGKAIARQRAIBAoAgAgCCgCAHIgESgCAHIgEigCAHIgEygCAHIgFCgCAHIgFSgCAHIgFigCAHIEQCAPIAogCyAHIAkgCCANEDENBAsLIAwgAiADQQAgBSAEQQFqIgQgDkEBcREBACIADQBBACEACwVBACEACwsgCUIANwIAIAlCADcCCCAJQgA3AhAgCUIANwIYIAhCADcCACAIQgA3AgggCEIANwIQIAhCADcCGCAHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggAARAIA0oAgAhAyABIAopAAA3AAAgASAKKQAINwAIIAEgCikAEDcAECABIAopABg3ABggAUEgaiICIAspAAA3AAAgAiALKQAINwAIIAIgCykAEDcAECACIAspABg3ABggAUFAayADOgAAIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAGJARBAAv+AQECfyMEIQQjBEFAayQEIAFFBEBByooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgA0UEQEGuigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEQSBqIQUgAgR/IAUgAykAADcAACAFIAMpAAg3AAggBSADKQAQNwAQIAUgAykAGDcAGCAEIANBIGoiACkAADcAACAEIAApAAg3AAggBCAAKQAQNwAQIAQgACkAGDcAGCACIANBQGstAAA2AgAgASAFEBEgAUEgaiAEEBEgBCQEQQEFQb6MBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAAsL7wIBA38jBCEEIwRB0ABqJAQgBEEANgIAIAFFBEBBrooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAkUEQEG6igQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyADQQNLBEBBpYwEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgBEEoaiIFIAIgBBAOIAQoAgAhACAEQQhqIgYgAkEgaiAEEA4gBCgCACAAckUiACECIAAEfyABIAUpAAA3AAAgASAFKQAINwAIIAEgBSkAEDcAECABIAUpABg3ABggAUEgaiIAIAYpAAA3AAAgACAGKQAINwAIIAAgBikAEDcAECAAIAYpABg3ABggAUFAayADOgAAIAQkBCACBSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAEJAQgAgsLlCoBX38jBCEHIwRBwANqJAQgB0GgAWohCCAHQfgAaiEKIAFB+ABqIUAgB0GQA2oiBiABQdAAaiI9EAcgB0HoAmoiAyABKQIANwIAIAMgASkCCDcCCCADIAEpAhA3AhAgAyABKQIYNwIYIAMgASkCIDcCICADQSRqIiUoAgAiFEEWdiIEQdEHbCADKAIAaiEFIARBBnQgA0EEaiImKAIAaiAFQRp2aiIVQRp2IANBCGoiJygCAGoiFkEadiADQQxqIhwoAgBqIhdBGnYgA0EQaiIdKAIAaiIYQRp2IANBFGoiMSgCAGoiDkEadiADQRhqIjIoAgBqIiBBGnYgA0EcaiIzKAIAaiIhQRp2IANBIGoiNCgCAGohBCADIAVB////H3E2AgAgJiAVQf///x9xNgIAICcgFkH///8fcTYCACAcIBdB////H3E2AgAgHSAYQf///x9xNgIAIDEgDkH///8fcTYCACAyICBB////H3E2AgAgMyAhQf///x9xNgIAIDQgBEH///8fcTYCACAlIARBGnYgFEH///8BcWo2AgAgB0HAAmoiBCACIAYQCiABKAJMIhlBFnYiBUHRB2wgASgCKGohGiAFQQZ0IAEoAixqIBpBGnZqIihBGnYgASgCMGoiKUEadiABKAI0aiIqQRp2IAEoAjhqIitBGnYgASgCPGoiLEEadiABQUBrKAIAaiItQRp2IAEoAkRqIiJBGnYgASgCSGohHiAHQZgCaiIFIAJBKGoiWCAGEAogBSAFID0QCiAHQfABaiIBIAMpAgA3AgAgASADKQIINwIIIAEgAykCEDcCECABIAMpAhg3AhggASAD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aiI6KAIAayETIDogEzYCAEH8////ACAKQSBqIjsoAgBrIR8gOyAfNgIAQfz//wcgCkEkaiI/KAIAayEbID8gGzYCACAuKAIAIBtqIkJBFnYiPEHRB2wgASgCACAkamohGyA8QQZ0IBQoAgAgCWpqIBtBGnZqIiRBGnYgFSgCACALamoiC0EadiAWKAIAIA9qaiIPQRp2IBcoAgAgDGpqIgxBGnYgGCgCACANamoiDUEadiAOKAIAIBJqaiISQRp2ICAoAgAgE2pqIhNBGnYgISgCACAfamohCSABIBtB////H3EiHzYCACAUICRB////H3EiGzYCACAVIAtB////H3EiCzYCACAWIA9B////H3EiDzYCACAXIAxB////H3EiDDYCACAYIA1B////H3EiDTYCACAOIBJB////H3EiEjYCACAgIBNB////H3EiEzYCACAhIAlB////H3EiJDYCACAuIAlBGnYgQkH///8BcWoiCTYCACAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAEgH0EBdCAKKAIAajYCACAUIBtBAXQgAygCAGo2AgAgFSALQQF0IBAoAgBqNgIAIBYgD0EBdCARKAIAajYCACAXIAxBAXQgIygCAGo2AgAgGCANQQF0IDAoAgBqNgIAIA4gEkEBdCA5KAIAajYCACAgIBNBAXQgOigCAGo2AgAgISAkQQF0IDsoAgBqNgIAIC4gCUEBdCA/KAIAajYCACABIAEgBxAKIAEgASgCACAIKAIAaiIBNgIAIBQgFCgCACAeKAIAaiIDNgIAIBUgFSgCACAZKAIAaiIINgIAIBYgFigCACAlKAIAaiIKNgIAIBcgFygCACAmKAIAaiIUNgIAIBggGCgCACAnKAIAaiIVNgIAIA4gDigCACAcKAIAaiIWNgIAICAgICgCACAdKAIAaiIXNgIAICEgISgCACAiKAIAaiIYNgIAIC4gLigCACAvKAIAaiIONgIAQfj//w8gDmsiD0EWdiIOQdEHbEH4wv//ASABa2ohASAOQQZ0Qfj7//8BIANraiABQRp2aiIcQRp2Qfj///8BIAhraiIdQRp2Qfj///8BIApraiIJQRp2Qfj///8BIBRraiIQQRp2Qfj///8BIBVraiILQRp2Qfj///8BIBZraiIR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FHZyNgIwIAIgEUESdEGAgPAfcSAQQQ52cjYCNCACIAVBGHRBgICAGHEgEUEIdnI2AjggAiAFQQJ2Qf///x9xNgI8IAJBQGsgEkEEdEHw//8fcSAFQRx2cjYCACACIBNBCnRBgPj/H3EgEkEWdnI2AkQgAiAUQRB0QYCA/B9xIBNBEHZyNgJIIAIgFEEKdjYCTCACQdAAaiINQQA2AgAgDiACKAIAciAGciAHciAIciAVciADciAKciALciAMckUEQEHajAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIARBwAJqIQogBEGYAmohCyAEQfgBaiEIIARB/ABqIQMgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAJKAIEIAkoAgByIAkoAghyIAkoAgxyIAkoAhByIAkoAhRyIAkoAhhyIAkoAhxyBH8gCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIANB+ABqIgxBADYCACADIAIpAgA3AgAgAyACKQIINwIIIAMgAikCEDcCECADIAIpAhg3AhggAyACKQIgNwIgIANBKGoiBSACQShqIgYpAgA3AgAgBSAGKQIINwIIIAUgBikCEDcCECAFIAYpAhg3AhggBSAGKQIgNwIgIANBATYCUCADQdQAaiIHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggB0EANgIgIAAgAyADIAkgCBAZIA0gDCgCADYCACADQdAAaiIAIAAQFSAKIAAQByALIAAgChAKIAMgAyAKEAogBSAFIAsQCiAAQQE2AgAgB0IANwIAIAdCADcCCCAHQgA3AhAgB0IANwIYIAdBADYCICACIAMpAgA3AgAgAiADKQIINwIIIAIgAykCEDcCECACIAMpAhg3AhggAiADKQIgNwIgIAYgBSkCADcCACAGIAUpAgg3AgggBiAFKQIQNwIQIAYgBSkCGDcCGCAGIAUpAiA3AiAgASACEBsgBCQEQQEFIAQkBEEACwvhAgEBfyMEIQMjBEHQAGokBCADQQA2AgAgAUUEQEGIjAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAyQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACADJARBAA8LIANBKGoiACACIAMQDiADQQhqIgIgAUEAEA4gAygCAAR/IAFCADcAACABQgA3AAggAUIANwAQIAFCADcAGEEABSAAKAIEIAAoAgByIAAoAghyIAAoAgxyIAAoAhByIAAoAhRyIAAoAhhyIAAoAhxyBH8gAiACIAAQDSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggASACEBFBAQUgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYQQALCyEBIAJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCAAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAyQEIAELgAsBE38jBCEEIwRB8AJqJAQgBEEANgIAIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAUUEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAA8LIARBCGoiFCACIAQQDiAEKAIABEAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIAEoAAQhBiABKAAIIQcgASgADCEIIAEoABAhAyABKAAUIQkgASgAGCEKIAEoABwhCyABKAAgIQwgASgAJCENIAEoACghDyABKAAsIRAgASgAMCEFIAEoADQhESABKAA4IRIgASgAPCETIARBKGoiAiABKAAAIg5B////H3E2AgAgAiAGQQZ0QcD//x9xIA5BGnZyIg42AgQgAiAHQQx0QYDg/x9xIAZBFHZyIgY2AgggAiAIQRJ0QYCA8B9xIAdBDnZyIgc2AgwgAiADQRh0QYCAgBhxIAhBCHZyIgg2AhAgAiADQQJ2Qf///x9xIhU2AhQgAiAJQQR0QfD//x9xIANBHHZyIgM2AhggAiAKQQp0QYD4/x9xIAlBFnZyIgk2AhwgAiALQRB0QYCA/B9xIApBEHZyIgo2AiAgAiALQQp2Igs2AiQgAiAMQf///x9xNgIoIAIgDUEGdEHA//8fcSAMQRp2cjYCLCACIA9BDHRBgOD/H3Eg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AWoiBCANQQFxEQEAIgANAEEAIQALBUEAIQALCyAJQgA3AgAgCUIANwIIIAlCADcCECAJQgA3AhggCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIAdCADcCACAHQgA3AgggB0IANwIQIAdCADcCGCAABEAgASAKKQAANwAAIAEgCikACDcACCABIAopABA3ABAgASAKKQAYNwAYIAFBIGoiASALKQAANwAAIAEgCykACDcACCABIAspABA3ABAgASALKQAYNwAYIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAYkBEEAC9cCAQJ/IwQhByMEQcABaiQEIAdByABqIgYgAikAADcAACAGIAIpAAg3AAggBiACKQAQNwAQIAYgAikAGDcAGCAGQSBqIgIgASkAADcAACACIAEpAAg3AAggAiABKQAQNwAQIAIgASkAGDcAGCAEBH8gBkFAayIBIAQpAAA3AAAgASAEKQAINwAIIAEgBCkAEDcAECABIAQpABg3ABhB4AAFQcAACyEBIAMEQCAGIAFqIgIgAykAADcAACACIAMpAAg3AAggAUEQciEBCyAHIAYgARAqIAZCADcAACAGQgA3AAggBkIANwAQIAZCADcAGCAGQgA3ACAgBkIANwAoIAZCADcAMCAGQgA3ADggBkFAa0IANwAAIAZCADcASCAGQgA3AFAgBkIANwBYIAZCADcAYCAGQgA3AGhBACEBA0AgByAAEB8gAUEBaiIBIAVNDQALIAckBEEBC90QASl/IwQhBSMEQYAEaiQEIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgAkUEQEGsiwQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyABRQRAQa6KBCAAKAKoASAAKAKkAUEDcUECahEAACAFJARBAA8LIANFBEBB5IgEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgBSACQQAQDiAFQUBrIgYgASkAADcAACAGIAEpAAg3AAggBiABKQAQNwAQIAYgASkAGDcAGCAFQSBqIgQgAUEgaiIBKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIARBGGoi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////HzYCACAGQf///x82AgAgAkH///8BNgIAIAMgBxAhQQBHCwsLCwsLCwsFQQALBUEACwshACAFJAQgAAuYBQIJfwd+IwQhBCMEQSBqJAQgAkUEQEHbigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEIgAgAikAADcAACAAIAIpAAg3AAggACACKQAQNwAQIAAgAikAGDcAGCACKAA4IghBf0cgAigAPCIEQR92IgVBf3MiA3EgBEH/////B0lyIAMgAigANCIJQX9HcXIgAyACKAAwIgpBf0dxciADIAIoACwiA0Hz3N3qBUlxciIGQQFzIANB89zd6gVLcSAFciIHQQFzIAIoACgiBUGdoJG9BUlxIAZyIgtBAXMgBUGdoJG9BUtxIAdyIgdBAXMgAigAJCIGQcbepP99SXEgC3JBf3MiCyAGQcbepP99S3EgB3IgCyACKAAgIgJBoMHswAZLcXIhByABRQRAIAAkBCAHDwsgBwRAIAhBf3OtQv////8PfCAJQX9zrUL/////D3wgCkF/c61C/v///w98IANBf3OtQua5u9ULfCAFQX9zrUK7wKL6CnwgBkF/c61CjL3J/gt8IAJBf3OtQsKC2YENfCIMQiCIfCIOQiCIfCIPQiCIfCIQQiCIfCIRQiCIfCISQiCIfCENIAwgBiACciAFciADciAKciAJciAIciAEckEAR0EfdEEfda0iDIOnIQIgDyAMg6chBSAQIAyDpyEDIBEgDIOnIQogEiAMg6chCSANIAyDpyEIIARBf3OtQv////8PfCANQiCIfCAMg6chBCAOIAyDpyEGCyABIAApAAA3AAAgASAAKQAINwAIIAEgACkAEDcAECABIAApABg3ABggASACNgAgIAEgBjYAJCABIAU2ACggASADNgAsIAEgCjYAMCABIAk2ADQgASAINgA4IAEgBDYAPCAAJAQgBwuDAwIGfwh+IAJFBEBB24oEIAAoAqgBIAAoAqQBQQNxQQJqEQAAQQAPCyABBH8gAigAICIAQX9zrULCgtmBDXwhCiACKAAkIgMgAHIgAigAKCIAciACKAAsIgRyIAIoADAiBXIgAigANCIGciACKAA4IgdyIAIoADwiCHJBAEdBH3RBH3WtIQkgB0F/c61C/////w98IAZBf3OtQv////8PfCAFQX9zrUL+////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';

/* eslint-disable no-underscore-dangle, @typescript-eslint/max-params, @typescript-eslint/naming-convention */
// cSpell:ignore memcpy, anyfunc
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
const wrapSecp256k1Wasm$1 = (instance, heapU8, heapU32) => ({
    contextCreate: (context) => instance.exports._secp256k1_context_create(context),
    contextRandomize: (contextPtr, seedPtr) => instance.exports._secp256k1_context_randomize(contextPtr, seedPtr),
    free: (pointer) => instance.exports._free(pointer),
    heapU32,
    heapU8,
    instance,
    malloc: (bytes) => instance.exports._malloc(bytes),
    mallocSizeT: (num) => {
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        const pointer = instance.exports._malloc(4);
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
        const pointerView32 = pointer >> 2;
        // eslint-disable-next-line functional/no-expression-statements
        heapU32.set([num], pointerView32);
        return pointer;
    },
    mallocUint8Array: (array) => {
        const pointer = instance.exports._malloc(array.length);
        // eslint-disable-next-line functional/no-expression-statements
        heapU8.set(array, pointer);
        return pointer;
    },
    privkeyTweakAdd: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_add(contextPtr, secretKeyPtr, tweakNum256Ptr),
    privkeyTweakMul: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_privkey_tweak_mul(contextPtr, secretKeyPtr, tweakNum256Ptr),
    pubkeyCreate: (contextPtr, publicKeyPtr, secretKeyPtr) => instance.exports._secp256k1_ec_pubkey_create(contextPtr, publicKeyPtr, secretKeyPtr),
    pubkeyParse: (contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength) => instance.exports._secp256k1_ec_pubkey_parse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength),
    pubkeySerialize: (contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression) => instance.exports._secp256k1_ec_pubkey_serialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression),
    pubkeyTweakAdd: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_add(contextPtr, publicKeyPtr, tweakNum256Ptr),
    pubkeyTweakMul: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance.exports._secp256k1_ec_pubkey_tweak_mul(contextPtr, publicKeyPtr, tweakNum256Ptr),
    readHeapU8: (pointer, bytes) => new Uint8Array(heapU8.buffer, pointer, bytes),
    readSizeT: (pointer) => {
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
        const pointerView32 = pointer >> 2;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return heapU32[pointerView32];
    },
    recover: (contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr) => instance.exports._secp256k1_ecdsa_recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr),
    recoverableSignatureParse: (contextPtr, outputRSigPtr, inputSigPtr, rid) => instance.exports._secp256k1_ecdsa_recoverable_signature_parse_compact(contextPtr, outputRSigPtr, inputSigPtr, rid),
    recoverableSignatureSerialize: (contextPtr, sigOutPtr, recIDOutPtr, rSigPtr) => instance.exports._secp256k1_ecdsa_recoverable_signature_serialize_compact(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr),
    schnorrSign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_schnorr_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
    schnorrVerify: (contextPtr, sigPtr, msg32Ptr, publicKeyPtr) => instance.exports._secp256k1_schnorr_verify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr),
    seckeyVerify: (contextPtr, secretKeyPtr) => instance.exports._secp256k1_ec_seckey_verify(contextPtr, secretKeyPtr),
    sign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
    signRecoverable: (contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr) => instance.exports._secp256k1_ecdsa_sign_recoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr),
    signatureMalleate: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_malleate(contextPtr, outputSigPtr, inputSigPtr),
    signatureNormalize: (contextPtr, outputSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_normalize(contextPtr, outputSigPtr, inputSigPtr),
    signatureParseCompact: (contextPtr, sigOutPtr, compactSigInPtr) => instance.exports._secp256k1_ecdsa_signature_parse_compact(contextPtr, sigOutPtr, compactSigInPtr),
    signatureParseDER: (contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength) => instance.exports._secp256k1_ecdsa_signature_parse_der(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength),
    signatureSerializeCompact: (contextPtr, outputCompactSigPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_compact(contextPtr, outputCompactSigPtr, inputSigPtr),
    signatureSerializeDER: (contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr) => instance.exports._secp256k1_ecdsa_signature_serialize_der(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr),
    verify: (contextPtr, sigPtr, msg32Ptr, pubkeyPtr) => instance.exports._secp256k1_ecdsa_verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr),
});
/* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
/* eslint-disable functional/immutable-data, functional/no-expression-statements, @typescript-eslint/no-magic-numbers, functional/no-conditional-statements, no-bitwise, functional/no-throw-statements */
/**
 * Method extracted from Emscripten's preamble.js
 */
const isLittleEndian = (buffer) => {
    const littleEndian = true;
    const notLittleEndian = false;
    const heap16 = new Int16Array(buffer);
    const heap32 = new Int32Array(buffer);
    const heapU8 = new Uint8Array(buffer);
    heap32[0] = 1668509029;
    heap16[1] = 25459;
    return heapU8[2] !== 115 || heapU8[3] !== 99
        ? /* c8 ignore next */
            notLittleEndian
        : littleEndian;
};
/**
 * Method derived from Emscripten's preamble.js
 */
const alignMemory = (factor, size) => Math.ceil(size / factor) * factor;
/**
 * The most performant way to instantiate secp256k1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSecp256k1}.
 *
 * Note, most of this method is translated and boiled-down from Emscripten's
 * preamble.js. Significant changes to the WASM build or breaking updates to
 * Emscripten will likely require modifications to this method.
 *
 * @param webassemblyBytes - A buffer containing the secp256k1 binary.
 */
const instantiateSecp256k1WasmBytes = async (webassemblyBytes) => {
    const STACK_ALIGN = 16;
    const GLOBAL_BASE = 1024;
    const WASM_PAGE_SIZE = 65536;
    const TOTAL_STACK = 5242880;
    const TOTAL_MEMORY = 16777216;
    const wasmMemory = new WebAssembly.Memory({
        initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
        maximum: TOTAL_MEMORY / WASM_PAGE_SIZE,
    });
    /* c8 ignore next 9 */
    if (!isLittleEndian(wasmMemory.buffer)) {
        /*
         * note: this block is excluded from test coverage. It's A) hard to test
         * (must be either tested on big-endian hardware or a big-endian buffer
         * mock) and B) extracted from Emscripten's preamble.js, where it should
         * be tested properly.
         */
        throw new Error('Runtime error: expected the system to be little-endian.');
    }
    const STATIC_BASE = GLOBAL_BASE;
    const STATICTOP_INITIAL = STATIC_BASE + 67696 + 16;
    const DYNAMICTOP_PTR = STATICTOP_INITIAL;
    const DYNAMICTOP_PTR_SIZE = 4;
    const STATICTOP = (STATICTOP_INITIAL + DYNAMICTOP_PTR_SIZE + 15) & -16;
    const STACKTOP = alignMemory(STACK_ALIGN, STATICTOP);
    const STACK_BASE = STACKTOP;
    const STACK_MAX = STACK_BASE + TOTAL_STACK;
    const DYNAMIC_BASE = alignMemory(STACK_ALIGN, STACK_MAX);
    const heapU8 = new Uint8Array(wasmMemory.buffer);
    const heap32 = new Int32Array(wasmMemory.buffer);
    const heapU32 = new Uint32Array(wasmMemory.buffer);
    heap32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
    const TABLE_SIZE = 6;
    const MAX_TABLE_SIZE = 6;
    // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
    let getErrNoLocation;
    /*
     * note: A number of methods below are excluded from test coverage. They are
     * a) not part of the regular usage of this library (should only be evaluated
     * if the consumer mis-implements the library and exist only to make
     * debugging easier) and B) already tested adequately in Emscripten, from
     * which this section is extracted.
     */
    const env = {
        DYNAMICTOP_PTR,
        STACKTOP,
        /* c8 ignore start */
        ___setErrNo: (value) => {
            if (getErrNoLocation !== undefined) {
                heap32[getErrNoLocation() >> 2] = value;
            }
            return value;
        },
        _abort: (err = 'Secp256k1 Error') => {
            throw new Error(err);
        },
        // eslint-disable-next-line camelcase
        _emscripten_memcpy_big: (dest, src, num) => {
            heapU8.set(heapU8.subarray(src, src + num), dest);
            return dest;
        },
        abort: (err = 'Secp256k1 Error') => {
            throw new Error(err);
        },
        abortOnCannotGrowMemory: () => {
            throw new Error('Secp256k1 Error: abortOnCannotGrowMemory was called.');
        },
        enlargeMemory: () => {
            throw new Error('Secp256k1 Error: enlargeMemory was called.');
        },
        getTotalMemory: () => TOTAL_MEMORY,
        /* c8 ignore stop */
    };
    const info = {
        env: {
            ...env,
            memory: wasmMemory,
            memoryBase: STATIC_BASE,
            table: new WebAssembly.Table({
                element: 'anyfunc',
                initial: TABLE_SIZE,
                maximum: MAX_TABLE_SIZE,
            }),
            tableBase: 0,
        },
        global: { Infinity, NaN },
    };
    return WebAssembly.instantiate(webassemblyBytes, info).then((result) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
        getErrNoLocation = result.instance.exports['___errno_location'];
        return wrapSecp256k1Wasm$1(result.instance, heapU8, heapU32);
    });
};
/* eslint-enable functional/immutable-data, functional/no-expression-statements, @typescript-eslint/no-magic-numbers, functional/no-conditional-statements, no-bitwise, functional/no-throw-statements */
const getEmbeddedSecp256k1Binary = () => base64ToBin(secp256k1Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of
 * {@link instantiateSecp256k1Bytes} that does not require the consumer to
 * provide the secp256k1 binary buffer.
 */
const instantiateSecp256k1Wasm = async () => instantiateSecp256k1WasmBytes(getEmbeddedSecp256k1Binary());

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
const sha1Base64Bytes = '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cjYCBEG8FCAANgIAQbQUIAI2AgAgACACaiACNgIADAQLIAMQJQwBC0GkEUGkESgCAEF+IAFBA3Z3cTYCAAsgBCACaiECIAMgBGohAwsgAyADKAIEQX5xNgIEIAAgAkEBcjYCBCAAIAJqIAI2AgACfwJAIAJB/wFNBEAgAkEDdiIBQQN0QawRaiECQaQRKAIAIgNBASABQR9xdCIBcUUNASACQQhqIQMgAigCCAwCCyAAIAIQJgwCC0GkESADIAFyNgIAIAJBCGohAyACCyEBIAMgADYCACABIAA2AgwgACACNgIMIAAgATYCCAsgBUEIag8LQbgUIAAgAmsiATYCAEHAFEHAFCgCACIAIAJqIgM2AgAgAyABQQFyNgIEIAAgAkEDcjYCBCAAQQhqC6UBAQJ/QQIhBQJAAkACQAJAAkAgACgCBCIGIAFrIAJPDQAgASACaiICIAFJIQECQCAEBEBBACEFIAENAiAGQQF0IgEgAiACIAFJGyECDAELQQAhBSABDQELIAJBAEgNACAGRQ0BIAAoAgAgAhATIgFFDQIMAwsgBQ8LIAIQBCIBDQELIAMNAQsgAQRAIAAgATYCACAAQQRqIAI2AgBBAg8LQQEPCwALCABB5BUQBwALZgIBfwN+IwBBMGsiASQAIAApAhAhAiAAKQIIIQMgACkCACEEIAFBFGpBADYCACABIAQ3AxggAUIBNwIEIAFBrA42AhAgASABQRhqNgIAIAEgAzcDICABIAI3AyggASABQSBqECIAC7gBAQF/IwBB4AFrIgMkACADQThqQcwIKAIANgIAIANBMGpBxAgpAgA3AwAgA0IANwMgIANBvAgpAgA3AyggA0E8akEAQcQAEC4aIANBIGogASACEAkgA0GAAWogA0EgakHgABAsGiADQQhqIANBgAFqEAogA0EgaiADQQhqQRQQAyADQYgBaiADQShqKAIANgIAIAMgAykDIDcDgAEgAyADQYABahALIAAgAykDADcCACADQeABaiQAC5cDAQR/IwBBQGoiAyQAIAAgACkDACACrXw3AwAgAyAAQQhqNgIoIAMgA0EoajYCLAJAAkACQAJAAkACQCAAKAIcIgUEQEHAACAFayIEIAJNDQEgA0EYaiAFIAUgAmoiBCAAQSBqEBUgAygCHCACRw0FIAMoAhggASACECwaDAMLIAIhBAwB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QcgAaiICKQMANwMAIAEgASkDQDcDcCABIAw2AoQBIAEgFCAZQR53ajYCgAEgASAPNgKIASABIAY2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQAQHiABKAJsIRYgASkCZCEfIAEoAiAhDSABKAIsIRAgASgCKCEKIAEoAiQhESABIAEoAmAiDjYCcCABIB83AnQgASAWNgJ8IAEgETYChAEgASAKNgKIASABIBA2AowBIAEgDSABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBABAeIAIgAUHoAGoiFikDADcDACABIAEpA2A3A0AgASgCPCEHIAEoAjghCCABKAIwIRIgASgCNCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIBIgDkEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEAEB4gASgCbCEOIAEpAmQhHyABKAJgIRcgASARIAQgC3NzNgKEASABIA0gBSADc3M2AoABIAEgCiAUIAVzczYCiAEgASAQIAwgBHNzNgKMASABQdAAaiABQYABaiAJIAggBxAfIAEgFzYCcCABIB83AnQgASAONgJ8IAEgASgCVCIDNgKEASABIAEoAlgiCzYCiAEgASABKAJcIg42AowBIAEgASgCQEEedyABKAJQIhVqNgKAASABQeAAaiABQfAAaiABQYABakEAEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgBiAMc3M2AoQBIAEgEiAPIBRzczYCgAEgASAIIA0gD3NzNgKIASABIAcgESAGc3M2AowBIAFB8ABqIAFBgAFqIAMgCyAOEB8gASgCfCEEIAEoAnghBSABKAJwIQ8gASgCdCEGIBMgAikDADcDACABIAEpA0A3A3AgASAGNgKEASABIA8gF0Eed2o2AoABIAEgBTYCiAEgASAENgKMASABQeAAaiABQfAAaiABQYABakEBEB4gASgCbCEMIAEpAmQhHyABKAJgIRcgASADIBAgEXNzNgKEASABIBUgCiANc3M2AoABIAEgCyASIApzczYCiAEgASAOIAkgEHNzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnAhFCABKAJ8IQ0gASgCeCEQIAEoAnQhCiABIBc2AnAgASAfNwJ0IAEgDDYCfCABIAo2AoQBIAEgEDYCiAEgASANNgKMASABIBQgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgBiAHIAlzczYChAEgASAPIAggEnNzNgKAASABIAUgFSAIc3M2AogBIAEgBCADIAdzczYCjAEgAUHwAGogAUGAAWogCiAQIA0QHyABKAJ8IQcgASgCeCEIIAEoAnAhDCABKAJ0IQkgEyACKQMANwMAIAEgASkDQDcDcCABIAk2AoQBIAEgDCAXQR53ajYCgAEgASAINgKIASABIAc2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRcgASkCZCEfIAEoAmAhGCABIAogDiADc3M2AoQBIAEgFCALIBVzczYCgAEgASAQIA8gC3NzNgKIASABIA0gBiAOc3M2AowBIAFB8ABqIAFBgAFqIAkgCCAHEB8gASgCcCELIAEoAnwhESABKAJ4IRIgASgCdCEDIAEgGDYCcCABIB83AnQgASAXNgJ8IAEgAzYChAEgASASNgKIASABIBE2AowBIAEgCyABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBARAeIAIgFikDADcDACABIAEpA2A3A0AgASAJIAQgBnNzNgKEASABIAwgBSAPc3M2AoABIAEgCCAUIAVzczYCiAEgASAHIAogBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIBMgAikDADcDACABIAEpA0A3A3AgASABKAJUIg42AoQBIAEgASgCWCIPNgKIASABIAEoAlwiFTYCjAEgASABKAJQIhcgGEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRogASkCZCEfIAEoAmAhGCABIAMgDSAKc3M2AoQBIAEgCyAQIBRzczYCgAEgASASIAwgEHNzNgKIASABIBEgCSANc3M2AowBIAFB8ABqIAFBgAFqIA4gDyAVEB8gASgCcCEUIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgGDYCcCABIB83AnQgASAaNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgFCABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAIgFikDADcDACABIAEpA2A3A0AgASAOIAcgCXNzNgKEASABIBcgCCAMc3M2AoABIAEgDyALIAhzczYCiAEgASAVIAMgB3NzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnwhByABKAJ4IQggASgCcCEMIAEoAnQhCSATIAIpAwA3AwAgASABKQNANwNwIAEgCTYChAEgASAMIBhBHndqNgKAASABIAg2AogBIAEgBzYCjAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAEoAmwhGiABKQJkIR8gASgCYCEYIAEgBiARIANzczYChAEgASAUIBIgC3NzNgKAASABIAUgFyASc3M2AogBIAEgBCAOIBFzczYCjAEgAUHwAGogAUGAAWogCSAIIAcQHyABKAJwIQsgASgCfCENIAEoAnghECABKAJ0IQogASAYNgJwIAEgHzcCdCABIBo2AnwgASAKNgKEASABIBA2AogBIAEgDTYCjAEgASALIAEoAkBBHndqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgFSAOc3M2AoQBIAEgDCAPIBdzczYCgAEgASAIIBQgD3NzNgKIASABIAcgBiAVc3M2AowBIAFB8ABqIAFBgAFqIAogECANEB8gASgCfCERIAEoAnghEiABKAJwIQ4gASgCdCEDIBMgAikDADcDACABIAEpA0A3A3AgASADNgKEASABIA4gGEEed2o2AoABIAEgEjYCiAEgASARNgKMASABQeAAaiABQfAAaiABQYABakECEB4gASgCbCEPIAEpAmQhHyABKAJgIRUgASAKIAQgBnNzNgKEASABIAsgBSAUc3M2AoABIAEgECAMIAVzczYCiAEgASANIAkgBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIAEgFTYCcCABIB83AnQgASAPNgJ8IAEgASgCVCIENgKEASABIAEoAlgiBTYCiAEgASABKAJcIgY2AowBIAEgASgCQEEedyABKAJQIhRqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAMgByAJc3M2AoQBIAEgDiAIIAxzczYCgAEgASASIAsgCHNzNgKIASABIBEgCiAHc3M2AowBIAFB8ABqIAFBgAFqIAQgBSAGEB8gASgCfCEHIAEoAnghCCABKAJwIQ8gASgCdCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIA8gFUEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEDEB4gASgCbCEVIAEpAmQhHyABKAJgIQwgASAEIA0gCnNzNgKEASABIBQgECALc3M2AoABIAEgBSAOIBBzczYCiAEgASAGIAMgDXNzNgKMASABQfAAaiABQYABaiAJIAggBxAfIAEoAnAhECABKAJ8IQogASgCeCELIAEoAnQhDSABIAw2AnAgASAfNwJ0IAEgFTYCfCABIA02AoQBIAEgCzYCiAEgASAKNgKMASABIBAgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgCSARIANzczYChAEgASAPIBIgDnNzNgKAASABIAggFCASc3M2AogBIAEgByAEIBFzczYCjAEgAUHwAGogAUGAAWogDSALIAoQHyABKAJ8IREgASgCeCESIAEoAnAhDiABKAJ0IQMgEyACKQMANwMAIAEgASkDQDcDcCABIAM2AoQBIAEgDiAMQR53ajYCgAEgASASNgKIASABIBE2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiABKAJsIRUgASkCZCEfIAEoAmAhDCABIA0gBiAEc3M2AoQBIAEgECAFIBRzczYCgAEgASALIA8gBXNzNgKIASABIAogCSAGc3M2AowBIAFB8ABqIAFBgAFqIAMgEiAREB8gASgCcCEKIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgDDYCcCABIB83AnQgASAVNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgCiABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAeIAIgFikDADcDACABIAEpA2A3A0AgASADIAcgCXNzNgKEASABIA4gCCAPc3M2AoABIAEgEiAQIAhzczYCiAEgASARIA0gB3NzNgKMASABQdAAaiABQYABaiAGIAUgBBAfIBMgAikDADcDACABIAEpA0A3A3AgASABKQJUNwKEASABIAEoAlw2AowBIAEgASgCUCAMQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAe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DSAKIABBDHZBD3FB4AFyOgAMQQMMAQsgCiAAQRJ2QfABcjoADCAKIABBP3FBgAFyOgAPIAogAEEMdkE/cUGAAXI6AA0gCiAAQQZ2QT9xQYABcjoADkEECyEIIAEoAhghAkF/IQAgAUEcaigCACIJQQxqIQECQAJAAkADQCAAQQFqIgAgBE8NASACIApBDGogCCABKAIAEQUARQ0ACwwBCyACIAcgBiAJQQxqKAIAIgERBQANAEF/IQADQCAAQQFqIgAgA08NAiACIApBDGogCCABEQUARQ0ACwtBAQwBC0EACyEAIApBEGokACAAC0YCAX8BfiMAQSBrIgIkACABKQIAIQMgAkEUaiABKQIINwIAIAJBlBY2AgQgAkGsDjYCACACIAA2AgggAiADNwIMIAIQJAALUAACQAJAQZARKAIAQQFGBEBBlBFBlBEoAgBBAWoiADYCACAAQQNJDQEMAgtBkBFCgYCAgBA3AwALQZwRKAIAIgBBf0wNAEGcESAANgIACwALPwECfyMAQRBrIgEkAAJ/IAAoAggiAiACDQAaQfwVEAcACxogASAAKQIMNwMAIAEgAEEUaikCADcDCCABECMAC7MCAQV/IAAoAhghAwJAAkACQCAAKAIMIgIgAEcEQCAAKAIIIgEgAjYCDCACIAE2AgggAw0BDAILIABBFGoiASAAQRBqIAEoAgAbIgQoAgAiAQRAAkADQCAEIQUgASICQRRqIgQoAgAiAQRAIAENAQwCCyACQRBqIQQgAigCECIBDQALCyAFQQA2AgAgAw0BDAILQQAhAiADRQ0BCwJAIAAoAhwiBEECdEG0E2oiASgCACAARwRAIANBEGogA0EUaiADKAIQIABGGyACNgIAIAINAQwCCyABIAI2AgAgAkUNAgsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAUUNACACQRRqIAE2AgAgASACNgIYCw8LQagRQagRKAIAQX4gBHdxNgIAC8UCAQR/IAACf0EAIAFBCHYiA0UNABpBHyICIAFB////B0sNABogAUEmIANnIgJrQR9xdkEBcUEfIAJrQQF0cgsiAjYCHCAAQgA3AhAgAkECdEG0E2ohAwJAAkACQEGoESgCACIEQQEgAkEfcXQiBXEEQCADKAIAIgQoAgRBeHEgAUcNASAEIQIM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LTFlY2M2Mjk5ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuMy4zL3NyYy9saWIucnNkZXN0aW5hdGlvbiBhbmQgc291cmNlIHNsaWNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc2hhLTEtMC43LjAvc3JjL3V0aWxzLnJzaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogdW5rbm93biBpY29zYXJvdW5kIGluZGV4AEHwCwvSBAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB7BQLnQIWBAAAJAAAAC8IAAATAAAASAIAAAkAAADQBAAAUwAAAEsAAAARAAAAUAQAACAAAABwBAAAWgAAAB8AAAAFAAAAIwUAADQAAABfBwAAFAAAAG0GAAAJAAAAzwUAABgAAAClBQAAKgAAAFcFAABOAAAAQgAAAA4AAAAUBgAAEQAAAC8IAAATAAAA8gIAAAUAAAAlBgAAKwAAAFAGAAARAAAAWQEAABUAAAADAAAAAAAAAAEAAAAEAAAALQcAACAAAABNBwAAEgAAALwHAAAGAAAAwgcAACIAAABfBwAAFAAAAK0HAAAFAAAA5AcAABYAAAD6BwAADQAAAF8HAAAUAAAAswcAAAUAAAAHCAAAKAAAAC8IAAATAAAA9QEAAB4ADAdsaW5raW5nAwKMDw==';

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
const sha256Base64Bytes = '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IAJHDQUgAygCGCABIAIQKxoMAwsgAiEEDAELIANBMGogASACIAQQFiADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQQxqIgYgACgCCBAXIAIgAygCJEcNBCADKAIgIAUgAhArGiAAQQhqQQA2AgAgA0EsaiAGEBgLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAWIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAZIANBLGogAygCCBAYDAALAAsgA0EQaiAAQQxqIAQQGiADKAIUIARHDQEgAygCECABIAQQKxoLIABBCGogBDYCACADQUBrJAAPC0GEFBAHAAtBhBQQBwALQYQUEAcAC98EAgN/AX4jAEHQAGsiAiQAIAIgAUHMAGo2AiQgASkDACEFIAEoAgghBCACIAJBJGo2AigCQCAEQT9NBEAgAUEMaiIDIARqQYABOgAAIAEgASgCCEEBaiIENgIIIAJBGGogAyAEEBcgAigCGEEAIAIoAhwQLRpBwAAgASgCCGtBB00EQCACQShqIAMQGCACQRBqIAMgAUEIaigCABAaIAIoAhBBACACKAIUEC0aCyACQQhqIANBOBAXIAIoAgxBCEcNASACKAIIIAVCOIYgBUIohkKAgICAgIDA/wCDhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwAAIAJBKGogAxAYIAFBCGpBADYCACACQQA2AiggAkEoakEEciEEQQAhAwJAA0AgA0EgRg0BIAQgA2pBADoAACACIAIoAihBAWo2AiggA0EBaiEDDAALAAsgAkFAayABQeQAaikAADcDACACQThqIAFB3ABqKQAANwMAIAJBMGogAUHUAGopAAA3AwAgAiABKQBMNwMoQQAhAwJAA0AgA0EgRg0BIAJBKGogA2oiBCAEKAIAIgRBGHQgBEEIdEGAgPwHcXIgBEEIdkGA/gNxIARBGHZycjYCACADQQRqIQMMAAsACyAAIAIpAyg3AAAgAEEYaiACQUBrKQMANwAAIABBEGogAkE4aikDADcAACAAQQhqIAJBMGopAwA3AAAgAkHQAGokAA8LQdwTIARBwAAQ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KAJsIQggASAPNgJkIAEgDjYCYCABIBM2AmggASAYNgJsIAEgAjYCdCABIBc2AnAgASAQNgJ4IAEgDDYCfCABQdAAaiABQeAAaiABQfAAaiAHQevZwaJ6aiAIQfr/+4V5ahAeIAEoAlwhByABKAJYIQggASgCUCEKIAEoAlQhESABIAI2AmQgASAXNgJgIAEgEDYCaCABIAw2AmwgASARNgJ0IAEgCjYCcCABIAg2AnggASAHNgJ8IAFB0ABqIAFB4ABqIAFB8ABqIA1B8vHFs3xqIBlB98fm93tqEB4gASgCXCENIAEoAlghGCABKAJQIRMgACAeIAEoAlRqNgIEIAAgEyAdajYCACAAIAogIWo2AgggACARICJqNgIMIAAgGCAcajYCECAAIA0gG2o2AhQgACAIICBqNgIYIAAgByAfajYCHCABQYABaiQAC30BAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQSxqQQE2AgAgAkEUakECNgIAIAJBHGpBAjYCACACQQE2AiQgAkGMFTYCCCACQQI2AgwgAkHMDTYCECACIAI2AiAgAiACQQRqNgIoIAIgAkEgajYCGCACQQhqQZwVECgAC3wBAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQSxqQQE2AgAgA0EUakECNgIAIANBHGpBAjYCACADQQE2AiQgA0HcFDYCCCADQQI2AgwgA0HMDTYCECADIANBBGo2AiAgAyADNgIoIAMgA0EgajYCGCADQQhqIAAQKAAL1gEBBn8gACABKAIAIgggAigCBCIHcyACKAIAIgVxIAggB3FzIAVBHncgBUETd3MgBUEKd3NqIAIoAggiBkEadyAGQRV3cyAGQQd3cyAEaiABKAIMaiABKAIIIgQgAigCDCIJcyAGcSAEc2oiCmoiAjYCBCAAIAogASgCBGoiATYCDCAAIAJBHncgAkETd3MgAkEKd3MgAiAHIAVzcSAHIAVxc2ogBCADaiAJIAEgCSAGc3FzaiABQRp3IAFBFXdzIAFBB3dzaiIFajYCACAAIAUgCGo2AggLeAAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgAiAmo2AgAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgQiAmo2AgQgACACQRl3IAJBA3ZzIAJBDndzIAEoAggiAmo2AgggACACQRl3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';

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
const sha512Base64Bytes = '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AjYCACAAIAJBAXI2AgQMBQsgAEGsEygCACACaiICQQFyNgIEQbQTIAA2AgBBrBMgAjYCACAAIAJqIAI2AgAMBAsgAxAiDAELQZwQQZwQKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RBpBBqIQJBnBAoAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAjDAILQZwQIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBsBMgACACayIBNgIAQbgTQbgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEG8FBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUGkDTYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJwALsgEBAn8jAEGABGsiAyQAIANB2ABqIgRCADcDACADQgA3A1AgA0GgAWpBAEGEARAsGiADQeAAakHICkHAABAqGiADQdAAaiABIAIQCSADQagCaiADQdAAakHYARAqGiADQRBqIANBqAJqEAogA0HQAGogA0EQakHAABADIANBsAJqIAQoAgA2AgAgAyADKQNQNwOoAiADQQhqIANBqAJqEAsgACADKQMINwIAIANBgARqJAALuwMCBH8CfiMAQUBqIgMkACAAIAApAwgiByACrUIDhnwiCDcDCCAIIAdUBEAgACAAKQMAQgF8NwMACyADIABBEGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAlAiBQRAQYABIAVrIgQg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sBMoAgAgAGoiADYCACABIABBAXI2AgQgAUG0EygCAEYEQEGsE0EANgIAQbQTQQA2AgALQdQTKAIAIABPDQcCQCAAQSlJDQBBxBMhAANAIAAoAgAiAiABTQRAIAIgACgCBGogAUsNAgsgACgCCCIADQALC0EAIQFBzBMoAgAiAEUNBANAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMBQtBtBMgATYCAEGsE0GsEygCACAAaiIANgIADAcLIAIQIgwBC0GcEEGcECgCAEF+IANBA3Z3cTYCAAsgASAAQQFyNgIEIAEgAGogADYCACABQbQTKAIARw0CQawTIAA2AgAPC0H/HwshAUHUE0F/NgIAQdwTIAE2AgAPC0HcEwJ/AkACfwJAIABB/wFNBEAgAEEDdiICQQN0QaQQaiEAQZwQKAIAIgNBASACQR9xdCICcUUNASAAQQhqIQMgACgCCAwCCyABIAAQI0HcE0HcEygCAEF/aiIBNgIAIAENBEHMEygCACIARQ0CQQAhAQNAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMAwtBnBAgAyACcjYCACAAQQhqIQMgAAshAiADIAE2AgAgAiABNgIMIAEgADYCDCABIAI2AggPC0H/HwsiATYCAAsPCyABIABBAXI2AgQgASAAaiAANgIACzkAAkAgAiABTwRAIAJBgQFPDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAkGAARACAAtNAgF/An4jAEEQayIEJAAgBEEIakEAIAMgASACEBkgBCkDCCEFIAQgAyACIAEgAhAZIAQpAwAhBiAAIAU3AgAgACAGNwIIIARBEGokAAssAQF/IwBBEGsiAyQAIANBCGogAkGAASABEBUgACADKQMINwIAIANBEGokAAsOACAAKAIAKAIAIAEQGws3AAJAIAIgAU8EQCAEIAJJDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAiAEEAIACysBAX8jAEEQayIDJAAgA0EIakEAIAIgARAVIAAgAykDCDcCACADQRBqJAALqioCAn8ifiMAQYAPayICJAAgAkGADmogAUGAARAqGkEAIQECQANAIAFBgAFGDQEgAkGADmogAWoiAyADKQMAIhxCOIYgHEIohkKAgICAgIDA/wCD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c2VydGlvbiBmYWlsZWQ6IDggPT0gZHN0LmxlbigpL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnl0ZS10b29scy0wLjIuMC9zcmMvd3JpdGVfc2luZ2xlLnJzAEHwCQvKBS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjMuMy9zcmMvbGliLnJzAAAAAAAIybzzZ+YJajunyoSFrme7K/iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfhMZzeBbAAAAAABjYXBhY2l0eSBvdmVyZmxvd2NhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVsaWJjb3JlL29wdGlvbi5yczAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB5BML/QEWBAAAJAAAAKcHAAATAAAASAIAAAkAAAA6BAAANAAAANcGAAAUAAAAbQYAAAkAAADwBAAAUwAAAEsAAAARAAAAbgQAACAAAACOBAAAWgAAAB8AAAAFAAAAjQUAABEAAACnBwAAEwAAAPICAAAFAAAAngUAACsAAADJBQAAEQAAAFkBAAAVAAAAAgAAAAAAAAABAAAAAwAAAKUGAAAgAAAAxQYAABIAAAA0BwAABgAAADoHAAAiAAAA1wYAABQAAACtBwAABQAAAFwHAAAWAAAAcgcAAA0AAADXBgAAFAAAALMHAAAFAAAAfwcAACgAAACnBwAAEwAAAPUBAAAeAAwHbGlua2luZwMC5A0=';

/**
 * The most performant way to instantiate ripemd160 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateRipemd160}.
 *
 * @param webassemblyBytes - A buffer containing the ripemd160 binary.
 */
const instantiateRipemd160Bytes = async (webassemblyBytes) => {
    const wasm = await instantiateRustWasm(webassemblyBytes, './ripemd160', 'ripemd160', 'ripemd160_init', 'ripemd160_update', 'ripemd160_final');
    return {
        final: wasm.final,
        hash: wasm.hash,
        init: wasm.init,
        update: wasm.update,
    };
};
const getEmbeddedRipemd160Binary = () => base64ToBin(ripemd160Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of
 * {@link instantiateRipemd160Bytes} that does not require the consumer to
 * provide the ripemd160 binary buffer.
 */
const instantiateRipemd160 = async () => instantiateRipemd160Bytes(getEmbeddedRipemd160Binary());

/* eslint-enable @typescript-eslint/no-duplicate-enum-values */
var Secp256k1Error;
(function (Secp256k1Error) {
    Secp256k1Error["unparsableSignature"] = "Failed to parse signature.";
    Secp256k1Error["unparsablePublicKey"] = "Failed to parse public key.";
    Secp256k1Error["derivePublicKeyFromInvalidPrivateKey"] = "Cannot derive public key from invalid private key.";
    Secp256k1Error["signWithInvalidPrivateKey"] = "Failed to sign message hash. The private key is not valid.";
    Secp256k1Error["recoverPublicKeyWithUnparsableSignature"] = "Failed to recover public key. Could not parse signature.";
    Secp256k1Error["recoverPublicKeyInvalidMaterial"] = "Failed to recover public key. The compact signature, recovery, or message hash is invalid.";
    Secp256k1Error["addTweakPrivateKey"] = "Private key is invalid or adding failed.";
    Secp256k1Error["mulTweakPrivateKey"] = "Private key is invalid or multiplying failed.";
    Secp256k1Error["addTweakPublicKey"] = "Failed to tweak public key (by addition).";
    Secp256k1Error["mulTweakPublicKey"] = "Failed to tweak public key (by multiplication).";
})(Secp256k1Error || (Secp256k1Error = {}));
/**
 * @param secp256k1Wasm - a Secp256k1Wasm object
 * @param randomSeed - a 32-byte random seed used to randomize the context after
 * creation
 */
const wrapSecp256k1Wasm = (secp256k1Wasm, randomSeed) => {
    /**
     * Currently, this wrapper creates a context with both SIGN and VERIFY
     * capabilities. For better initialization performance, consumers could
     * re-implement a wrapper with only the capabilities they require.
     */
    const contextPtr = secp256k1Wasm.contextCreate(ContextFlag.BOTH);
    /**
     * Since all of these methods are single-threaded and synchronous, we can
     * reuse allocated WebAssembly memory for each method without worrying about
     * calls interfering with each other. Likewise, these spaces never need to be
     * `free`d, since we will continue using them until this entire object (and
     * with it, the entire WebAssembly instance) is garbage collected.
     *
     * If malicious javascript gained access to this object, it should be
     * considered a critical vulnerability in the consumer. However, as a best
     * practice, we zero out private keys below when we're finished with them.
     */
    const sigScratch = secp256k1Wasm.malloc(72 /* ByteLength.maxECDSASig */);
    const publicKeyScratch = secp256k1Wasm.malloc(65 /* ByteLength.maxPublicKey */);
    const messageHashScratch = secp256k1Wasm.malloc(32 /* ByteLength.messageHash */);
    const internalPublicKeyPtr = secp256k1Wasm.malloc(64 /* ByteLength.internalPublicKey */);
    const internalSigPtr = secp256k1Wasm.malloc(64 /* ByteLength.internalSig */);
    const schnorrSigPtr = secp256k1Wasm.malloc(64 /* ByteLength.schnorrSig */);
    const privateKeyPtr = secp256k1Wasm.malloc(32 /* ByteLength.privateKey */);
    const internalRSigPtr = secp256k1Wasm.malloc(65 /* ByteLength.recoverableSig */);
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    const recoveryNumPtr = secp256k1Wasm.malloc(4);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const recoveryNumPtrView32 = recoveryNumPtr >> 2;
    const getRecoveryNumPtr = () => secp256k1Wasm.heapU32[recoveryNumPtrView32];
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    const lengthPtr = secp256k1Wasm.malloc(4);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const lengthPtrView32 = lengthPtr >> 2;
    const cloneAndPad = (value, expectedLength) => {
        const zeroPaddedValue = new Uint8Array(expectedLength);
        zeroPaddedValue.set(value);
        return zeroPaddedValue;
    };
    const parsePublicKey = (publicKey) => {
        const paddedPublicKey = cloneAndPad(publicKey, 65 /* ByteLength.maxPublicKey */);
        secp256k1Wasm.heapU8.set(paddedPublicKey, publicKeyScratch);
        return (secp256k1Wasm.pubkeyParse(contextPtr, internalPublicKeyPtr, publicKeyScratch, 
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        publicKey.length) === 1);
    };
    const setLengthPtr = (value) => {
        secp256k1Wasm.heapU32.set([value], lengthPtrView32);
    };
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const getLengthPtr = () => secp256k1Wasm.heapU32[lengthPtrView32];
    const serializePublicKey = (length, flag) => {
        setLengthPtr(length);
        secp256k1Wasm.pubkeySerialize(contextPtr, publicKeyScratch, lengthPtr, internalPublicKeyPtr, flag);
        return secp256k1Wasm.readHeapU8(publicKeyScratch, getLengthPtr()).slice();
    };
    const getSerializedPublicKey = (compressed) => compressed
        ? serializePublicKey(33 /* ByteLength.compressedPublicKey */, CompressionFlag.COMPRESSED)
        : serializePublicKey(65 /* ByteLength.uncompressedPublicKey */, CompressionFlag.UNCOMPRESSED);
    const convertPublicKey = (compressed) => (publicKey) => {
        if (!parsePublicKey(publicKey)) {
            return Secp256k1Error.unparsablePublicKey;
        }
        return getSerializedPublicKey(compressed);
    };
    const parseSignature = (signature, isDer) => {
        const paddedSignature = cloneAndPad(signature, 72 /* ByteLength.maxECDSASig */);
        secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
        return isDer
            ? secp256k1Wasm.signatureParseDER(contextPtr, internalSigPtr, sigScratch, signature.length) === 1
            : secp256k1Wasm.signatureParseCompact(contextPtr, internalSigPtr, sigScratch) === 1;
    };
    const getCompactSig = () => {
        secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, 64 /* ByteLength.compactSig */).slice();
    };
    const getDERSig = () => {
        setLengthPtr(72 /* ByteLength.maxECDSASig */);
        secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
    };
    const convertSignature = (wasDER) => (signature) => {
        if (!parseSignature(signature, wasDER)) {
            return Secp256k1Error.unparsableSignature;
        }
        return wasDER ? getCompactSig() : getDERSig();
    };
    const fillPrivateKeyPtr = (privateKey) => {
        const paddedPrivateKey = cloneAndPad(privateKey, 32 /* ByteLength.privateKey */);
        secp256k1Wasm.heapU8.set(paddedPrivateKey, privateKeyPtr);
    };
    const zeroOutPtr = (pointer, bytes) => {
        secp256k1Wasm.heapU8.fill(0, pointer, pointer + bytes);
    };
    const zeroOutPrivateKeyPtr = () => {
        zeroOutPtr(privateKeyPtr, 32 /* ByteLength.privateKey */);
    };
    const withPrivateKey = (privateKey, instructions) => {
        fillPrivateKeyPtr(privateKey);
        const ret = instructions();
        zeroOutPrivateKeyPtr();
        return ret;
    };
    const derivePublicKey = (compressed) => (privateKey) => {
        const invalid = withPrivateKey(privateKey, () => secp256k1Wasm.pubkeyCreate(contextPtr, internalPublicKeyPtr, privateKeyPtr) !== 1);
        if (invalid) {
            return Secp256k1Error.derivePublicKeyFromInvalidPrivateKey;
        }
        return getSerializedPublicKey(compressed);
    };
    const fillMessageHashScratch = (messageHash) => {
        const paddedMessageHash = cloneAndPad(messageHash, 32 /* ByteLength.messageHash */);
        secp256k1Wasm.heapU8.set(paddedMessageHash, messageHashScratch);
    };
    const normalizeSignature = () => {
        secp256k1Wasm.signatureNormalize(contextPtr, internalSigPtr, internalSigPtr);
    };
    const modifySignature = (isDer, normalize) => (signature) => {
        if (!parseSignature(signature, isDer)) {
            return Secp256k1Error.unparsableSignature;
        }
        if (normalize) {
            normalizeSignature();
        }
        else {
            secp256k1Wasm.signatureMalleate(contextPtr, internalSigPtr, internalSigPtr);
        }
        return isDer ? getDERSig() : getCompactSig();
    };
    const parseAndNormalizeSignature = (signature, isDer, normalize) => {
        const ret = parseSignature(signature, isDer);
        if (normalize) {
            normalizeSignature();
        }
        return ret;
    };
    const signMessageHash = (isDer) => (privateKey, messageHash) => {
        fillMessageHashScratch(messageHash);
        return withPrivateKey(privateKey, () => {
            const failed = secp256k1Wasm.sign(contextPtr, internalSigPtr, messageHashScratch, privateKeyPtr) !== 1;
            if (failed) {
                return Secp256k1Error.signWithInvalidPrivateKey;
            }
            if (isDer) {
                setLengthPtr(72 /* ByteLength.maxECDSASig */);
                secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
                return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
            }
            secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
            return secp256k1Wasm
                .readHeapU8(sigScratch, 64 /* ByteLength.compactSig */)
                .slice();
        });
    };
    const signMessageHashSchnorr = () => (privateKey, messageHash) => {
        fillMessageHashScratch(messageHash);
        return withPrivateKey(privateKey, () => {
            const failed = secp256k1Wasm.schnorrSign(contextPtr, schnorrSigPtr, messageHashScratch, privateKeyPtr) !== 1;
            if (failed) {
                return Secp256k1Error.signWithInvalidPrivateKey;
            }
            return secp256k1Wasm
                .readHeapU8(schnorrSigPtr, 64 /* ByteLength.schnorrSig */)
                .slice();
        });
    };
    const verifyMessage = (messageHash) => {
        fillMessageHashScratch(messageHash);
        return (secp256k1Wasm.verify(contextPtr, internalSigPtr, messageHashScratch, internalPublicKeyPtr) === 1);
    };
    const verifySignature = (isDer, normalize) => (signature, publicKey, messageHash) => parsePublicKey(publicKey) &&
        parseAndNormalizeSignature(signature, isDer, normalize) &&
        verifyMessage(messageHash);
    const verifyMessageSchnorr = (messageHash, signature) => {
        fillMessageHashScratch(messageHash);
        const paddedSignature = cloneAndPad(signature, 64 /* ByteLength.schnorrSig */);
        secp256k1Wasm.heapU8.set(paddedSignature, schnorrSigPtr);
        return (secp256k1Wasm.schnorrVerify(contextPtr, schnorrSigPtr, messageHashScratch, internalPublicKeyPtr) === 1);
    };
    const verifySignatureSchnorr = () => (signature, publicKey, messageHash) => parsePublicKey(publicKey)
        ? verifyMessageSchnorr(messageHash, signature)
        : false;
    const signMessageHashRecoverable = (privateKey, messageHash) => {
        fillMessageHashScratch(messageHash);
        return withPrivateKey(privateKey, () => {
            if (secp256k1Wasm.signRecoverable(contextPtr, internalRSigPtr, messageHashScratch, privateKeyPtr) !== 1) {
                return Secp256k1Error.signWithInvalidPrivateKey;
            }
            secp256k1Wasm.recoverableSignatureSerialize(contextPtr, sigScratch, recoveryNumPtr, internalRSigPtr);
            return {
                recoveryId: getRecoveryNumPtr(),
                signature: secp256k1Wasm
                    .readHeapU8(sigScratch, 64 /* ByteLength.compactSig */)
                    .slice(),
            };
        });
    };
    const recoverPublicKey = (compressed) => (signature, recoveryId, messageHash) => {
        fillMessageHashScratch(messageHash);
        const paddedSignature = cloneAndPad(signature, 72 /* ByteLength.maxECDSASig */);
        secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
        if (secp256k1Wasm.recoverableSignatureParse(contextPtr, internalRSigPtr, sigScratch, recoveryId) !== 1) {
            return Secp256k1Error.recoverPublicKeyWithUnparsableSignature;
        }
        if (secp256k1Wasm.recover(contextPtr, internalPublicKeyPtr, internalRSigPtr, messageHashScratch) !== 1) {
            return Secp256k1Error.recoverPublicKeyInvalidMaterial;
        }
        return getSerializedPublicKey(compressed);
    };
    const addTweakPrivateKey = (privateKey, tweakValue) => {
        fillMessageHashScratch(tweakValue);
        return withPrivateKey(privateKey, () => {
            if (secp256k1Wasm.privkeyTweakAdd(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
                return Secp256k1Error.addTweakPrivateKey;
            }
            return secp256k1Wasm
                .readHeapU8(privateKeyPtr, 32 /* ByteLength.privateKey */)
                .slice();
        });
    };
    const mulTweakPrivateKey = (privateKey, tweakValue) => {
        fillMessageHashScratch(tweakValue);
        return withPrivateKey(privateKey, () => {
            if (secp256k1Wasm.privkeyTweakMul(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
                return Secp256k1Error.mulTweakPrivateKey;
            }
            return secp256k1Wasm
                .readHeapU8(privateKeyPtr, 32 /* ByteLength.privateKey */)
                .slice();
        });
    };
    const addTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
        if (!parsePublicKey(publicKey)) {
            return Secp256k1Error.unparsablePublicKey;
        }
        fillMessageHashScratch(tweakValue);
        if (secp256k1Wasm.pubkeyTweakAdd(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
            return Secp256k1Error.addTweakPublicKey;
        }
        return getSerializedPublicKey(compressed);
    };
    const mulTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
        if (!parsePublicKey(publicKey)) {
            return Secp256k1Error.unparsablePublicKey;
        }
        fillMessageHashScratch(tweakValue);
        if (secp256k1Wasm.pubkeyTweakMul(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
            return Secp256k1Error.mulTweakPublicKey;
        }
        return getSerializedPublicKey(compressed);
    };
    if (randomSeed !== undefined) {
        const randomSeedPtr = messageHashScratch;
        const paddedRandomSeed = cloneAndPad(randomSeed, 32 /* ByteLength.randomSeed */);
        secp256k1Wasm.heapU8.set(paddedRandomSeed, randomSeedPtr);
        secp256k1Wasm.contextRandomize(contextPtr, randomSeedPtr);
        zeroOutPtr(randomSeedPtr, 32 /* ByteLength.randomSeed */);
    }
    return {
        addTweakPrivateKey,
        addTweakPublicKeyCompressed: addTweakPublicKey(true),
        addTweakPublicKeyUncompressed: addTweakPublicKey(false),
        compressPublicKey: convertPublicKey(true),
        derivePublicKeyCompressed: derivePublicKey(true),
        derivePublicKeyUncompressed: derivePublicKey(false),
        malleateSignatureCompact: modifySignature(false, false),
        malleateSignatureDER: modifySignature(true, false),
        mulTweakPrivateKey,
        mulTweakPublicKeyCompressed: mulTweakPublicKey(true),
        mulTweakPublicKeyUncompressed: mulTweakPublicKey(false),
        normalizeSignatureCompact: modifySignature(false, true),
        normalizeSignatureDER: modifySignature(true, true),
        recoverPublicKeyCompressed: recoverPublicKey(true),
        recoverPublicKeyUncompressed: recoverPublicKey(false),
        signMessageHashCompact: signMessageHash(false),
        signMessageHashDER: signMessageHash(true),
        signMessageHashRecoverableCompact: signMessageHashRecoverable,
        signMessageHashSchnorr: signMessageHashSchnorr(),
        signatureCompactToDER: convertSignature(false),
        signatureDERToCompact: convertSignature(true),
        uncompressPublicKey: convertPublicKey(false),
        validatePrivateKey: (privateKey) => withPrivateKey(privateKey, () => secp256k1Wasm.seckeyVerify(contextPtr, privateKeyPtr) === 1),
        validatePublicKey: parsePublicKey,
        verifySignatureCompact: verifySignature(false, true),
        verifySignatureCompactLowS: verifySignature(false, false),
        verifySignatureDER: verifySignature(true, true),
        verifySignatureDERLowS: verifySignature(true, false),
        verifySignatureSchnorr: verifySignatureSchnorr(),
    };
};
/**
 * This method is like {@link instantiateSecp256k1}, but requires the consumer
 * to `Window.fetch` or `fs.readFile` the `secp256k1.wasm` binary and provide it
 * to this method as `webassemblyBytes`. This skips a base64 decoding of an
 * embedded binary.
 *
 * ### Randomizing the Context with `randomSeed`
 * This method also accepts an optional, 32-byte `randomSeed`, which is passed
 * to the `contextRandomize` method in the underlying WebAssembly.
 *
 * In the secp256k1 C library, context randomization is an additional layer of
 * security from side-channel attacks that attempt to extract private key
 * information by analyzing things like a CPU's emitted radio frequencies or
 * power usage.
 *
 * As most applications also benefit from deterministic, reproducible behavior,
 * context is not randomized by default in Libauth. To randomize the context,
 * provide a 32-byte Uint8Array of cryptographically strong random values
 * (e.g. `crypto.getRandomValues(new Uint8Array(32))`).
 *
 * @param webassemblyBytes - an ArrayBuffer containing the bytes from Libauth's
 * `secp256k1.wasm` binary. Providing this buffer manually may be faster than
 * the internal base64 decode that happens in {@link instantiateSecp256k1}.
 * @param randomSeed - a 32-byte random seed used to randomize the secp256k1
 * context after creation. See above for details.
 */
const instantiateSecp256k1Bytes = async (webassemblyBytes, randomSeed) => wrapSecp256k1Wasm(await instantiateSecp256k1WasmBytes(webassemblyBytes), randomSeed);
/**
 * Create and wrap a Secp256k1 WebAssembly instance to expose a set of
 * purely-functional Secp256k1 methods. For slightly faster initialization, use
 * {@link instantiateSecp256k1Bytes}.
 *
 * @param randomSeed - a 32-byte random seed used to randomize the secp256k1
 * context after creation. See the description in
 * {@link instantiateSecp256k1Bytes} for details.
 */
const instantiateSecp256k1 = async (randomSeed) => wrapSecp256k1Wasm(await instantiateSecp256k1Wasm(), randomSeed);

/**
 * The most performant way to instantiate sha1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSha1}.
 *
 * @param webassemblyBytes - A buffer containing the sha1 binary.
 */
const instantiateSha1Bytes = async (webassemblyBytes) => {
    const wasm = await instantiateRustWasm(webassemblyBytes, './sha1', 'sha1', 'sha1_init', 'sha1_update', 'sha1_final');
    return {
        final: wasm.final,
        hash: wasm.hash,
        init: wasm.init,
        update: wasm.update,
    };
};
const getEmbeddedSha1Binary = () => base64ToBin(sha1Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of {@link instantiateSha1Bytes}
 * that does not require the consumer to provide the sha1 binary buffer.
 */
const instantiateSha1 = async () => instantiateSha1Bytes(getEmbeddedSha1Binary());

/**
 * The most performant way to instantiate sha256 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSha256}.
 *
 * @param webassemblyBytes - A buffer containing the sha256 binary.
 */
const instantiateSha256Bytes = async (webassemblyBytes) => {
    const wasm = await instantiateRustWasm(webassemblyBytes, './sha256', 'sha256', 'sha256_init', 'sha256_update', 'sha256_final');
    return {
        final: wasm.final,
        hash: wasm.hash,
        init: wasm.init,
        update: wasm.update,
    };
};
const getEmbeddedSha256Binary = () => base64ToBin(sha256Base64Bytes).buffer;
/**
 * An ultimately-portable (but possibly slower) version of
 * {@link instantiateSha256Bytes} which does not require the consumer to provide
 * the sha256 binary buffer.
 */
const instantiateSha256 = async () => instantiateSha256Bytes(getEmbeddedSha256Binary());

/**
 * The most performant way to instantiate sha512 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSha512}.
 *
 * @param webassemblyBytes - A buffer containing the sha512 binary.
 */
const instantiateSha512Bytes = async (webassemblyBytes) => {
    const wasm = await instantiateRustWasm(webassemblyBytes, './sha512', 'sha512', 'sha512_init', 'sha512_update', 'sha512_final');
    return {
        final: wasm.final,
        hash: wasm.hash,
        init: wasm.init,
        update: wasm.update,
    };
};
const getEmbeddedSha512Binary = () => base64ToBin(sha512Base64Bytes).buffer;
/**
 * An ultimately-portable (but slower) version of {@link instantiateSha512Bytes}
 * that does not require the consumer to provide the sha512 binary buffer.
 */
const instantiateSha512 = async () => instantiateSha512Bytes(getEmbeddedSha512Binary());

const [sha1, sha256, sha512, ripemd160, secp256k1] = await Promise.all([
    instantiateSha1(),
    instantiateSha256(),
    instantiateSha512(),
    instantiateRipemd160(),
    instantiateSecp256k1(),
]);

/**
 * Hash the given payload with sha256, then hash the 32-byte result with
 * ripemd160, returning a 20-byte hash.
 *
 * This hash is used in both {@link AddressType.p2pkh} and
 * {@link AddressType.p2sh20} addresses.
 *
 * @param payload - the Uint8Array to hash
 */
const hash160 = (payload, crypto = { ripemd160: ripemd160, sha256: sha256 }) => crypto.ripemd160.hash(crypto.sha256.hash(payload));
/**
 * Hash the given payload with sha256, then hash the 32-byte result with
 * one final round of sha256, returning a 32-byte hash.
 *
 * This type of hash is used to generate identifiers for transactions and blocks
 * (and therefore in block mining).
 *
 * @param payload - the Uint8Array to hash
 */
const hash256 = (payload, sha256$1 = sha256) => sha256$1.hash(sha256$1.hash(payload));

/**
 * Instantiate a hash-based message authentication code (HMAC) function as
 * specified by RFC 2104.
 *
 * @param hashFunction - a cryptographic hash function that iterates a basic
 * compression function over blocks of data
 * @param blockByteLength - the byte-length of blocks used in `hashFunction`
 */
const instantiateHmacFunction = (hashFunction, blockByteLength) => (secret, message) => {
    const key = new Uint8Array(blockByteLength).fill(0);
    // eslint-disable-next-line functional/no-expression-statements
    key.set(secret.length > blockByteLength ? hashFunction(secret) : secret, 0);
    const innerPaddingFill = 0x36;
    const innerPadding = new Uint8Array(blockByteLength).fill(innerPaddingFill);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
    const innerPrefix = innerPadding.map((pad, index) => pad ^ key[index]);
    const innerContent = flattenBinArray([innerPrefix, message]);
    const innerResult = hashFunction(innerContent);
    const outerPaddingFill = 0x5c;
    const outerPadding = new Uint8Array(blockByteLength).fill(outerPaddingFill);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
    const outerPrefix = outerPadding.map((pad, index) => pad ^ key[index]);
    return hashFunction(flattenBinArray([outerPrefix, innerResult]));
};
const sha256BlockByteLength = 64;
/**
 * Create a hash-based message authentication code using HMAC-SHA256 as
 * specified in `RFC 4231`. Returns a 32-byte Uint8Array.
 *
 * Secrets longer than the block byte-length (64 bytes) are hashed before
 * use, shortening their length to the minimum recommended length (32 bytes).
 * See `RFC 2104` for details.
 *
 * @param secret - the secret key (recommended length: 32-64 bytes)
 * @param message - the message to authenticate
 * @param sha256 - an implementation of Sha256 (defaults to the
 * internal WASM implementation)
 */
const hmacSha256 = (secret, message, sha256$1 = sha256) => instantiateHmacFunction(sha256$1.hash, sha256BlockByteLength)(secret, message);
const sha512BlockByteLength = 128;
/**
 * Create a hash-based message authentication code using HMAC-SHA512 as
 * specified in `RFC 4231`. Returns a 64-byte Uint8Array.
 *
 * Secrets longer than the block byte-length (128 bytes) are hashed before
 * use, shortening their length to the minimum recommended length (64 bytes).
 * See `RFC 2104` for details.
 *
 * @param secret - the secret key (recommended length: 64-128 bytes)
 * @param message - the message to authenticate
 * @param sha512 - an implementation of Sha512 (defaults to the
 * internal WASM implementation)
 */
const hmacSha512 = (secret, message, sha512$1 = sha512) => instantiateHmacFunction(sha512$1.hash, sha512BlockByteLength)(secret, message);

var Pbkdf2Error;
(function (Pbkdf2Error) {
    Pbkdf2Error["invalidIterations"] = "Invalid PBKDF2 parameters: iterations must be a positive integer.";
    Pbkdf2Error["invalidDerivedKeyLength"] = "Invalid PBKDF2 parameters: derived key length must be a positive integer.";
    Pbkdf2Error["invalidHmacLength"] = "Invalid HMAC length: HMAC length must be a positive integer.";
})(Pbkdf2Error || (Pbkdf2Error = {}));
/**
 * Instantiate a PBKDF2 function as specified by RFC 2898.
 *
 * @param hmacFunction - the HMAC function to use
 * @param hmacByteLength - the byte-length of the HMAC function
 */
const instantiatePbkdf2Function = (hmacFunction, hmacByteLength) => 
// eslint-disable-next-line complexity
(parameters) => {
    /* eslint-disable functional/immutable-data, functional/no-let, functional/no-loop-statements, functional/no-expression-statements, no-bitwise, no-plusplus */
    const { password, salt, iterations, derivedKeyLength } = parameters;
    if (!Number.isInteger(iterations) || iterations <= 0) {
        return formatError(Pbkdf2Error.invalidIterations, `Iterations parameter: ${iterations}.`);
    }
    if (!Number.isInteger(derivedKeyLength) || derivedKeyLength <= 0) {
        return formatError(Pbkdf2Error.invalidDerivedKeyLength, `Derived key length: ${derivedKeyLength}.`);
    }
    if (!Number.isInteger(hmacByteLength) || hmacByteLength <= 0) {
        return formatError(Pbkdf2Error.invalidHmacLength, `HMAC length: ${hmacByteLength}.`);
    }
    const iterationCountByteLength = 4;
    const derivedKey = new Uint8Array(derivedKeyLength);
    const block = new Uint8Array(salt.length + iterationCountByteLength);
    block.set(salt, 0);
    let writePosition = 0;
    const length = Math.ceil(derivedKeyLength / hmacByteLength);
    for (let i = 1; i <= length; i++) {
        const iterationUint32BEEncoded = numberToBinUint32BE(i);
        block.set(iterationUint32BEEncoded, salt.length);
        const accumulatedMac = hmacFunction(password, block);
        let intermediateMac = accumulatedMac;
        for (let j = 1; j < iterations; j++) {
            intermediateMac = hmacFunction(password, intermediateMac);
            for (let k = 0; k < hmacByteLength; k++) {
                accumulatedMac[k] ^= intermediateMac[k]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
            }
        }
        const truncatedResult = accumulatedMac.subarray(0, derivedKeyLength);
        derivedKey.set(truncatedResult, writePosition);
        writePosition += hmacByteLength;
    }
    return derivedKey;
    /* eslint-enable functional/immutable-data, functional/no-let, functional/no-loop-statements, functional/no-expression-statements, no-bitwise, no-plusplus */
};
const hmacSha256ByteLength = 32;
/**
 * Derive a key using PBKDF2 and the HMAC SHA256 function as specified in RFC 2898.
 *
 * Note, if the provided `parameters` are valid, this method will never error.
 *
 * @param parameters - the PBKDF2 parameters to use
 * @param sha256Hmac - the SHA256 HMAC implementation to use (defaults to the
 * internal WASM implementation)
 */
const pbkdf2HmacSha256 = (parameters, sha256Hmac = hmacSha256) => instantiatePbkdf2Function(sha256Hmac, hmacSha256ByteLength)(parameters);
const hmacSha512ByteLength = 64;
/**
 * Derive a key using PBKDF2 and the HMAC SHA512 function as specified in RFC 2898.
 *
 * Note, if the provided `parameters` are valid, this method will never error.
 *
 * @param parameters - the PBKDF2 parameters to use
 * @param sha512Hmac - the SHA512 HMAC implementation to use (defaults to the
 * internal WASM implementation)
 */
const pbkdf2HmacSha512 = (parameters, sha512Hmac = hmacSha512) => instantiatePbkdf2Function(sha512Hmac, hmacSha512ByteLength)(parameters);

/**
 * Base58 version byte values for common Base58Address format
 * (A.K.A. "Base58Check") versions.
 */
var Base58AddressFormatVersion;
(function (Base58AddressFormatVersion) {
    /**
     * A Pay to Public Key Hash (P2PKH) address – base58 encodes to a leading `1`.
     *
     * Hex: `0x00`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["p2pkh"] = 0] = "p2pkh";
    /**
     * A 20-byte Pay to Script Hash (P2SH20) address – base58 encodes to a leading
     * `3`.
     *
     * Hex: `0x05`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["p2sh20"] = 5] = "p2sh20";
    /**
     * A private key in Wallet Import Format. For private keys used with
     * uncompressed public keys, the payload is 32 bytes and causes the version
     * to be encoded as a `5`. For private keys used with compressed public keys,
     * a final `0x01` byte is appended to the private key, increasing the payload
     * to 33 bytes, and causing the version to be encoded as a `K` or `L`.
     *
     * Hex: `0x80`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["wif"] = 128] = "wif";
    /**
     * A testnet Pay to Public Key Hash (P2PKH) address – base58 encodes to a
     * leading `m` or `n`.
     *
     * Hex: `0x6f`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["p2pkhTestnet"] = 111] = "p2pkhTestnet";
    /**
     * A testnet 20-byte Pay to Script Hash (P2SH20) address – base58 encodes to a
     * leading `2`.
     *
     * Hex: `0xc4`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["p2sh20Testnet"] = 196] = "p2sh20Testnet";
    /**
     * A private key in Wallet Import Format intended for testnet use. For private
     * keys used with uncompressed public keys, the payload is 32 bytes and causes
     * the version to be encoded as a `9`. For private keys used with compressed
     * public keys, a final `0x01` byte is appended to the private key, increasing
     * the payload to 33 bytes, and causing the version to be encoded as a `c`.
     *
     * Hex: `0xef`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["wifTestnet"] = 239] = "wifTestnet";
    /**
     * A Pay to Public Key Hash (P2PKH) address intended for use on the Bitcoin
     * Cash network – base58 encodes to a leading `C`. This version was
     * temporarily used by the Copay project before the CashAddress format was
     * standardized.
     *
     * Hex: `0x1c`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["p2pkhCopayBCH"] = 28] = "p2pkhCopayBCH";
    /**
     * A 20-byte Pay to Script Hash (P2SH20) address intended for use on the
     * Bitcoin Cash network – base58 encodes to a leading `H`. This version was
     * temporarily used by the Copay project before the CashAddress format was
     * standardized.
     *
     * Hex: `0x28`
     */
    Base58AddressFormatVersion[Base58AddressFormatVersion["p2sh20CopayBCH"] = 40] = "p2sh20CopayBCH";
})(Base58AddressFormatVersion || (Base58AddressFormatVersion = {}));
/**
 * Encode a payload using the Base58Address format (A.K.A. "Base58Check"), the
 * original address format used by the Satoshi implementation.
 *
 * Note, this method does not enforce error handling via the type system. The
 * returned string will not be a valid Base58Address if `hash` is not exactly 20
 * bytes. If needed, validate the length of `hash` before calling this method.
 *
 * To decode a Base58Address-like format, use {@link decodeBase58AddressFormat}.
 *
 * @remarks
 * A Base58Address includes a 1-byte prefix to indicate the address version, a
 * variable-length payload, and a 4-byte checksum:
 *
 * `[version: 1 byte] [payload: variable length] [checksum: 4 bytes]`
 *
 * The checksum is the first 4 bytes of the double-SHA256 hash of the version
 * byte followed by the payload.
 *
 * @param version - the address version byte (see
 * {@link Base58AddressFormatVersion})
 * @param payload - the Uint8Array payload to encode
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
const encodeBase58AddressFormat = (version, payload, sha256$1 = sha256) => {
    const checksumBytes = 4;
    const content = Uint8Array.from([version, ...payload]);
    const checksum = hash256(content, sha256$1).slice(0, checksumBytes);
    const bin = flattenBinArray([content, checksum]);
    return binToBase58(bin);
};
/**
 * Encode a hash as a Base58Address.
 *
 * Note, this method does not enforce error handling via the type system. The
 * returned string will not be a valid Base58Address if `hash` is not exactly 20
 * bytes. If needed, validate the length of `hash` before calling this method.
 *
 * For other standards that use the Base58Address format but have other version
 * or length requirements, use {@link encodeCashAddressFormat}.
 *
 * To decode a Base58Address, see {@link decodeBase58Address}.
 *
 * @param type - the type of address to encode: `p2pkh`, `p2sh20`,
 * `p2pkh-testnet`, or `p2sh20-testnet`
 * @param hash - the 20-byte hash to encode
 * (`RIPEMD160(SHA256(public key or bytecode))`)
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
const encodeBase58Address = (type, payload, sha256$1 = sha256) => encodeBase58AddressFormat({
    p2pkh: Base58AddressFormatVersion.p2pkh,
    p2pkhCopayBCH: Base58AddressFormatVersion.p2pkhCopayBCH,
    p2pkhTestnet: Base58AddressFormatVersion.p2pkhTestnet,
    p2sh20: Base58AddressFormatVersion.p2sh20,
    p2sh20CopayBCH: Base58AddressFormatVersion.p2sh20CopayBCH,
    p2sh20Testnet: Base58AddressFormatVersion.p2sh20Testnet,
}[type], payload, sha256$1);
var Base58AddressError;
(function (Base58AddressError) {
    Base58AddressError["unknownCharacter"] = "Base58Address error: address may only contain valid base58 characters.";
    Base58AddressError["tooShort"] = "Base58Address error: address is too short to be valid.";
    Base58AddressError["invalidChecksum"] = "Base58Address error: address has an invalid checksum.";
    Base58AddressError["unknownAddressVersion"] = "Base58Address error: address uses an unknown address version.";
    Base58AddressError["incorrectLength"] = "Base58Address error: the encoded payload is not the correct length (20 bytes).";
})(Base58AddressError || (Base58AddressError = {}));
/**
 * Attempt to decode a Base58Address-formatted string. This is more lenient than
 * {@link decodeCashAddress}, which also validates the address version.
 *
 * Returns the contents of the address or an error message as a string.
 *
 * To encode a Base58Address-like format, use {@link encodeBase58AddressFormat}.
 *
 * @param address - the string to decode as a base58 address
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
const decodeBase58AddressFormat = (address, sha256$1 = sha256) => {
    const checksumBytes = 4;
    const bin = base58ToBin(address);
    if (typeof bin === 'string') {
        return formatError(Base58AddressError.unknownCharacter, bin);
    }
    const minimumBase58AddressLength = 5;
    if (bin.length < minimumBase58AddressLength) {
        return Base58AddressError.tooShort;
    }
    const content = bin.slice(0, -checksumBytes);
    const checksum = bin.slice(-checksumBytes);
    const expectedChecksum = sha256$1
        .hash(sha256$1.hash(content))
        .slice(0, checksumBytes);
    if (!checksum.every((value, i) => value === expectedChecksum[i])) {
        return Base58AddressError.invalidChecksum;
    }
    return {
        payload: content.slice(1),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        version: content[0],
    };
};
/**
 * Decode and validate a Base58Address, strictly checking the version and
 * payload length.
 *
 * Because the Wallet Import Format (WIF) private key serialization format uses
 * the Base58Address format, some libraries allow WIF key decoding via the same
 * method as base58 address decoding. This method accepts only Base58Address
 * types, but WIF keys can be decoded with {@link decodePrivateKeyWif}.
 *
 * For other address-like standards that closely follow the Base58Address
 * format (but have alternative version byte requirements), use
 * {@link decodeBase58AddressFormat}.
 *
 * To encode a Base58Address, see {@link encodeBase58Address}.
 *
 * @param address - the string to decode as a base58 address
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
const decodeBase58Address = (address, sha256$1 = sha256) => {
    const decoded = decodeBase58AddressFormat(address, sha256$1);
    if (typeof decoded === 'string')
        return decoded;
    if (![
        Base58AddressFormatVersion.p2pkh,
        Base58AddressFormatVersion.p2sh20,
        Base58AddressFormatVersion.p2pkhTestnet,
        Base58AddressFormatVersion.p2sh20Testnet,
        Base58AddressFormatVersion.p2pkhCopayBCH,
        Base58AddressFormatVersion.p2sh20CopayBCH,
    ].includes(decoded.version)) {
        return Base58AddressError.unknownAddressVersion;
    }
    const hash160Length = 20;
    if (decoded.payload.length !== hash160Length) {
        return Base58AddressError.incorrectLength;
    }
    return decoded;
};

/**
 * The list of 32 symbols used in Bech32 encoding.
 */
// cspell: disable-next-line
const bech32CharacterSet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
// prettier-ignore
const bech32CharacterSetIndex = { q: 0, p: 1, z: 2, r: 3, y: 4, '9': 5, x: 6, '8': 7, g: 8, f: 9, '2': 10, t: 11, v: 12, d: 13, w: 14, '0': 15, s: 16, '3': 17, j: 18, n: 19, '5': 20, '4': 21, k: 22, h: 23, c: 24, e: 25, '6': 26, m: 27, u: 28, a: 29, '7': 30, l: 31 }; // eslint-disable-line sort-keys, @typescript-eslint/naming-convention
var BitRegroupingError;
(function (BitRegroupingError) {
    BitRegroupingError["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
    BitRegroupingError["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
    BitRegroupingError["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError || (BitRegroupingError = {}));
/* eslint-disable functional/no-let, no-bitwise, functional/no-expression-statements, functional/no-conditional-statements, complexity */
/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 */
// Derived from: https://github.com/sipa/bech32
const regroupBits = ({ bin, sourceWordLength, resultWordLength, allowPadding = true, }) => {
    let accumulator = 0;
    let bits = 0;
    const result = [];
    const maxResultInt = (1 << resultWordLength) - 1;
    // eslint-disable-next-line functional/no-loop-statements, @typescript-eslint/prefer-for-of, no-plusplus
    for (let p = 0; p < bin.length; ++p) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = bin[p];
        if (value < 0 || value >> sourceWordLength !== 0) {
            return BitRegroupingError.integerOutOfRange;
        }
        accumulator = (accumulator << sourceWordLength) | value;
        bits += sourceWordLength;
        // eslint-disable-next-line functional/no-loop-statements
        while (bits >= resultWordLength) {
            bits -= resultWordLength;
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator >> bits) & maxResultInt);
        }
    }
    if (allowPadding) {
        if (bits > 0) {
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator << (resultWordLength - bits)) & maxResultInt);
        }
    }
    else if (bits >= sourceWordLength) {
        return BitRegroupingError.hasDisallowedPadding;
    }
    else if (((accumulator << (resultWordLength - bits)) & maxResultInt) > 0) {
        return BitRegroupingError.requiresDisallowedPadding;
    }
    return result;
};
/* eslint-enable functional/no-let, no-bitwise, functional/no-expression-statements, functional/no-conditional-statements, complexity */
/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`. To prepare another array
 * type for encoding, see {@link regroupBits}.
 *
 * For the reverse, see {@link decodeBech32}.
 *
 * @param base32IntegerArray - the array of 5-bit integers to encode
 */
const encodeBech32 = (base32IntegerArray) => {
    // eslint-disable-next-line functional/no-let
    let result = '';
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statements, no-plusplus
    for (let i = 0; i < base32IntegerArray.length; i++) {
        // eslint-disable-next-line functional/no-expression-statements, @typescript-eslint/no-non-null-assertion
        result += bech32CharacterSet[base32IntegerArray[i]];
    }
    return result;
};
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with {@link isBech32CharacterSet} before calling
 * this method.
 *
 * For the reverse, see {@link encodeBech32}.
 *
 * @param validBech32 - the bech32-encoded string to decode
 */
const decodeBech32 = (validBech32) => {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statements, no-plusplus
    for (let i = 0; i < validBech32.length; i++) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        result.push(bech32CharacterSetIndex[validBech32[i]]);
    }
    return result;
};
const nonBech32Characters = new RegExp(`[^${bech32CharacterSet}]`, 'u');
const base32WordLength = 5;
const base256WordLength = 8;
/**
 * Validate that a string uses only characters from the bech32 character set.
 *
 * @param maybeBech32 - a string to test for valid Bech32 encoding
 */
const isBech32CharacterSet = (maybeBech32) => !nonBech32Characters.test(maybeBech32);
/**
 * Returns an array of the non-Bech32 characters in the provided string; if all
 * characters are valid, an empty array is returned.
 * @param maybeBech32 - the string to test
 */
const extractNonBech32Characters = (maybeBech32) => [
    ...new Set([...maybeBech32].filter((character) => !bech32CharacterSet.includes(character))),
];
var Bech32DecodingError;
(function (Bech32DecodingError) {
    Bech32DecodingError["notBech32CharacterSet"] = "Bech32 decoding error: input contains characters outside of the Bech32 character set.";
})(Bech32DecodingError || (Bech32DecodingError = {}));
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * For the reverse, see {@link binToBech32Padded}.
 *
 * @param bech32Padded - the padded bech32-encoded string to decode
 */
const bech32PaddedToBin = (bech32Padded) => {
    const result = isBech32CharacterSet(bech32Padded)
        ? regroupBits({
            allowPadding: false,
            bin: decodeBech32(bech32Padded),
            resultWordLength: base256WordLength,
            sourceWordLength: base32WordLength,
        })
        : Bech32DecodingError.notBech32CharacterSet;
    return typeof result === 'string' ? result : Uint8Array.from(result);
};
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * For the reverse, see {@link bech32PaddedToBin}.
 *
 * @param bytes - the Uint8Array to bech32 encode
 */
const binToBech32Padded = (bytes) => encodeBech32(regroupBits({
    bin: bytes,
    resultWordLength: base32WordLength,
    sourceWordLength: base256WordLength,
}));

var CashAddressNetworkPrefix;
(function (CashAddressNetworkPrefix) {
    CashAddressNetworkPrefix["mainnet"] = "bitcoincash";
    CashAddressNetworkPrefix["testnet"] = "bchtest";
    CashAddressNetworkPrefix["regtest"] = "bchreg";
})(CashAddressNetworkPrefix || (CashAddressNetworkPrefix = {}));
/**
 * The CashAddress specification standardizes the format of the version byte:
 * - Most significant bit: reserved, must be `0`
 * - next 4 bits: Address Type
 * - 3 least significant bits: Payload Length
 *
 * Two Address Type values are currently standardized:
 * - 0 (`0b0000`): P2PKH
 * - 1 (`0b0001`): P2SH
 *
 * And two are proposed by `CHIP-2022-02-CashTokens`:
 * - 2 (`0b0010`): P2PKH + Token Support
 * - 3 (`0b0011`): P2SH + Token Support
 *
 * The CashAddress specification standardizes expected payload length using
 * {@link CashAddressLengthBits}. Currently, two length bit values are in use by
 * standard CashAddress types:
 * - `0` (`0b000`): 20 bytes (in use by `p2pkh` and `p2sh20`)
 * - `3` (`0b011`): 32 bytes (in use by `p2sh32`)
 */
var CashAddressVersionByte;
(function (CashAddressVersionByte) {
    /**
     * Pay to Public Key Hash (P2PKH): `0b00000000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0000` (P2PKH)
     * - Length bits: `000` (20 bytes)
     */
    CashAddressVersionByte[CashAddressVersionByte["p2pkh"] = 0] = "p2pkh";
    /**
     * 20-byte Pay to Script Hash (P2SH20): `0b00001000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0001` (P2SH)
     * - Length bits: `000` (20 bytes)
     */
    CashAddressVersionByte[CashAddressVersionByte["p2sh20"] = 8] = "p2sh20";
    /**
     * 32-byte Pay to Script Hash (P2SH20): `0b00001000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0001` (P2SH)
     * - Length bits: `011` (32 bytes)
     */
    CashAddressVersionByte[CashAddressVersionByte["p2sh32"] = 11] = "p2sh32";
    /**
     * Pay to Public Key Hash (P2PKH) with token support: `0b00010000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0010` (P2PKH + Tokens)
     * - Length bits: `000` (20 bytes)
     */
    CashAddressVersionByte[CashAddressVersionByte["p2pkhWithTokens"] = 16] = "p2pkhWithTokens";
    /**
     * 20-byte Pay to Script Hash (P2SH20) with token support: `0b00011000`
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0011` (P2SH + Tokens)
     * - Length bits: `000` (20 bytes)
     */
    CashAddressVersionByte[CashAddressVersionByte["p2sh20WithTokens"] = 24] = "p2sh20WithTokens";
    /**
     * 32-byte Pay to Script Hash (P2SH32) with token support: `0b00011011`
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0011` (P2SH + Tokens)
     * - Length bits: `011` (32 bytes)
     */
    CashAddressVersionByte[CashAddressVersionByte["p2sh32WithTokens"] = 27] = "p2sh32WithTokens";
})(CashAddressVersionByte || (CashAddressVersionByte = {}));
/**
 * The address types currently defined in the CashAddress specification. See
 * also: {@link CashAddressVersionByte}.
 */
var CashAddressType;
(function (CashAddressType) {
    /**
     * Pay to Public Key Hash (P2PKH): `0b0000`
     */
    CashAddressType["p2pkh"] = "p2pkh";
    /**
     * Pay to Script Hash (P2SH): `0b0001`
     *
     * Note, this type is used for both {@link CashAddressVersionByte.p2sh20} and
     * {@link CashAddressVersionByte.p2sh32}.
     */
    CashAddressType["p2sh"] = "p2sh";
    /**
     * Pay to Public Key Hash (P2PKH) with token support: `0b0010`
     */
    CashAddressType["p2pkhWithTokens"] = "p2pkhWithTokens";
    /**
     * Pay to Script Hash (P2SH) with token support: `0b0011`
     *
     * Note, this type is used for both
     * {@link CashAddressVersionByte.p2sh20WithTokens} and
     * {@link CashAddressVersionByte.p2sh32WithTokens}.
     */
    CashAddressType["p2shWithTokens"] = "p2shWithTokens";
})(CashAddressType || (CashAddressType = {}));
/**
 * The address type bits currently defined in the CashAddress specification.
 * These map to: {@link CashAddressType}.
 */
var CashAddressTypeBits;
(function (CashAddressTypeBits) {
    /**
     * Pay to Public Key Hash (P2PKH)
     */
    CashAddressTypeBits[CashAddressTypeBits["p2pkh"] = 0] = "p2pkh";
    /**
     * Pay to Script Hash (P2SH)
     */
    CashAddressTypeBits[CashAddressTypeBits["p2sh"] = 1] = "p2sh";
    /**
     * Pay to Public Key Hash (P2PKH) with token support
     */
    CashAddressTypeBits[CashAddressTypeBits["p2pkhWithTokens"] = 2] = "p2pkhWithTokens";
    /**
     * Pay to Script Hash (P2SH) with token support
     */
    CashAddressTypeBits[CashAddressTypeBits["p2shWithTokens"] = 3] = "p2shWithTokens";
})(CashAddressTypeBits || (CashAddressTypeBits = {}));
const cashAddressTypeToTypeBits = {
    [CashAddressType.p2pkh]: CashAddressTypeBits.p2pkh,
    [CashAddressType.p2sh]: CashAddressTypeBits.p2sh,
    [CashAddressType.p2pkhWithTokens]: CashAddressTypeBits.p2pkhWithTokens,
    [CashAddressType.p2shWithTokens]: CashAddressTypeBits.p2shWithTokens,
};
const cashAddressTypeBitsToType = {
    [CashAddressTypeBits.p2pkh]: CashAddressType.p2pkh,
    [CashAddressTypeBits.p2sh]: CashAddressType.p2sh,
    [CashAddressTypeBits.p2pkhWithTokens]: CashAddressType.p2pkhWithTokens,
    [CashAddressTypeBits.p2shWithTokens]: CashAddressType.p2shWithTokens,
};
/* eslint-disable @typescript-eslint/naming-convention */
const cashAddressLengthBitsToLength = {
    0: 20,
    1: 24,
    2: 28,
    3: 32,
    4: 40,
    5: 48,
    6: 56,
    7: 64,
};
const cashAddressLengthToLengthBits = {
    20: 0,
    24: 1,
    28: 2,
    32: 3,
    40: 4,
    48: 5,
    56: 6,
    64: 7,
};
/**
 * Encode a CashAddress version byte for the given address type and payload
 * length. See {@link CashAddressVersionByte} for more information.
 *
 * The `type` parameter must be a number between `0` and `15`, and `bitLength`
 * must be one of the standardized lengths. To use the contents of a variable,
 * cast it to {@link CashAddressType} or
 * {@link CashAddressSupportedLength} respectively,
 * e.g.:
 * ```ts
 * const type = 3 as CashAddressType;
 * const length = 20 as CashAddressSupportedLength;
 * getCashAddressVersionByte(type, length);
 * ```
 *
 * For the reverse, see {@link decodeCashAddressVersionByte}.
 *
 * @param typeBits - The address type bit of the payload being encoded.
 * @param length - The length of the payload being encoded.
 */
const encodeCashAddressVersionByte = (typeBits, length) => 
// eslint-disable-next-line no-bitwise
(typeBits << 3 /* Constants.cashAddressTypeBitsShift */) |
    cashAddressLengthToLengthBits[length];
var CashAddressVersionByteDecodingError;
(function (CashAddressVersionByteDecodingError) {
    CashAddressVersionByteDecodingError["reservedBitSet"] = "Reserved bit is set.";
})(CashAddressVersionByteDecodingError || (CashAddressVersionByteDecodingError = {}));
/**
 * Decode a CashAddress version byte. For a list of known versions, see
 * {@link CashAddressVersionByte}.
 *
 * For the reverse, see {@link encodeCashAddressVersionByte}.
 *
 * @param version - The version byte to decode.
 */
const decodeCashAddressVersionByte = (version) => 
// eslint-disable-next-line no-negated-condition, no-bitwise
(version & 128 /* Constants.cashAddressReservedBitMask */) !== 0
    ? CashAddressVersionByteDecodingError.reservedBitSet
    : {
        length: cashAddressLengthBitsToLength[
        // eslint-disable-next-line no-bitwise
        (version &
            7 /* Constants.cashAddressLengthBits */)],
        typeBits: 
        // eslint-disable-next-line no-bitwise
        (version >>> 3 /* Constants.cashAddressTypeBitsShift */) &
            15 /* Constants.cashAddressTypeBits */,
    };
/**
 * Convert a string into an array of 5-bit numbers, representing the characters
 * in a case-insensitive way.
 *
 * @param prefix - The prefix to mask.
 */
const maskCashAddressPrefix = (prefix) => {
    const result = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let i = 0; i < prefix.length; i++) {
        // eslint-disable-next-line functional/no-expression-statements, no-bitwise, functional/immutable-data
        result.push(prefix.charCodeAt(i) & 31 /* Constants.asciiCaseInsensitiveBits */);
    }
    return result;
};
// prettier-ignore
const bech32GeneratorMostSignificantByte = [0x98, 0x79, 0xf3, 0xae, 0x1e]; // eslint-disable-line @typescript-eslint/no-magic-numbers
// prettier-ignore
const bech32GeneratorRemainingBytes = [0xf2bc8e61, 0xb76d99e2, 0x3e5fb3c4, 0x2eabe2a8, 0x4f43e470]; // eslint-disable-line @typescript-eslint/no-magic-numbers
/**
 * Perform the CashAddress polynomial modulo operation, which is based on the
 * Bech32 polynomial modulo operation, but the returned checksum is 40 bits,
 * rather than 30.
 *
 * A.K.A. `PolyMod`
 *
 * @remarks
 * Notes from C++ implementation:
 * This function will compute what 8 5-bit values to XOR into the last 8 input
 * values, in order to make the checksum 0. These 8 values are packed together
 * in a single 40-bit integer. The higher bits correspond to earlier values.
 *
 * The input is interpreted as a list of coefficients of a polynomial over F
 * = GF(32), with an implicit 1 in front. If the input is [v0,v1,v2,v3,v4],
 * that polynomial is v(x) = 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4.
 * The implicit 1 guarantees that [v0,v1,v2,...] has a distinct checksum
 * from [0,v0,v1,v2,...].
 *
 * The output is a 40-bit integer whose 5-bit groups are the coefficients of
 * the remainder of v(x) mod g(x), where g(x) is the cashaddr generator, x^8
 * + [19]*x^7 + [3]*x^6 + [25]*x^5 + [11]*x^4 + [25]*x^3 + [3]*x^2 + [19]*x
 * + [1]. g(x) is chosen in such a way that the resulting code is a BCH
 * code, guaranteeing detection of up to 4 errors within a window of 1025
 * characters. Among the various possible BCH codes, one was selected to in
 * fact guarantee detection of up to 5 errors within a window of 160
 * characters and 6 errors within a window of 126 characters. In addition,
 * the code guarantee the detection of a burst of up to 8 errors.
 *
 * Note that the coefficients are elements of GF(32), here represented as
 * decimal numbers between []. In this finite field, addition is just XOR of
 * the corresponding numbers. For example, [27] + [13] = [27 ^ 13] = [22].
 * Multiplication is more complicated, and requires treating the bits of
 * values themselves as coefficients of a polynomial over a smaller field,
 * GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example,
 * [5] * [26] = (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 +
 * a^3 + a) = a^6 + a^5 + a^4 + a = a^3 + 1 (mod a^5 + a^3 + 1) = [9].
 *
 * During the course of the loop below, `c` contains the bit-packed
 * coefficients of the polynomial constructed from just the values of v that
 * were processed so far, mod g(x). In the above example, `c` initially
 * corresponds to 1 mod (x), and after processing 2 inputs of v, it
 * corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the
 * starting value for `c`.
 *
 * @param v - Array of 5-bit integers over which the checksum is to be computed.
 */
// Derived from the `bitcore-lib-cash` implementation (does not require BigInt): https://github.com/bitpay/bitcore
const cashAddressPolynomialModulo = (v) => {
    /* eslint-disable functional/no-let, functional/no-loop-statements, functional/no-expression-statements, no-bitwise, @typescript-eslint/no-magic-numbers */
    let mostSignificantByte = 0;
    let lowerBytes = 1;
    let c = 0;
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, no-plusplus
    for (let j = 0; j < v.length; j++) {
        c = mostSignificantByte >>> 3;
        mostSignificantByte &= 0x07;
        mostSignificantByte <<= 5;
        mostSignificantByte |= lowerBytes >>> 27;
        lowerBytes &= 0x07ffffff;
        lowerBytes <<= 5;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        lowerBytes ^= v[j];
        // eslint-disable-next-line no-plusplus
        for (let i = 0; i < bech32GeneratorMostSignificantByte.length; ++i) {
            // eslint-disable-next-line functional/no-conditional-statements
            if (c & (1 << i)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                mostSignificantByte ^= bech32GeneratorMostSignificantByte[i];
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                lowerBytes ^= bech32GeneratorRemainingBytes[i];
            }
        }
    }
    lowerBytes ^= 1;
    // eslint-disable-next-line functional/no-conditional-statements
    if (lowerBytes < 0) {
        lowerBytes ^= 1 << 31;
        lowerBytes += (1 << 30) * 2;
    }
    return mostSignificantByte * (1 << 30) * 4 + lowerBytes;
    /* eslint-enable functional/no-let, functional/no-loop-statements, functional/no-expression-statements, no-bitwise, @typescript-eslint/no-magic-numbers */
};
/**
 * Convert the checksum returned by {@link cashAddressPolynomialModulo} to an
 * array of 5-bit positive integers that can be Base32 encoded.
 * @param checksum - A 40 bit checksum returned by
 * {@link cashAddressPolynomialModulo}.
 */
const cashAddressChecksumToUint5Array = (checksum) => {
    const result = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let i = 0; i < 8 /* Constants.base256WordLength */; ++i) {
        // eslint-disable-next-line functional/no-expression-statements, no-bitwise, @typescript-eslint/no-magic-numbers, functional/immutable-data
        result.push(checksum & 31);
        // eslint-disable-next-line functional/no-expression-statements, @typescript-eslint/no-magic-numbers, no-param-reassign
        checksum /= 32;
    }
    // eslint-disable-next-line functional/immutable-data
    return result.reverse();
};
var CashAddressFormatEncodingError;
(function (CashAddressFormatEncodingError) {
    CashAddressFormatEncodingError["excessiveVersion"] = "CashAddress format encoding error: version must be 255 or less.";
})(CashAddressFormatEncodingError || (CashAddressFormatEncodingError = {}));
var CashAddressEncodingError;
(function (CashAddressEncodingError) {
    CashAddressEncodingError["noTypeBitsValueStandardizedForP2pk"] = "CashAddress encoding error: no CashAddress type bit has been standardized for P2PK locking bytecode.";
    CashAddressEncodingError["unsupportedPayloadLength"] = "CashAddress encoding error: a payload of this length can not be encoded as a valid CashAddress.";
    CashAddressEncodingError["unknownLockingBytecodeType"] = "CashAddress encoding error: unknown locking bytecode type.";
})(CashAddressEncodingError || (CashAddressEncodingError = {}));
/**
 * Encode a payload as a CashAddress-like string using the CashAddress format.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * For the reverse, see {@link decodeCashAddressFormat}.
 *
 * To encode a standard CashAddress, use {@link encodeCashAddress}.
 */
const encodeCashAddressFormat = ({ payload, prefix, throwErrors = true, version, }) => {
    const checksum40BitPlaceholder = [0, 0, 0, 0, 0, 0, 0, 0];
    if (version > 255 /* Constants.maximumCashAddressFormatVersion */) {
        return formatError(CashAddressFormatEncodingError.excessiveVersion, `Version: ${version}.`, throwErrors);
    }
    const payloadContents = regroupBits({
        bin: Uint8Array.from([version, ...payload]),
        resultWordLength: 5 /* Constants.base32WordLength */,
        sourceWordLength: 8 /* Constants.base256WordLength */,
    });
    const checksumContents = [
        ...maskCashAddressPrefix(prefix),
        0 /* Constants.payloadSeparator */,
        ...payloadContents,
        ...checksum40BitPlaceholder,
    ];
    const checksum = cashAddressPolynomialModulo(checksumContents);
    const encoded = [
        ...payloadContents,
        ...cashAddressChecksumToUint5Array(checksum),
    ];
    const address = `${prefix}:${encodeBech32(encoded)}`;
    return { address };
};
const isValidCashAddressPayloadLength = (length) => cashAddressLengthToLengthBits[length] !== undefined;
/**
 * Encode a payload as a CashAddress. This function is similar to
 * {@link encodeCashAddress} but supports non-standard `prefix`es and `type`s.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * For other address standards that closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * {@link encodeCashAddressFormat}.
 *
 * For the reverse, see {@link decodeCashAddressNonStandard}.
 */
const encodeCashAddressNonStandard = ({ payload, prefix, throwErrors = true, typeBits, }) => {
    const { length } = payload;
    if (!isValidCashAddressPayloadLength(length)) {
        return formatError(CashAddressEncodingError.unsupportedPayloadLength, `Payload length: ${length}.`, throwErrors);
    }
    return encodeCashAddressFormat({
        payload,
        prefix,
        throwErrors,
        version: encodeCashAddressVersionByte(typeBits, length),
    });
};
/**
 * Encode a payload as a CashAddress.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * To encode a CashAddress with a custom/unknown prefix or type bit, see
 * {@link encodeCashAddressNonStandard}. For other address standards that
 * closely follow the CashAddress specification (but have alternative version
 * byte requirements), use {@link encodeCashAddressFormat}.
 *
 * To decode a CashAddress, use {@link decodeCashAddress}.
 *
 * @returns If `throwErrors` is `true`, the CashAddress as a `string`. If
 * `throwErrors` is `false`, a {@link CashAddressResult} on successful encoding
 * or an error message as a `string`.
 */
const encodeCashAddress = ({ payload, prefix = 'bitcoincash', throwErrors = true, type, }) => encodeCashAddressNonStandard({
    payload,
    prefix,
    throwErrors,
    typeBits: cashAddressTypeToTypeBits[type],
});
var CashAddressDecodingError;
(function (CashAddressDecodingError) {
    CashAddressDecodingError["improperPadding"] = "CashAddress decoding error: the payload is improperly padded.";
    CashAddressDecodingError["invalidCharacters"] = "CashAddress decoding error: the payload contains unexpected characters.";
    CashAddressDecodingError["invalidChecksum"] = "CashAddress decoding error: invalid checksum - please review the address for errors.";
    CashAddressDecodingError["invalidFormat"] = "CashAddress decoding error: CashAddresses should be of the form \"prefix:payload\".";
    CashAddressDecodingError["mismatchedPayloadLength"] = "CashAddress decoding error: mismatched payload length for specified address version.";
    CashAddressDecodingError["reservedBit"] = "CashAddress decoding error: unknown CashAddress version, reserved bit set.";
    CashAddressDecodingError["unknownAddressType"] = "CashAddress decoding error: unknown CashAddress type.";
})(CashAddressDecodingError || (CashAddressDecodingError = {}));
/**
 * Decode and validate a string using the CashAddress format. This is more
 * lenient than {@link decodeCashAddress}, which also validates the contents of
 * the version byte.
 *
 * Note, this method requires `address` to include a network prefix. To
 * decode a string with an unknown prefix, try
 * {@link decodeCashAddressFormatWithoutPrefix}.
 *
 * For the reverse, see {@link encodeCashAddressFormat}.
 *
 * @param address - The CashAddress-like string to decode.
 */
// eslint-disable-next-line complexity
const decodeCashAddressFormat = (address) => {
    const parts = address.toLowerCase().split(':');
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
        return formatError(CashAddressDecodingError.invalidFormat, `Provided address: "${address}".`);
    }
    const [prefix, payload] = parts;
    if (!isBech32CharacterSet(payload)) {
        return formatError(CashAddressDecodingError.invalidCharacters, `Invalid characters: ${extractNonBech32Characters(payload).join(', ')}.`);
    }
    const decodedPayload = decodeBech32(payload);
    const polynomial = [
        ...maskCashAddressPrefix(prefix),
        0 /* Constants.payloadSeparator */,
        ...decodedPayload,
    ];
    if (cashAddressPolynomialModulo(polynomial) !== 0) {
        return CashAddressDecodingError.invalidChecksum;
    }
    const payloadContents = regroupBits({
        allowPadding: false,
        bin: decodedPayload.slice(0, -8),
        resultWordLength: 8 /* Constants.base256WordLength */,
        sourceWordLength: 5 /* Constants.base32WordLength */,
    });
    if (typeof payloadContents === 'string') {
        return formatError(CashAddressDecodingError.improperPadding, payloadContents);
    }
    const [version, ...contents] = payloadContents;
    const result = Uint8Array.from(contents);
    return { payload: result, prefix, version };
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * This function is similar to {@link decodeCashAddress} but supports
 * non-standard `type`s.
 *
 * For other address-like standards that closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * {@link decodeCashAddressFormat}.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * {@link decodeCashAddressFormatWithoutPrefix}.
 *
 * For the reverse, see {@link encodeCashAddressNonStandard}.
 *
 * @param address - The CashAddress to decode.
 */
const decodeCashAddressNonStandard = (address) => {
    const decoded = decodeCashAddressFormat(address);
    if (typeof decoded === 'string') {
        return decoded;
    }
    const info = decodeCashAddressVersionByte(decoded.version);
    if (info === CashAddressVersionByteDecodingError.reservedBitSet) {
        return formatError(CashAddressDecodingError.reservedBit);
    }
    if (decoded.payload.length !== info.length) {
        return formatError(CashAddressDecodingError.mismatchedPayloadLength, `Version byte indicated a byte length of ${info.length}, but the payload is ${decoded.payload.length} bytes.`);
    }
    return {
        payload: decoded.payload,
        prefix: decoded.prefix,
        typeBits: info.typeBits,
    };
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * To decode CashAddresses with non-standard `type`s,
 * see {@link decodeCashAddressNonStandard}.
 *
 * For other address-like standards that closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * {@link decodeCashAddressFormat}.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * {@link decodeCashAddressFormatWithoutPrefix}.
 *
 * To encode a CashAddress, use {@link encodeCashAddress}.
 *
 * @param address - The CashAddress to decode.
 */
const decodeCashAddress = (address) => {
    const decoded = decodeCashAddressNonStandard(address);
    if (typeof decoded === 'string') {
        return decoded;
    }
    const type = cashAddressTypeBitsToType[decoded.typeBits];
    if (type === undefined) {
        return formatError(CashAddressDecodingError.unknownAddressType, `Type bit value: ${decoded.typeBits}.`);
    }
    return {
        payload: decoded.payload,
        prefix: decoded.prefix,
        type,
    };
};
/**
 * Attempt to decode and validate a CashAddress against a list of possible
 * prefixes. If the correct prefix is known, use {@link decodeCashAddress}.
 *
 * @param address - The CashAddress to decode.
 * @param possiblePrefixes - The network prefixes to try.
 */
// decodeCashAddressWithoutPrefix
const decodeCashAddressFormatWithoutPrefix = (address, possiblePrefixes = [
    CashAddressNetworkPrefix.mainnet,
    CashAddressNetworkPrefix.testnet,
    CashAddressNetworkPrefix.regtest,
]) => {
    // eslint-disable-next-line functional/no-loop-statements
    for (const prefix of possiblePrefixes) {
        const attempt = decodeCashAddressFormat(`${prefix}:${address}`);
        if (attempt !== CashAddressDecodingError.invalidChecksum) {
            return attempt;
        }
    }
    return CashAddressDecodingError.invalidChecksum;
};
/**
 * Convert a CashAddress polynomial to CashAddress string format.
 *
 * @remarks
 * CashAddress polynomials take the form:
 *
 * `[lowest 5 bits of each prefix character] 0 [payload + checksum]`
 *
 * This method remaps the 5-bit integers in the prefix location to the matching
 * ASCII lowercase characters, replaces the separator with `:`, and then Bech32
 * encodes the remaining payload and checksum.
 *
 * @param polynomial - An array of 5-bit integers representing the terms of a
 * CashAddress polynomial.
 */
const cashAddressPolynomialToCashAddress = (polynomial) => {
    const separatorPosition = polynomial.indexOf(0);
    const prefix = polynomial
        .slice(0, separatorPosition)
        .map((integer) => String.fromCharCode(96 /* Constants.asciiLowerCaseStart */ + integer))
        .join('');
    const contents = encodeBech32(polynomial.slice(separatorPosition + 1));
    return `${prefix}:${contents}`;
};
var CashAddressFormatCorrectionError;
(function (CashAddressFormatCorrectionError) {
    CashAddressFormatCorrectionError["tooManyErrors"] = "CashAddress format correction error: this address cannot be corrected as it contains more than 2 errors.";
})(CashAddressFormatCorrectionError || (CashAddressFormatCorrectionError = {}));
/**
 * Attempt to correct up to 2 errors in a CashAddress-formatted string. The
 * string must include the prefix and only contain Bech32 characters.
 *
 * ## **CAUTION: improper use of this function can lead to lost funds.**
 *
 * Using error correction of CashAddress-like formats degrades error detection,
 * i.e. if the payload contains more than 2 errors, it is possible that error
 * correction will "correct" the payload to a plausible but incorrect payload.
 *
 * For applications which proceed to take irreversible actions – like sending a
 * payment – **naive usage of CashAddress Format error correction can lead to
 * vulnerabilities and lost funds**.
 *
 * It is strongly advised that this method only be used in fail-safe
 * applications (e.g. automatic correction of CashAddress-formatted private key
 * material during wallet recovery) or under explicit user control (e.g. "The
 * address you entered is invalid, please review the highlighted characters and
 * try again.").
 *
 * Only 2 substitution errors can be corrected (or a single swap) – deletions
 * and insertions (errors that shift many other characters and change the
 * length of the payload) can never be safely corrected and will produce an
 * error.
 *
 * Errors can be corrected in both the prefix and the payload, but attempting to
 * correct errors in the prefix prior to this method can improve results, e.g.
 * for `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x`, the string
 * `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can be corrected, while
 * `typo:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can not.
 *
 * @param address - The address or formatted data to correct.
 */
// Derived from: https://github.com/deadalnix/cashaddressed
// eslint-disable-next-line complexity
const attemptCashAddressFormatErrorCorrection = (address) => {
    const parts = address.toLowerCase().split(':');
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
        return CashAddressDecodingError.invalidFormat;
    }
    const [prefix, payload] = parts;
    if (!isBech32CharacterSet(payload)) {
        return formatError(CashAddressDecodingError.invalidCharacters, `Invalid characters: ${extractNonBech32Characters(payload).join(', ')}.`);
    }
    const decodedPayload = decodeBech32(payload);
    const polynomial = [...maskCashAddressPrefix(prefix), 0, ...decodedPayload];
    const originalChecksum = cashAddressPolynomialModulo(polynomial);
    if (originalChecksum === 0) {
        return {
            address: cashAddressPolynomialToCashAddress(polynomial),
            corrections: [],
        };
    }
    const syndromes = {};
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let term = 0; term < polynomial.length; term++) {
        // eslint-disable-next-line functional/no-loop-statements
        for (
        // eslint-disable-next-line functional/no-let
        let errorVector = 1; errorVector < 32 /* Constants.finiteFieldOrder */; 
        // eslint-disable-next-line no-plusplus
        errorVector++) {
            // eslint-disable-next-line functional/no-expression-statements, no-bitwise, functional/immutable-data
            polynomial[term] ^= errorVector;
            const correct = cashAddressPolynomialModulo(polynomial);
            if (correct === 0) {
                return {
                    address: cashAddressPolynomialToCashAddress(polynomial),
                    corrections: [term],
                };
            }
            // eslint-disable-next-line no-bitwise
            const s0 = (BigInt(correct) ^ BigInt(originalChecksum)).toString();
            // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
            syndromes[s0] = term * 32 /* Constants.finiteFieldOrder */ + errorVector;
            // eslint-disable-next-line functional/no-expression-statements, no-bitwise, functional/immutable-data
            polynomial[term] ^= errorVector;
        }
    }
    // eslint-disable-next-line functional/no-loop-statements
    for (const [s0, pe] of Object.entries(syndromes)) {
        // eslint-disable-next-line no-bitwise
        const s1Location = (BigInt(s0) ^ BigInt(originalChecksum)).toString();
        const s1 = syndromes[s1Location];
        if (s1 !== undefined) {
            const correctionIndex1 = Math.trunc(pe / 32 /* Constants.finiteFieldOrder */);
            const correctionIndex2 = Math.trunc(s1 / 32 /* Constants.finiteFieldOrder */);
            // eslint-disable-next-line functional/no-expression-statements, no-bitwise, functional/immutable-data
            polynomial[correctionIndex1] ^= pe % 32 /* Constants.finiteFieldOrder */;
            // eslint-disable-next-line functional/no-expression-statements, no-bitwise, functional/immutable-data
            polynomial[correctionIndex2] ^= s1 % 32 /* Constants.finiteFieldOrder */;
            return {
                address: cashAddressPolynomialToCashAddress(polynomial),
                corrections: [correctionIndex1, correctionIndex2].sort((a, b) => a - b),
            };
        }
    }
    return CashAddressFormatCorrectionError.tooManyErrors;
};

/**
 * The most common address types used on Bitcoin Cash and similar networks. Each
 * address type represents a commonly used locking bytecode pattern.
 *
 * @remarks
 * Addresses are strings that encode information about the network and
 * `lockingBytecode` to which a transaction output can pay.
 *
 * Several address formats exist – `Base58Address` was the format used by the
 * original satoshi client, and is still in use on several active chains (see
 * {@link encodeBase58Address}). On Bitcoin Cash, the `CashAddress` standard is
 * most common (See {@link encodeCashAddress}).
 */
var LockingBytecodeType;
(function (LockingBytecodeType) {
    /**
     * Pay to Public Key (P2PK). This address type is uncommon, and primarily
     * occurs in early blocks because the original satoshi implementation mined
     * rewards to P2PK addresses.
     *
     * There are no standardized address formats for representing a P2PK address.
     * Instead, most applications use the `AddressType.p2pkh` format.
     */
    LockingBytecodeType["p2pk"] = "P2PK";
    /**
     * Pay to Public Key Hash (P2PKH). The most common address type. P2PKH
     * addresses lock funds using a single private key.
     */
    LockingBytecodeType["p2pkh"] = "P2PKH";
    /**
     * 20-byte Pay to Script Hash (P2SH20). An address type that locks funds to
     * the 20-byte hash of a script provided in the spending transaction. See
     * BIPs 13 and 16 for details.
     */
    LockingBytecodeType["p2sh20"] = "P2SH20";
    /**
     * 32-byte Pay to Script Hash (P2SH32). An address type that locks funds to
     * the 32-byte hash of a script provided in the spending transaction.
     */
    LockingBytecodeType["p2sh32"] = "P2SH32";
})(LockingBytecodeType || (LockingBytecodeType = {}));
const isPayToPublicKeyUncompressed = (lockingBytecode) => lockingBytecode.length === 67 /* PayToPublicKeyUncompressed.length */ &&
    lockingBytecode[0] === 65 /* Opcodes.OP_PUSHBYTES_65 */ &&
    lockingBytecode[66 /* PayToPublicKeyUncompressed.lastElement */] ===
        172 /* Opcodes.OP_CHECKSIG */;
const isPayToPublicKeyCompressed = (lockingBytecode) => lockingBytecode.length === 35 /* PayToPublicKeyCompressed.length */ &&
    lockingBytecode[0] === 33 /* Opcodes.OP_PUSHBYTES_33 */ &&
    lockingBytecode[34 /* PayToPublicKeyCompressed.lastElement */] === 172 /* Opcodes.OP_CHECKSIG */;
const isPayToPublicKey = (lockingBytecode) => isPayToPublicKeyCompressed(lockingBytecode) ||
    isPayToPublicKeyUncompressed(lockingBytecode);
// eslint-disable-next-line complexity
const isPayToPublicKeyHash = (lockingBytecode) => lockingBytecode.length === 25 /* PayToPublicKeyHash.length */ &&
    lockingBytecode[0] === 118 /* Opcodes.OP_DUP */ &&
    lockingBytecode[1] === 169 /* Opcodes.OP_HASH160 */ &&
    lockingBytecode[2] === 20 /* Opcodes.OP_PUSHBYTES_20 */ &&
    lockingBytecode[23] === 136 /* Opcodes.OP_EQUALVERIFY */ &&
    lockingBytecode[24] === 172 /* Opcodes.OP_CHECKSIG */;
const isPayToScriptHash20 = (lockingBytecode) => lockingBytecode.length === 23 /* PayToScriptHash20.length */ &&
    lockingBytecode[0] === 169 /* Opcodes.OP_HASH160 */ &&
    lockingBytecode[1] === 20 /* Opcodes.OP_PUSHBYTES_20 */ &&
    lockingBytecode[22 /* PayToScriptHash20.lastElement */] === 135 /* Opcodes.OP_EQUAL */;
const isPayToScriptHash32 = (lockingBytecode) => lockingBytecode.length === 35 /* PayToScriptHash32.length */ &&
    lockingBytecode[0] === 170 /* Opcodes.OP_HASH256 */ &&
    lockingBytecode[1] === 32 /* Opcodes.OP_PUSHBYTES_32 */ &&
    lockingBytecode[34 /* PayToScriptHash32.lastElement */] === 135 /* Opcodes.OP_EQUAL */;
/**
 * Attempt to match a lockingBytecode to a standard address type for use in
 * address encoding. (See {@link LockingBytecodeType} for details.)
 *
 * For a locking bytecode matching the Pay to Public Key Hash (P2PKH) pattern,
 * the returned `type` is {@link LockingBytecodeType.p2pkh} and `payload` is the
 * `HASH160` of the public key.
 *
 * For a locking bytecode matching the 20-byte Pay to Script Hash (P2SH20)
 * pattern, the returned `type` is {@link LockingBytecodeType.p2sh20} and
 * `payload` is the `HASH160` of the redeeming bytecode, A.K.A. "redeem
 * script hash".
 *
 * For a locking bytecode matching the Pay to Public Key (P2PK) pattern, the
 * returned `type` is {@link LockingBytecodeType.p2pk} and `payload` is the full
 * public key.
 *
 * Any other locking bytecode will return a `type` of
 * {@link LockingBytecodeType.unknown} and a payload of the
 * unmodified `bytecode`.
 *
 * @param bytecode - the locking bytecode to match
 */
// eslint-disable-next-line complexity
const lockingBytecodeToAddressContents = (bytecode) => {
    if (isPayToPublicKeyHash(bytecode)) {
        return {
            payload: bytecode.slice(3 /* AddressPayload.p2pkhStart */, 23 /* AddressPayload.p2pkhEnd */),
            type: LockingBytecodeType.p2pkh,
        };
    }
    if (isPayToScriptHash20(bytecode)) {
        return {
            payload: bytecode.slice(2 /* AddressPayload.p2sh20Start */, 22 /* AddressPayload.p2sh20End */),
            type: LockingBytecodeType.p2sh20,
        };
    }
    if (isPayToScriptHash32(bytecode)) {
        return {
            payload: bytecode.slice(2 /* AddressPayload.p2sh32Start */, 34 /* AddressPayload.p2sh32End */),
            type: LockingBytecodeType.p2sh32,
        };
    }
    if (isPayToPublicKeyUncompressed(bytecode)) {
        return {
            payload: bytecode.slice(1 /* AddressPayload.p2pkUncompressedStart */, 66 /* AddressPayload.p2pkUncompressedEnd */),
            type: LockingBytecodeType.p2pk,
        };
    }
    if (isPayToPublicKeyCompressed(bytecode)) {
        return {
            payload: bytecode.slice(1 /* AddressPayload.p2pkCompressedStart */, 34 /* AddressPayload.p2pkCompressedEnd */),
            type: LockingBytecodeType.p2pk,
        };
    }
    return { payload: bytecode.slice(), type: 'unknown' };
};
/**
 * Given the 20-byte {@link hash160} of a compressed public key, return a P2PKH
 * locking bytecode:
 * `OP_DUP OP_HASH160 OP_PUSHBYTES_20 publicKeyHash OP_EQUALVERIFY OP_CHECKSIG`.
 *
 * This method does not validate `publicKeyHash` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param publicKeyHash - the 20-byte hash of the compressed public key
 * @returns
 */
const encodeLockingBytecodeP2pkh = (publicKeyHash) => Uint8Array.from([
    118 /* Opcodes.OP_DUP */,
    169 /* Opcodes.OP_HASH160 */,
    20 /* Opcodes.OP_PUSHBYTES_20 */,
    ...publicKeyHash,
    136 /* Opcodes.OP_EQUALVERIFY */,
    172 /* Opcodes.OP_CHECKSIG */,
]);
/**
 * Given the 20-byte {@link hash160} of a P2SH20 redeem bytecode, encode a
 * P2SH20 locking bytecode:
 * `OP_HASH160 OP_PUSHBYTES_20 redeemBytecodeHash OP_EQUAL`.
 *
 * This method does not validate `p2sh20Hash` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param p2sh20Hash - the 20-byte, p2sh20 redeem bytecode hash
 */
const encodeLockingBytecodeP2sh20 = (p2sh20Hash) => Uint8Array.from([
    169 /* Opcodes.OP_HASH160 */,
    20 /* Opcodes.OP_PUSHBYTES_20 */,
    ...p2sh20Hash,
    135 /* Opcodes.OP_EQUAL */,
]);
/**
 * Given the 32-byte {@link hash256} of a P2SH32 redeem bytecode, encode a
 * P2SH32 locking bytecode:
 * `OP_HASH256 OP_PUSHBYTES_32 redeemBytecodeHash OP_EQUAL`.
 *
 * This method does not validate `p2sh32Hash` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param p2sh32Hash - the 32-byte, p2sh32 redeem bytecode hash
 */
const encodeLockingBytecodeP2sh32 = (p2sh32Hash) => Uint8Array.from([
    170 /* Opcodes.OP_HASH256 */,
    32 /* Opcodes.OP_PUSHBYTES_32 */,
    ...p2sh32Hash,
    135 /* Opcodes.OP_EQUAL */,
]);
/**
 * Given a 33-byte compressed or 65-byte uncompressed public key, encode a P2PK
 * locking bytecode: `OP_PUSHBYTES_33 publicKey OP_CHECKSIG` or
 * `OP_PUSHBYTES_65 publicKey OP_CHECKSIG`.
 *
 * This method does not validate `publicKey` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param publicKey - the 33-byte or 65-byte public key
 */
const encodeLockingBytecodeP2pk = (publicKey) => publicKey.length === 33 /* AddressPayload.compressedPublicKeyLength */
    ? Uint8Array.from([
        33 /* Opcodes.OP_PUSHBYTES_33 */,
        ...publicKey,
        172 /* Opcodes.OP_CHECKSIG */,
    ])
    : Uint8Array.from([
        65 /* Opcodes.OP_PUSHBYTES_65 */,
        ...publicKey,
        172 /* Opcodes.OP_CHECKSIG */,
    ]);
/**
 * Get the locking bytecode for a {@link KnownAddressTypeContents}. See
 * {@link lockingBytecodeToAddressContents} for details.
 *
 * @param addressContents - the `AddressContents` to encode
 */
const addressContentsToLockingBytecode = ({ payload, type, }) => {
    if (type === LockingBytecodeType.p2pkh) {
        return encodeLockingBytecodeP2pkh(payload);
    }
    if (type === LockingBytecodeType.p2sh20) {
        return encodeLockingBytecodeP2sh20(payload);
    }
    if (type === LockingBytecodeType.p2sh32) {
        return encodeLockingBytecodeP2sh32(payload);
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (type === LockingBytecodeType.p2pk) {
        return encodeLockingBytecodeP2pk(payload);
    }
    return unknownValue(type, `Unrecognized addressContents type:`);
};
/**
 * Encode a locking bytecode as a CashAddress.
 *
 * If `bytecode` matches a standard pattern, it is encoded using the proper
 * address type and returned as a {@link CashAddressResult}.
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), an error message is returned as a `string`.
 *
 * For the reverse, see {@link cashAddressToLockingBytecode}.
 *
 * Due to the high likelihood of runtime errors in a variety of use cases (e.g.
 * attempting to convert P2PK or arbitrary data outputs to CashAddresses for
 * display in a transaction viewer or block explorer), this function returns
 * encoding errors in a type-safe way (as a `string`) rather than via thrown
 * `Error` objects.
 *
 * For applications in which the input to `lockingBytecodeToCashAddress` is
 * trusted (e.g. the application is encoding an address for self-generated
 * locking bytecode), consider using `assertSuccess` to simplify error handling:
 *
 * ```ts
 * import {
 *   assertSuccess,
 *   lockingBytecodeToCashAddress
 * } from '@bitauth/libauth';
 * import { lockingBytecode, useTheAddress } from './my/app.js';
 *
 * const { address } = assertSuccess(
 *   lockingBytecodeToCashAddress(lockingBytecode)
 * );
 *
 * useTheAddress(address);
 * ```
 *
 * @param bytecode - the locking bytecode to encode
 * @param prefix - the network prefix to use, e.g. `bitcoincash`, `bchtest`, or
 * `bchreg`, defaults to `bitcoincash`
 * @param tokenSupport - If `true`, the address will indicate that the receiver
 * accepts CashTokens; defaults to `false`.
 */
// eslint-disable-next-line complexity
const lockingBytecodeToCashAddress = ({ prefix = 'bitcoincash', bytecode, tokenSupport = false, }) => {
    const { payload, type } = lockingBytecodeToAddressContents(bytecode);
    if (type === LockingBytecodeType.p2pkh) {
        return tokenSupport
            ? encodeCashAddress({
                payload,
                prefix,
                throwErrors: false,
                type: CashAddressType.p2pkhWithTokens,
            })
            : encodeCashAddress({
                payload,
                prefix,
                throwErrors: false,
                type: CashAddressType.p2pkh,
            });
    }
    if (type === LockingBytecodeType.p2sh20 ||
        type === LockingBytecodeType.p2sh32) {
        return tokenSupport
            ? encodeCashAddress({
                payload,
                prefix,
                throwErrors: false,
                type: CashAddressType.p2shWithTokens,
            })
            : encodeCashAddress({
                payload,
                prefix,
                throwErrors: false,
                type: CashAddressType.p2sh,
            });
    }
    if (type === 'P2PK') {
        return CashAddressEncodingError.noTypeBitsValueStandardizedForP2pk;
    }
    return CashAddressEncodingError.unknownLockingBytecodeType;
};
/**
 * Convert a CashAddress to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network prefix. If an error
 * occurs, an error message is returned as a string.
 *
 * For the reverse, see {@link lockingBytecodeToCashAddress}.
 *
 * @param address - the CashAddress to convert
 */
// eslint-disable-next-line complexity
const cashAddressToLockingBytecode = (address) => {
    const decoded = decodeCashAddress(address);
    if (typeof decoded === 'string')
        return decoded;
    if (decoded.type === CashAddressType.p2pkh ||
        decoded.type === CashAddressType.p2pkhWithTokens) {
        return {
            bytecode: addressContentsToLockingBytecode({
                payload: decoded.payload,
                type: LockingBytecodeType.p2pkh,
            }),
            prefix: decoded.prefix,
            tokenSupport: decoded.type === CashAddressType.p2pkhWithTokens,
        };
    }
    if (decoded.type === CashAddressType.p2sh ||
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        decoded.type === CashAddressType.p2shWithTokens) {
        return {
            bytecode: addressContentsToLockingBytecode({
                payload: decoded.payload,
                type: decoded.payload.length === 32 /* AddressPayload.p2sh32Length */
                    ? LockingBytecodeType.p2sh32
                    : LockingBytecodeType.p2sh20,
            }),
            prefix: decoded.prefix,
            tokenSupport: decoded.type === CashAddressType.p2shWithTokens,
        };
    }
    /* c8 ignore next 2 */
    return unknownValue(decoded.type);
};
/**
 * Encode a locking bytecode as a Base58Address for a given network.
 *
 * If `bytecode` matches a standard pattern, it is encoded using the proper
 * address type and returned as a valid Base58Address (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting {@link AddressContents} is returned.
 *
 * For the reverse, see {@link base58AddressToLockingBytecode}.
 *
 * Note, Base58Addresses cannot accept tokens; to accept tokens,
 * use {@link lockingBytecodeToCashAddress} with `tokenSupport` set
 * to `true`.
 *
 * @param bytecode - the locking bytecode to encode
 * @param network - the network for which to encode the address (`mainnet`,
 * `testnet`, or 'copayBCH'), defaults to `mainnet`
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
const lockingBytecodeToBase58Address = (bytecode, network = 'mainnet', sha256$1 = sha256) => {
    const contents = lockingBytecodeToAddressContents(bytecode);
    if (contents.type === LockingBytecodeType.p2pkh) {
        return encodeBase58AddressFormat({
            copayBCH: Base58AddressFormatVersion.p2pkhCopayBCH,
            mainnet: Base58AddressFormatVersion.p2pkh,
            testnet: Base58AddressFormatVersion.p2pkhTestnet,
        }[network], contents.payload, sha256$1);
    }
    if (contents.type === LockingBytecodeType.p2sh20) {
        return encodeBase58AddressFormat({
            copayBCH: Base58AddressFormatVersion.p2sh20CopayBCH,
            mainnet: Base58AddressFormatVersion.p2sh20,
            testnet: Base58AddressFormatVersion.p2sh20Testnet,
        }[network], contents.payload, sha256$1);
    }
    return contents;
};
/**
 * Convert a Base58Address to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network version. If an error
 * occurs, an error message is returned as a string.
 *
 * For the reverse, see {@link lockingBytecodeToBase58Address}.
 *
 * @param address - the CashAddress to convert
 */
const base58AddressToLockingBytecode = (address, sha256$1 = sha256) => {
    const decoded = decodeBase58Address(address, sha256$1);
    if (typeof decoded === 'string')
        return decoded;
    return {
        bytecode: addressContentsToLockingBytecode({
            payload: decoded.payload,
            type: [
                Base58AddressFormatVersion.p2pkh,
                Base58AddressFormatVersion.p2pkhCopayBCH,
                Base58AddressFormatVersion.p2pkhTestnet,
            ].includes(decoded.version)
                ? LockingBytecodeType.p2pkh
                : LockingBytecodeType.p2sh20,
        }),
        version: decoded.version,
    };
};

var ReadBytesError;
(function (ReadBytesError) {
    ReadBytesError["insufficientLength"] = "Error reading bytes: insufficient length.";
})(ReadBytesError || (ReadBytesError = {}));
/**
 * Returns a function that reads the requested number of bytes from a
 * {@link ReadPosition}, returning either an error message (as a string) or an
 * object containing the `Uint8Array` and the next {@link ReadPosition}.
 *
 * @param length - the number of bytes to read
 */
const readBytes = (length) => (
/**
 * the {@link ReadPosition} at which to start reading the bytes.
 */
position) => {
    const nextPosition = {
        bin: position.bin,
        index: position.index + length,
    };
    const result = position.bin.slice(position.index, nextPosition.index);
    if (result.length !== length) {
        return formatError(ReadBytesError.insufficientLength, `Bytes requested: ${length}; remaining bytes: ${result.length}`);
    }
    return { position: nextPosition, result };
};
var ReadUint32LEError;
(function (ReadUint32LEError) {
    ReadUint32LEError["insufficientBytes"] = "Error reading Uint32LE: requires 4 bytes.";
})(ReadUint32LEError || (ReadUint32LEError = {}));
/**
 * Read a 4-byte, Uint32LE from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * number and the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading
 */
const readUint32LE = (position) => {
    const nextPosition = {
        bin: position.bin,
        index: position.index + 4 /* ReadConstants.bytesPerUint32 */,
    };
    const uint32LEBin = position.bin.subarray(position.index, nextPosition.index);
    if (uint32LEBin.length !== 4 /* ReadConstants.bytesPerUint32 */) {
        return formatError(ReadUint32LEError.insufficientBytes, `Remaining bytes: ${uint32LEBin.length}`);
    }
    const result = binToNumberUint32LE(uint32LEBin);
    return { position: nextPosition, result };
};
var ReadUint64LEError;
(function (ReadUint64LEError) {
    ReadUint64LEError["insufficientBytes"] = "Error reading Uint64LE: requires 8 bytes.";
})(ReadUint64LEError || (ReadUint64LEError = {}));
/**
 * Read {@link Output.valueSatoshis} from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Output.valueSatoshis} and the next {@link ReadPosition}.
 * @param position - the {@link ReadPosition} at which to start reading
 * {@link Output.valueSatoshis}
 */
const readUint64LE = (position) => {
    const nextPosition = {
        bin: position.bin,
        index: position.index + 8 /* ReadConstants.bytesPerUint64 */,
    };
    const uint64LEBin = position.bin.subarray(position.index, nextPosition.index);
    if (uint64LEBin.length !== 8 /* ReadConstants.bytesPerUint64 */) {
        return formatError(ReadUint64LEError.insufficientBytes, `Remaining bytes: ${uint64LEBin.length}`);
    }
    const result = binToBigIntUint64LE(uint64LEBin);
    return { position: nextPosition, result };
};
var CompactUintPrefixedBinError;
(function (CompactUintPrefixedBinError) {
    CompactUintPrefixedBinError["invalidCompactUint"] = "Error reading CompactUint-prefixed bin: invalid CompactUint.";
    CompactUintPrefixedBinError["insufficientBytes"] = "Error reading CompactUint-prefixed bin: insufficient bytes.";
})(CompactUintPrefixedBinError || (CompactUintPrefixedBinError = {}));
/**
 * Read a bin (`Uint8Array`) that is prefixed by a minimally-encoded
 * `CompactUint` starting at the provided {@link ReadPosition}, returning either
 * an error message (as a string) or an object containing the `Uint8Array` and
 * the next {@link ReadPosition}. (In the transaction format,
 * `CompactUint`-prefixes are used to indicate the length of unlocking bytecode,
 * locking bytecode, and non-fungible token commitments.)
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * `CompactUint`-prefixed bin (`Uint8Array`)
 */
const readCompactUintPrefixedBin = (position) => {
    const read = readCompactUintMinimal(position);
    if (typeof read === 'string') {
        return formatError(CompactUintPrefixedBinError.invalidCompactUint, read);
    }
    const { result, position: p2 } = read;
    const length = Number(result);
    const nextPosition = { bin: position.bin, index: p2.index + length };
    const contents = position.bin.slice(p2.index, nextPosition.index);
    if (contents.length !== length) {
        return formatError(CompactUintPrefixedBinError.insufficientBytes, `Required bytes: ${length}, remaining bytes: ${contents.length}`);
    }
    return { position: nextPosition, result: contents };
};
/**
 * Read the remaining bytes from the provided {@link ReadPosition}, returning
 * an object containing the `Uint8Array` and the next {@link ReadPosition}
 * (with `index === bin.length`).
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * remaining bytes
 */
const readRemainingBytes = (position) => {
    const nextPosition = {
        bin: position.bin,
        index: position.bin.length,
    };
    const result = position.bin.subarray(position.index, nextPosition.index);
    return { position: nextPosition, result };
};

/**
 * The capability assigned to a particular non-fungible token.
 */
var NonFungibleTokenCapability;
(function (NonFungibleTokenCapability) {
    /**
     * No capability, i.e. the token is an **immutable token**.
     */
    NonFungibleTokenCapability["none"] = "none";
    /**
     * The mutable capability (`0x01`), i.e. the token is a **mutable token**.
     */
    NonFungibleTokenCapability["mutable"] = "mutable";
    /**
     * The minting capability (`0x02`), i.e. the token is a **minting token**.
     */
    NonFungibleTokenCapability["minting"] = "minting";
})(NonFungibleTokenCapability || (NonFungibleTokenCapability = {}));
/**
 * The maximum uint64 value – an impossibly large, intentionally invalid value
 * for `valueSatoshis`. See {@link Transaction.valueSatoshis} for details.
 */
// prettier-ignore
// eslint-disable-next-line @typescript-eslint/no-magic-numbers
const excessiveSatoshis = Uint8Array.from([255, 255, 255, 255, 255, 255, 255, 255]);

/**
 * Encode a single input for inclusion in an encoded transaction.
 *
 * @param input - the input to encode
 */
const encodeTransactionInput = (input) => flattenBinArray([
    input.outpointTransactionHash.slice().reverse(),
    numberToBinUint32LE(input.outpointIndex),
    bigIntToCompactUint(BigInt(input.unlockingBytecode.length)),
    input.unlockingBytecode,
    numberToBinUint32LE(input.sequenceNumber),
]);
var TransactionDecodingError;
(function (TransactionDecodingError) {
    TransactionDecodingError["transaction"] = "Error reading transaction.";
    TransactionDecodingError["endsWithUnexpectedBytes"] = "Error decoding transaction: the provided input includes unexpected bytes after the encoded transaction.";
    TransactionDecodingError["input"] = "Error reading transaction input.";
    TransactionDecodingError["inputs"] = "Error reading transaction inputs.";
    TransactionDecodingError["output"] = "Error reading transaction output.";
    TransactionDecodingError["outputs"] = "Error reading transaction outputs.";
    TransactionDecodingError["outputsEndWithUnexpectedBytes"] = "Error decoding transaction outputs: the provided serialization includes unexpected bytes after the encoded transaction outputs.";
    TransactionDecodingError["lockingBytecodeLength"] = "Error reading locking bytecode length.";
})(TransactionDecodingError || (TransactionDecodingError = {}));
/**
 * Read a transaction {@link Input} from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Input} and the next {@link ReadPosition}.
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction output
 */
const readTransactionInput = (position) => {
    const inputRead = readMultiple(position, [
        readBytes(32 /* TransactionConstants.outpointTransactionHashLength */),
        readUint32LE,
        readCompactUintPrefixedBin,
        readUint32LE,
    ]);
    if (typeof inputRead === 'string') {
        return formatError(TransactionDecodingError.input, inputRead);
    }
    const { position: nextPosition, result: [outpointTransactionHash, outpointIndex, unlockingBytecode, sequenceNumber,], } = inputRead;
    return {
        position: nextPosition,
        result: {
            outpointIndex,
            outpointTransactionHash: outpointTransactionHash.reverse(),
            sequenceNumber,
            unlockingBytecode,
        },
    };
};
/**
 * Encode a set of {@link Input}s for inclusion in an encoded transaction
 * including the prefixed number of inputs.
 *
 * Format: [CompactUint: input count] [encoded inputs]
 *
 * @param inputs - the set of inputs to encode
 */
const encodeTransactionInputs = (inputs) => flattenBinArray([
    bigIntToCompactUint(BigInt(inputs.length)),
    ...inputs.map(encodeTransactionInput),
]);
/**
 * Read a set of transaction {@link Input}s beginning at {@link ReadPosition}.
 * A CompactUint will be read to determine the number of inputs, and that
 * number of transaction inputs will be read and returned. Returns either an
 * error message (as a string) or an object containing the array of inputs and
 * the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction inputs
 */
const readTransactionInputs = (position) => {
    const inputsRead = readItemCount(position, readTransactionInput);
    if (typeof inputsRead === 'string') {
        return formatError(TransactionDecodingError.inputs, inputsRead);
    }
    return inputsRead;
};
const maximumTokenAmount = 9223372036854775807n;
const nftCapabilityNumberToLabel = [
    NonFungibleTokenCapability.none,
    NonFungibleTokenCapability.mutable,
    NonFungibleTokenCapability.minting,
];
const nftCapabilityLabelToNumber = {
    [NonFungibleTokenCapability.none]: 0,
    [NonFungibleTokenCapability.mutable]: 1,
    [NonFungibleTokenCapability.minting]: 2,
};
var CashTokenDecodingError;
(function (CashTokenDecodingError) {
    CashTokenDecodingError["invalidPrefix"] = "Error reading token prefix.";
    CashTokenDecodingError["insufficientLength"] = "Invalid token prefix: insufficient length.";
    CashTokenDecodingError["reservedBit"] = "Invalid token prefix: reserved bit is set.";
    CashTokenDecodingError["invalidCapability"] = "Invalid token prefix: capability must be none (0), mutable (1), or minting (2).";
    CashTokenDecodingError["commitmentWithoutNft"] = "Invalid token prefix: commitment requires an NFT.";
    CashTokenDecodingError["capabilityWithoutNft"] = "Invalid token prefix: capability requires an NFT.";
    CashTokenDecodingError["commitmentLengthZero"] = "Invalid token prefix: if encoded, commitment length must be greater than 0.";
    CashTokenDecodingError["invalidCommitment"] = "Invalid token prefix: invalid non-fungible token commitment.";
    CashTokenDecodingError["invalidAmountEncoding"] = "Invalid token prefix: invalid fungible token amount encoding.";
    CashTokenDecodingError["zeroAmount"] = "Invalid token prefix: if encoded, fungible token amount must be greater than 0.";
    CashTokenDecodingError["excessiveAmount"] = "Invalid token prefix: exceeds maximum fungible token amount of 9223372036854775807.";
    CashTokenDecodingError["noTokens"] = "Invalid token prefix: must encode at least one token.";
})(CashTokenDecodingError || (CashTokenDecodingError = {}));
/**
 * Read a token amount from the provided {@link ReadPosition}, returning either
 * an error message (as a string) or an object containing the value and the next
 * {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * token amount.
 */
const readTokenAmount = (position) => {
    const amountRead = readCompactUintMinimal(position);
    if (typeof amountRead === 'string') {
        return formatError(CashTokenDecodingError.invalidAmountEncoding, amountRead);
    }
    if (amountRead.result > maximumTokenAmount) {
        return formatError(CashTokenDecodingError.excessiveAmount, `Encoded amount: ${amountRead.result}`);
    }
    if (amountRead.result === 0n) {
        return formatError(CashTokenDecodingError.zeroAmount);
    }
    return amountRead;
};
/**
 * Attempt to read a transaction {@link Output}'s token prefix from the provided
 * {@link ReadPosition}, returning either an error message (as a string) or an
 * object containing the (optional) token information and the
 * next {@link ReadPosition}.
 *
 * Rather than using this function directly, most applications
 * should use {@link readLockingBytecodeWithPrefix}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * token prefix
 */
// eslint-disable-next-line complexity
const readTokenPrefix = (position) => {
    const { bin, index } = position;
    if (bin[index] !== 239 /* CashTokens.PREFIX_TOKEN */) {
        return { position, result: {} };
    }
    if (bin.length < index + 34 /* CashTokens.minimumPrefixLength */) {
        return formatError(CashTokenDecodingError.insufficientLength, `The minimum possible length is ${34 /* CashTokens.minimumPrefixLength */}. Missing bytes: ${34 /* CashTokens.minimumPrefixLength */ - (bin.length - index)}`);
    }
    const category = bin
        .slice(index + 1, index + 33 /* CashTokens.tokenBitfieldIndex */)
        .reverse();
    const tokenBitfield = bin[index + 33 /* CashTokens.tokenBitfieldIndex */]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
    /* eslint-disable no-bitwise */
    const prefixStructure = tokenBitfield & 240 /* CashTokens.tokenFormatMask */;
    if ((prefixStructure & 128 /* CashTokens.RESERVED_BIT */) !== 0) {
        return formatError(CashTokenDecodingError.reservedBit, `Bitfield: 0b${tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)}`);
    }
    const nftCapabilityInt = tokenBitfield & 15 /* CashTokens.nftCapabilityMask */;
    if (nftCapabilityInt > 2 /* CashTokens.maximumCapability */) {
        return formatError(CashTokenDecodingError.invalidCapability, `Capability value: ${nftCapabilityInt}`);
    }
    const capability = nftCapabilityNumberToLabel[nftCapabilityInt]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
    const hasNft = (prefixStructure & 32 /* CashTokens.HAS_NFT */) !== 0;
    const hasCommitmentLength = (prefixStructure & 64 /* CashTokens.HAS_COMMITMENT_LENGTH */) !== 0;
    if (hasCommitmentLength && !hasNft) {
        return formatError(CashTokenDecodingError.commitmentWithoutNft, `Bitfield: 0b${tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)}`);
    }
    const hasAmount = (prefixStructure & 16 /* CashTokens.HAS_AMOUNT */) !== 0;
    /* eslint-enable no-bitwise */
    const nextPosition = {
        bin,
        index: index + 33 /* CashTokens.tokenBitfieldIndex */ + 1,
    };
    if (hasNft) {
        const commitmentRead = hasCommitmentLength
            ? readCompactUintPrefixedBin(nextPosition)
            : { position: nextPosition, result: Uint8Array.of() };
        if (typeof commitmentRead === 'string') {
            return formatError(CashTokenDecodingError.invalidCommitment, commitmentRead);
        }
        if (hasCommitmentLength && commitmentRead.result.length === 0) {
            return formatError(CashTokenDecodingError.commitmentLengthZero);
        }
        const amountRead = hasAmount
            ? readTokenAmount(commitmentRead.position)
            : { position: commitmentRead.position, result: 0n };
        if (typeof amountRead === 'string') {
            return amountRead;
        }
        return {
            position: amountRead.position,
            result: {
                token: {
                    amount: amountRead.result,
                    category,
                    nft: { capability, commitment: commitmentRead.result },
                },
            },
        };
    }
    if (capability !== NonFungibleTokenCapability.none) {
        return formatError(CashTokenDecodingError.capabilityWithoutNft, `Bitfield: 0b${tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)}`);
    }
    if (!hasAmount) {
        return formatError(CashTokenDecodingError.noTokens, `Bitfield: 0b${tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)}`);
    }
    const amountRead = readTokenAmount(nextPosition);
    if (typeof amountRead === 'string') {
        return amountRead;
    }
    return {
        position: amountRead.position,
        result: { token: { amount: amountRead.result, category } },
    };
};
/**
 * Read the locking bytecode and token prefix (if present) of a transaction
 * {@link Output}, beginning at the `CompactUint` indicating the
 * combined length.
 * @param position - the {@link ReadPosition} at which to start reading the
 * optional token prefix and locking bytecode
 */
const readLockingBytecodeWithPrefix = (position) => {
    const bytecodeRead = readCompactUintPrefixedBin(position);
    if (typeof bytecodeRead === 'string') {
        return formatError(TransactionDecodingError.lockingBytecodeLength, bytecodeRead);
    }
    const { result: contents, position: nextPosition } = bytecodeRead;
    const contentsRead = readMultiple({ bin: contents, index: 0 }, [
        readTokenPrefix,
        readRemainingBytes,
    ]);
    if (typeof contentsRead === 'string') {
        return formatError(CashTokenDecodingError.invalidPrefix, contentsRead);
    }
    const { result: [{ token }, lockingBytecode], } = contentsRead;
    return {
        position: nextPosition,
        result: { lockingBytecode, ...(token === undefined ? {} : { token }) },
    };
};
/**
 * Read a transaction {@link Output} from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Output} and the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction output
 */
const readTransactionOutput = (position) => {
    const outputRead = readMultiple(position, [
        readUint64LE,
        readLockingBytecodeWithPrefix,
    ]);
    if (typeof outputRead === 'string') {
        return formatError(TransactionDecodingError.output, outputRead);
    }
    const { position: nextPosition, result: [valueSatoshis, { lockingBytecode, token }], } = outputRead;
    return {
        position: nextPosition,
        result: {
            lockingBytecode,
            ...(token === undefined ? {} : { token }),
            valueSatoshis,
        },
    };
};
/**
 * Given {@link Output.token} data, encode a token prefix.
 *
 * This function does not fail, but returns an empty Uint8Array if the token
 * data does not encode any tokens (even if `token.category` is set).
 *
 * @param token - the token data to encode
 */
// eslint-disable-next-line complexity
const encodeTokenPrefix = (token) => {
    if (token === undefined || (token.nft === undefined && token.amount < 1n)) {
        return Uint8Array.of();
    }
    const hasNft = token.nft === undefined ? 0 : 32 /* CashTokens.HAS_NFT */;
    const capabilityInt = token.nft === undefined
        ? 0
        : nftCapabilityLabelToNumber[token.nft.capability];
    const hasCommitmentLength = token.nft !== undefined && token.nft.commitment.length > 0
        ? 64 /* CashTokens.HAS_COMMITMENT_LENGTH */
        : 0;
    const hasAmount = token.amount > 0n ? 16 /* CashTokens.HAS_AMOUNT */ : 0;
    const tokenBitfield = 
    // eslint-disable-next-line no-bitwise
    hasNft | hasCommitmentLength | hasAmount | capabilityInt;
    return flattenBinArray([
        Uint8Array.of(239 /* CashTokens.PREFIX_TOKEN */),
        token.category.slice().reverse(),
        Uint8Array.of(tokenBitfield),
        ...(hasCommitmentLength === 0
            ? []
            : [
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                bigIntToCompactUint(BigInt(token.nft.commitment.length)),
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                token.nft.commitment,
            ]),
        ...(hasAmount === 0 ? [] : [bigIntToCompactUint(token.amount)]),
    ]);
};
/**
 * Encode a single {@link Output} for inclusion in an encoded transaction.
 *
 * @param output - the output to encode
 */
const encodeTransactionOutput = (output) => {
    const lockingBytecodeField = flattenBinArray([
        encodeTokenPrefix(output.token),
        output.lockingBytecode,
    ]);
    return flattenBinArray([
        valueSatoshisToBin(output.valueSatoshis),
        bigIntToCompactUint(BigInt(lockingBytecodeField.length)),
        lockingBytecodeField,
    ]);
};
/**
 * Read a set of transaction {@link Output}s beginning at {@link ReadPosition}.
 * A CompactUint will be read to determine the number of outputs, and that
 * number of transaction outputs will be read and returned. Returns either an
 * error message (as a string) or an object containing the array of outputs and
 * the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction outputs
 */
const readTransactionOutputs = (position) => {
    const outputsRead = readItemCount(position, readTransactionOutput);
    if (typeof outputsRead === 'string') {
        return formatError(TransactionDecodingError.outputs, outputsRead);
    }
    return outputsRead;
};
/**
 * Decode a CompactUint-prefixed series of Transaction {@link Output}s
 * according to the version 1/2 P2P network transaction format.
 *
 * This function verifies that the provided `bin` contains one `CompactUint`
 * followed by the indicated number of serialized transaction outputs with no
 * additional data. To read a transaction from a
 * specific location within a `Uint8Array`, use {@link readTransactionCommon}.
 *
 * For the reverse, see {@link encodeTransactionOutputs}.
 *
 * @param bin - the encoded transaction to decode
 */
const decodeTransactionOutputs = (bin) => {
    const outputsRead = readTransactionOutputs({ bin, index: 0 });
    if (typeof outputsRead === 'string') {
        return outputsRead;
    }
    if (outputsRead.position.index !== bin.length) {
        return formatError(TransactionDecodingError.outputsEndWithUnexpectedBytes, `Last encoded transaction output ends at index ${outputsRead.position.index - 1}, leaving ${bin.length - outputsRead.position.index} remaining byte(s).`);
    }
    return outputsRead.result;
};
/**
 * Encode a set of {@link Output}s for inclusion in an encoded transaction
 * including the prefixed number of outputs. Note, this encoding differs from
 * {@link encodeTransactionOutputsForSigning} (used for signing serializations).
 *
 * Format: `[CompactUint: output count] [encoded outputs]`
 *
 * For the reverse, see {@link decodeTransactionOutputs}.
 *
 * @param outputs - the set of outputs to encode
 */
const encodeTransactionOutputs = (outputs) => flattenBinArray([
    bigIntToCompactUint(BigInt(outputs.length)),
    ...outputs.map(encodeTransactionOutput),
]);
/**
 * Read a version 1 or 2 transaction beginning at {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Transaction} and the next {@link ReadPosition}. Rather than using this
 * function directly, most applications should
 * use {@link decodeTransactionCommon}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * {@link TransactionCommon}
 */
const readTransactionCommon = (position) => {
    const transactionRead = readMultiple(position, [
        readUint32LE,
        readTransactionInputs,
        readTransactionOutputs,
        readUint32LE,
    ]);
    if (typeof transactionRead === 'string') {
        return formatError(TransactionDecodingError.transaction, transactionRead);
    }
    const { position: nextPosition, result: [version, inputs, outputs, locktime], } = transactionRead;
    return {
        position: nextPosition,
        result: { inputs, locktime, outputs, version },
    };
};
const readTransaction = readTransactionCommon;
const readTransactionOutputNonTokenAware = (pos) => {
    const outputRead = readMultiple(pos, [
        readUint64LE,
        readCompactUintPrefixedBin,
    ]);
    if (typeof outputRead === 'string') {
        return formatError(TransactionDecodingError.output, outputRead);
    }
    const { position: nextPosition, result: [valueSatoshis, lockingBytecode], } = outputRead;
    return {
        position: nextPosition,
        result: { lockingBytecode, valueSatoshis },
    };
};
const readTransactionOutputsNonTokenAware = (pos) => {
    const outputsRead = readItemCount(pos, readTransactionOutputNonTokenAware);
    if (typeof outputsRead === 'string') {
        return formatError(TransactionDecodingError.outputs, outputsRead);
    }
    return outputsRead;
};
/**
 * Read a version 1 or 2 transaction beginning at a {@link ReadPosition} as if
 * CHIP-2022-02-CashTokens were not deployed, returning either an error message
 * (as a string) or an object containing the {@link Transaction} and the next
 * {@link ReadPosition}.
 *
 * This function emulates legacy transaction parsing to test behavior prior to
 * deployment of CHIP-2022-02-CashTokens; most applications should instead
 * use {@link readTransactionCommon}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * {@link TransactionCommon}
 */
const readTransactionNonTokenAware = (position) => {
    const transactionRead = readMultiple(position, [
        readUint32LE,
        readTransactionInputs,
        readTransactionOutputsNonTokenAware,
        readUint32LE,
    ]);
    if (typeof transactionRead === 'string') {
        return formatError(TransactionDecodingError.transaction, transactionRead);
    }
    const { position: nextPosition, result: [version, inputs, outputs, locktime], } = transactionRead;
    return {
        position: nextPosition,
        result: { inputs, locktime, outputs, version },
    };
};
/**
 * Decode a {@link TransactionCommon} according to the version 1/2 P2P network
 * transaction format.
 *
 * This function verifies that the provided `bin` contains only one transaction
 * and no additional data. To read a transaction from a specific location within
 * a `Uint8Array`, use {@link readTransactionCommon}.
 *
 * For the reverse, see {@link encodeTransactionCommon}.
 *
 * @param bin - the encoded transaction to decode
 */
const decodeTransactionCommon = (bin) => {
    const transactionRead = readTransactionCommon({ bin, index: 0 });
    if (typeof transactionRead === 'string') {
        return transactionRead;
    }
    if (transactionRead.position.index !== bin.length) {
        return formatError(TransactionDecodingError.endsWithUnexpectedBytes, `Encoded transaction ends at index ${transactionRead.position.index - 1}, leaving ${bin.length - transactionRead.position.index} remaining bytes.`);
    }
    return transactionRead.result;
};
const decodeTransactionBCH = decodeTransactionCommon;
const decodeTransaction = decodeTransactionBCH;
/**
 * Decode a {@link TransactionCommon} from a trusted source according to the
 * version 1/2 P2P network transaction format.
 *
 * Note: this method throws runtime errors when attempting to decode messages
 * which do not properly follow the transaction format. If the input is
 * untrusted, use {@link decodeTransactionCommon}.
 *
 * @param bin - the raw message to decode
 */
const decodeTransactionUnsafeCommon = (bin) => {
    const result = decodeTransactionCommon(bin);
    if (typeof result === 'string') {
        // eslint-disable-next-line functional/no-throw-statements
        throw new Error(result);
    }
    return result;
};
const decodeTransactionUnsafeBCH = decodeTransactionUnsafeCommon;
const decodeTransactionUnsafe = decodeTransactionUnsafeBCH;
/**
 * Encode a {@link Transaction} using the standard P2P network format. This
 * serialization is also used when computing the transaction's hash (A.K.A.
 * "transaction ID" or "TXID").
 *
 * For the reverse, see {@link decodeTransactionCommon}.
 */
const encodeTransactionCommon = (tx) => flattenBinArray([
    numberToBinUint32LE(tx.version),
    encodeTransactionInputs(tx.inputs),
    encodeTransactionOutputs(tx.outputs),
    numberToBinUint32LE(tx.locktime),
]);
const encodeTransactionBCH = encodeTransactionCommon;
const encodeTransaction = encodeTransactionBCH;
/**
 * @deprecated use `structuredClone` instead
 */
const cloneTransactionInputsCommon = (inputs) => inputs.map((input) => ({
    outpointIndex: input.outpointIndex,
    outpointTransactionHash: input.outpointTransactionHash.slice(),
    sequenceNumber: input.sequenceNumber,
    unlockingBytecode: input.unlockingBytecode.slice(),
}));
/**
 * @deprecated use `structuredClone` instead
 */
const cloneTransactionOutputsCommon = (outputs) => outputs.map((output) => ({
    lockingBytecode: output.lockingBytecode.slice(),
    ...(output.token === undefined
        ? {}
        : {
            token: {
                amount: output.token.amount,
                category: output.token.category.slice(),
                ...(output.token.nft === undefined
                    ? {}
                    : {
                        nft: {
                            capability: output.token.nft.capability,
                            commitment: output.token.nft.commitment.slice(),
                        },
                    }),
            },
        }),
    valueSatoshis: output.valueSatoshis,
}));
/**
 * @deprecated use `structuredClone` instead
 */
const cloneTransactionCommon = (transaction) => ({
    inputs: cloneTransactionInputsCommon(transaction.inputs),
    locktime: transaction.locktime,
    outputs: cloneTransactionOutputsCommon(transaction.outputs),
    version: transaction.version,
});
/**
 * Compute a transaction hash (A.K.A. "transaction ID" or "TXID") from an
 * encoded transaction in P2P network message order. This is the byte order
 * produced by most sha256 libraries and used by encoded P2P network messages.
 * It is also the byte order produced by `OP_SHA256` and `OP_HASH256` in the
 * virtual machine.
 *
 * @returns the transaction hash in P2P network message byte order
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
const hashTransactionP2pOrder = (transaction, sha256$1 = sha256) => hash256(transaction, sha256$1);
/**
 * Compute a transaction hash (A.K.A. "transaction ID" or "TXID") from an
 * encoded transaction in user interface byte order. This is the byte order
 * typically used by block explorers, wallets, and other user interfaces.
 *
 * To return this result as a `string`, use {@link hashTransaction}.
 *
 * @returns the transaction hash in User Interface byte order
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
const hashTransactionUiOrder = (transaction, sha256$1 = sha256) => hashTransactionP2pOrder(transaction, sha256$1).reverse();
/**
 * Return an encoded {@link Transaction}'s hash/ID as a string in user interface
 * byte order (typically used by wallets and block explorers).
 *
 * To return this result as a `Uint8Array`, use {@link hashTransactionUiOrder}.
 *
 * @param transaction - the encoded transaction
 */
const hashTransaction = (transaction) => binToHex(hashTransactionUiOrder(transaction));
/**
 * Encode all outpoints in a series of transaction inputs. (For use in
 * {@link hashTransactionOutpoints}.)
 *
 * @param inputs - the series of inputs from which to extract the outpoints
 */
const encodeTransactionOutpoints = (inputs) => flattenBinArray(inputs.map((i) => flattenBinArray([
    i.outpointTransactionHash.slice().reverse(),
    numberToBinUint32LE(i.outpointIndex),
])));
/**
 * Encode an array of transaction {@link Output}s for use in transaction signing
 * serializations. Note, this encoding differs from
 * {@link encodeTransactionOutputs} (used for encoding full transactions).
 *
 * @param outputs - the array of outputs to encode
 */
const encodeTransactionOutputsForSigning = (outputs) => flattenBinArray(outputs.map(encodeTransactionOutput));
/**
 * Encode the sequence numbers of an array of transaction inputs for use in
 * transaction signing serializations.
 *
 * @param inputs - the array of inputs from which to extract the sequence
 * numbers
 */
const encodeTransactionInputSequenceNumbersForSigning = (inputs) => flattenBinArray(inputs.map((i) => numberToBinUint32LE(i.sequenceNumber)));

var OpcodeDescriptionsXEC;
(function (OpcodeDescriptionsXEC) {
    OpcodeDescriptionsXEC["OP_0"] = "Push the VM Number 0 onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
    OpcodeDescriptionsXEC["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
    OpcodeDescriptionsXEC["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_1"] = "Push a 1 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_2"] = "Push a 2 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_3"] = "Push a 3 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_4"] = "Push a 4 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_5"] = "Push a 5 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_6"] = "Push a 6 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_7"] = "Push a 7 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_8"] = "Push a 8 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_9"] = "Push a 9 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_10"] = "Push a 10 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_11"] = "Push a 11 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_12"] = "Push a 12 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_13"] = "Push a 13 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_14"] = "Push a 14 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_15"] = "Push a 15 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_16"] = "Push a 16 (VM Number) onto the stack.";
    OpcodeDescriptionsXEC["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
    OpcodeDescriptionsXEC["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsXEC["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsXEC["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
    OpcodeDescriptionsXEC["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
    OpcodeDescriptionsXEC["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
    OpcodeDescriptionsXEC["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
    OpcodeDescriptionsXEC["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
    OpcodeDescriptionsXEC["OP_RETURN"] = "Error when executed.";
    OpcodeDescriptionsXEC["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
    OpcodeDescriptionsXEC["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
    OpcodeDescriptionsXEC["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
    OpcodeDescriptionsXEC["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
    OpcodeDescriptionsXEC["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
    OpcodeDescriptionsXEC["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
    OpcodeDescriptionsXEC["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
    OpcodeDescriptionsXEC["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
    OpcodeDescriptionsXEC["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
    OpcodeDescriptionsXEC["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
    OpcodeDescriptionsXEC["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
    OpcodeDescriptionsXEC["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
    OpcodeDescriptionsXEC["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
    OpcodeDescriptionsXEC["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
    OpcodeDescriptionsXEC["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
    OpcodeDescriptionsXEC["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
    OpcodeDescriptionsXEC["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
    OpcodeDescriptionsXEC["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
    OpcodeDescriptionsXEC["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
    OpcodeDescriptionsXEC["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
    OpcodeDescriptionsXEC["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
    OpcodeDescriptionsXEC["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
    OpcodeDescriptionsXEC["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
    OpcodeDescriptionsXEC["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
    OpcodeDescriptionsXEC["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
    OpcodeDescriptionsXEC["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsXEC["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsXEC["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsXEC["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsXEC["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
    OpcodeDescriptionsXEC["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
    OpcodeDescriptionsXEC["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
    OpcodeDescriptionsXEC["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
    OpcodeDescriptionsXEC["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
    OpcodeDescriptionsXEC["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
    OpcodeDescriptionsXEC["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
    OpcodeDescriptionsXEC["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
    OpcodeDescriptionsXEC["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
    OpcodeDescriptionsXEC["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
    OpcodeDescriptionsXEC["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
    OpcodeDescriptionsXEC["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
    OpcodeDescriptionsXEC["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
    OpcodeDescriptionsXEC["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsXEC["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
    OpcodeDescriptionsXEC["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
    OpcodeDescriptionsXEC["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
    OpcodeDescriptionsXEC["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsXEC["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
    OpcodeDescriptionsXEC["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
    OpcodeDescriptionsXEC["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsXEC["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
    OpcodeDescriptionsXEC["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
    OpcodeDescriptionsXEC["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
    OpcodeDescriptionsXEC["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
    OpcodeDescriptionsXEC["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
    OpcodeDescriptionsXEC["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
    OpcodeDescriptionsXEC["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
    OpcodeDescriptionsXEC["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsXEC["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
    OpcodeDescriptionsXEC["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
})(OpcodeDescriptionsXEC || (OpcodeDescriptionsXEC = {}));

/**
 * A.K.A. `sighash` flags
 */
var SigningSerializationFlag;
(function (SigningSerializationFlag) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationFlag[SigningSerializationFlag["allOutputs"] = 1] = "allOutputs";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationFlag[SigningSerializationFlag["noOutputs"] = 2] = "noOutputs";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationFlag[SigningSerializationFlag["correspondingOutput"] = 3] = "correspondingOutput";
    /**
     * A.K.A. `SIGHASH_UTXOS`
     */
    SigningSerializationFlag[SigningSerializationFlag["utxos"] = 32] = "utxos";
    SigningSerializationFlag[SigningSerializationFlag["forkId"] = 64] = "forkId";
    /**
     * A.K.A `ANYONE_CAN_PAY`/`SIGHASH_ANYONECANPAY`
     */
    SigningSerializationFlag[SigningSerializationFlag["singleInput"] = 128] = "singleInput";
})(SigningSerializationFlag || (SigningSerializationFlag = {}));
/* eslint-disable no-bitwise, @typescript-eslint/prefer-literal-enum-member */
var SigningSerializationType;
(function (SigningSerializationType) {
    SigningSerializationType[SigningSerializationType["allOutputs"] = 65] = "allOutputs";
    SigningSerializationType[SigningSerializationType["allOutputsAllUtxos"] = 97] = "allOutputsAllUtxos";
    SigningSerializationType[SigningSerializationType["allOutputsSingleInput"] = 193] = "allOutputsSingleInput";
    SigningSerializationType[SigningSerializationType["correspondingOutput"] = 67] = "correspondingOutput";
    SigningSerializationType[SigningSerializationType["correspondingOutputAllUtxos"] = 99] = "correspondingOutputAllUtxos";
    SigningSerializationType[SigningSerializationType["correspondingOutputSingleInput"] = 195] = "correspondingOutputSingleInput";
    SigningSerializationType[SigningSerializationType["noOutputs"] = 66] = "noOutputs";
    SigningSerializationType[SigningSerializationType["noOutputsAllUtxos"] = 98] = "noOutputsAllUtxos";
    SigningSerializationType[SigningSerializationType["noOutputsSingleInput"] = 194] = "noOutputsSingleInput";
})(SigningSerializationType || (SigningSerializationType = {}));
/* eslint-enable no-bitwise, @typescript-eslint/prefer-literal-enum-member */
// eslint-disable-next-line @typescript-eslint/naming-convention
const SigningSerializationTypeBCH = SigningSerializationType;
const match = (type, flag) => 
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
(type[0] & flag) !== 0;
const equals = (type, flag) => (type[0] & 31 /* Internal.mask5Bits */) === flag;
const shouldSerializeSingleInput = (type) => match(type, SigningSerializationFlag.singleInput);
const shouldSerializeCorrespondingOutput = (type) => equals(type, SigningSerializationFlag.correspondingOutput);
const shouldSerializeNoOutputs = (type) => equals(type, SigningSerializationFlag.noOutputs);
const shouldSerializeUtxos = (type) => match(type, SigningSerializationFlag.utxos);
const emptyHash = () => new Uint8Array(32 /* Internal.sha256HashByteLength */).fill(0);
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 */
const hashPrevouts = ({ signingSerializationType, transactionOutpoints, }, sha256$1 = sha256) => shouldSerializeSingleInput(signingSerializationType)
    ? emptyHash()
    : hash256(transactionOutpoints, sha256$1);
/**
 * Return the proper `hashUtxos` value for a given a signing serialization
 * type.
 */
const hashUtxos = ({ signingSerializationType, transactionUtxos, }, sha256$1 = sha256) => shouldSerializeUtxos(signingSerializationType)
    ? hash256(transactionUtxos, sha256$1)
    : Uint8Array.of();
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 */
const hashSequence = ({ signingSerializationType, transactionSequenceNumbers, }, sha256$1 = sha256) => !shouldSerializeSingleInput(signingSerializationType) &&
    !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? hash256(transactionSequenceNumbers, sha256$1)
    : emptyHash();
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 */
const hashOutputs = ({ correspondingOutput, signingSerializationType, transactionOutputs, }, sha256$1 = sha256) => !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? hash256(transactionOutputs, sha256$1)
    : shouldSerializeCorrespondingOutput(signingSerializationType)
        ? correspondingOutput === undefined
            ? emptyHash()
            : hash256(correspondingOutput, sha256$1)
        : emptyHash();
/**
 * Encode the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * Note: When validating transactions with multiple signatures,
 * performance-critical applications should use a memoized sha256 implementation
 * to avoid re-computing hashes.
 */
const encodeSigningSerializationBCH = ({ correspondingOutput, coveredBytecode, forkId = new Uint8Array([0, 0, 0]), locktime, outpointIndex, outpointTransactionHash, outputTokenPrefix, outputValue, sequenceNumber, signingSerializationType, transactionOutpoints, transactionOutputs, transactionSequenceNumbers, transactionUtxos, version, }, sha256$1 = sha256) => flattenBinArray([
    numberToBinUint32LE(version),
    hashPrevouts({ signingSerializationType, transactionOutpoints }, sha256$1),
    hashUtxos({ signingSerializationType, transactionUtxos }, sha256$1),
    hashSequence({
        signingSerializationType,
        transactionSequenceNumbers,
    }, sha256$1),
    outpointTransactionHash.slice().reverse(),
    numberToBinUint32LE(outpointIndex),
    outputTokenPrefix,
    bigIntToCompactUint(BigInt(coveredBytecode.length)),
    coveredBytecode,
    outputValue,
    numberToBinUint32LE(sequenceNumber),
    hashOutputs({
        correspondingOutput,
        signingSerializationType,
        transactionOutputs,
    }, sha256$1),
    numberToBinUint32LE(locktime),
    signingSerializationType,
    forkId,
]);
/**
 * Generate the encoded components of a BCH signing serialization from
 * compilation context.
 */
const generateSigningSerializationComponentsBCH = (context) => ({
    correspondingOutput: context.inputIndex < context.transaction.outputs.length
        ? encodeTransactionOutput(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        context.transaction.outputs[context.inputIndex])
        : undefined,
    locktime: context.transaction.locktime,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    outpointIndex: context.transaction.inputs[context.inputIndex].outpointIndex,
    outpointTransactionHash: 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.inputs[context.inputIndex].outpointTransactionHash,
    outputTokenPrefix: encodeTokenPrefix(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.sourceOutputs[context.inputIndex].token),
    outputValue: valueSatoshisToBin(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.sourceOutputs[context.inputIndex].valueSatoshis),
    sequenceNumber: 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.inputs[context.inputIndex].sequenceNumber,
    transactionOutpoints: encodeTransactionOutpoints(context.transaction.inputs),
    transactionOutputs: encodeTransactionOutputsForSigning(context.transaction.outputs),
    transactionSequenceNumbers: encodeTransactionInputSequenceNumbersForSigning(context.transaction.inputs),
    transactionUtxos: encodeTransactionOutputsForSigning(context.sourceOutputs),
    version: context.transaction.version,
});
/**
 * Generate the signing serialization for a particular transaction input
 * following the algorithm required by the provided `signingSerializationType`.
 *
 * Note: When validating transactions with multiple signatures,
 * performance-critical applications should use a memoized sha256 implementation
 * to avoid re-computing hashes.
 */
const generateSigningSerializationBCH = (context, { coveredBytecode, signingSerializationType, }, sha256$1 = sha256) => encodeSigningSerializationBCH({
    ...generateSigningSerializationComponentsBCH(context),
    coveredBytecode,
    signingSerializationType,
}, sha256$1);
/**
 * @param signingSerializationType - the 32-bit number indicating the signing
 * serialization algorithm to use
 */
const isLegacySigningSerialization = (signingSerializationType) => {
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const forkValue = signingSerializationType >> 8;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const newForkValue = (forkValue ^ 0xdead) | 0xff0000;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const sighashType = (newForkValue << 8) | (signingSerializationType & 0xff);
    // eslint-disable-next-line no-bitwise
    return (sighashType & SigningSerializationFlag.forkId) === 0;
};

/**
 * Consensus settings for the `BCH_2022_05` instruction set.
 */
var ConsensusCommon;
(function (ConsensusCommon) {
    /**
     * A.K.A. `MAX_SCRIPT_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
    /**
     * A.K.A. `MAX_OP_RETURN_RELAY`, `nMaxDatacarrierBytes`
     */
    ConsensusCommon[ConsensusCommon["maximumDataCarrierBytes"] = 223] = "maximumDataCarrierBytes";
    /**
     * A.K.A. `MAX_OPS_PER_SCRIPT`
     */
    ConsensusCommon[ConsensusCommon["maximumOperationCount"] = 201] = "maximumOperationCount";
    /**
     * A.K.A. `MAX_STACK_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStackDepth"] = 1000] = "maximumStackDepth";
    /**
     * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStackItemLength"] = 520] = "maximumStackItemLength";
    /**
     * A.K.A. `MAX_STANDARD_VERSION`
     */
    ConsensusCommon[ConsensusCommon["maximumStandardVersion"] = 2] = "maximumStandardVersion";
    /**
     * A.K.A. `MAX_TX_IN_SCRIPT_SIG_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStandardUnlockingBytecodeLength"] = 1650] = "maximumStandardUnlockingBytecodeLength";
    /**
     * A.K.A. `MIN_TX_SIZE`
     */
    ConsensusCommon[ConsensusCommon["minimumTransactionSize"] = 100] = "minimumTransactionSize";
    /**
     * A.K.A. `MAX_STANDARD_TX_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStandardTransactionSize"] = 100000] = "maximumStandardTransactionSize";
    /**
     * A.K.A. `MAX_TX_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumTransactionSize"] = 1000000] = "maximumTransactionSize";
    /**
     * A.K.A. `MAXIMUM_ELEMENT_SIZE_64_BIT`
     */
    ConsensusCommon[ConsensusCommon["maximumVmNumberLength"] = 8] = "maximumVmNumberLength";
    // eslint-disable-next-line @typescript-eslint/no-mixed-enums
    ConsensusCommon["minVmNumber"] = "-9223372036854775807";
    ConsensusCommon["maxVmNumber"] = "9223372036854775807";
    ConsensusCommon[ConsensusCommon["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusCommon || (ConsensusCommon = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
const SigningSerializationTypesCommon = [
    SigningSerializationTypeBCH.allOutputs,
    SigningSerializationTypeBCH.allOutputsSingleInput,
    SigningSerializationTypeBCH.correspondingOutput,
    SigningSerializationTypeBCH.correspondingOutputSingleInput,
    SigningSerializationTypeBCH.noOutputs,
    SigningSerializationTypeBCH.noOutputsSingleInput,
];
// eslint-disable-next-line @typescript-eslint/naming-convention
const SigningSerializationTypesBCH = SigningSerializationTypesCommon;
// eslint-disable-next-line @typescript-eslint/naming-convention
const ConsensusBCH = ConsensusCommon;

var AuthenticationErrorCommon;
(function (AuthenticationErrorCommon) {
    AuthenticationErrorCommon["calledReserved"] = "Program called an unassigned, reserved operation.";
    AuthenticationErrorCommon["calledReturn"] = "Program called an OP_RETURN operation.";
    AuthenticationErrorCommon["calledUpgradableNop"] = "Program called a disallowed upgradable non-operation (OP_NOP1-OP_NOP10).";
    AuthenticationErrorCommon["checkSequenceUnavailable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation, but OP_CHECKSEQUENCEVERIFY requires transaction version 2 or higher.";
    AuthenticationErrorCommon["disabledOpcode"] = "Program contains a disabled opcode.";
    AuthenticationErrorCommon["divisionByZero"] = "Program attempted to divide a number by zero.";
    AuthenticationErrorCommon["emptyAlternateStack"] = "Tried to read from an empty alternate stack.";
    AuthenticationErrorCommon["emptyStack"] = "Tried to read from an empty stack.";
    AuthenticationErrorCommon["exceededMaximumBytecodeLengthLocking"] = "The provided locking bytecode exceeds the maximum bytecode length (10,000 bytes).";
    AuthenticationErrorCommon["exceededMaximumBytecodeLengthUnlocking"] = "The provided unlocking bytecode exceeds the maximum bytecode length (10,000 bytes).";
    AuthenticationErrorCommon["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length.";
    AuthenticationErrorCommon["exceededMaximumStackDepth"] = "Program exceeded the maximum stack depth (1,000 items).";
    AuthenticationErrorCommon["exceededMaximumStackItemLength"] = "Program attempted to push a stack item that exceeded the maximum stack item length (520 bytes).";
    AuthenticationErrorCommon["exceededMaximumOperationCount"] = "Program exceeded the maximum operation count (201 operations).";
    AuthenticationErrorCommon["exceedsMaximumMultisigPublicKeyCount"] = "Program called an OP_CHECKMULTISIG that exceeds the maximum public key count (20 public keys).";
    AuthenticationErrorCommon["failedVerify"] = "Program failed an OP_VERIFY operation.";
    AuthenticationErrorCommon["invalidStackIndex"] = "Tried to read from an invalid stack index.";
    AuthenticationErrorCommon["incompatibleLocktimeType"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation with an incompatible locktime type. The transaction locktime and required locktime must both refer to either a block height or a block time.";
    AuthenticationErrorCommon["incompatibleSequenceType"] = "Program called an OP_CHECKSEQUENCEVERIFY operation with an incompatible sequence type flag. The input sequence number and required sequence number must both use the same sequence locktime type.";
    AuthenticationErrorCommon["insufficientLength"] = "Program called an OP_NUM2BIN operation with an insufficient byte length to re-encode the provided number.";
    AuthenticationErrorCommon["insufficientPublicKeys"] = "Program called an OP_CHECKMULTISIG operation that requires signatures from more public keys than are provided.";
    AuthenticationErrorCommon["invalidNaturalNumber"] = "Invalid input: the key/signature count inputs for OP_CHECKMULTISIG require a natural number (n > 0).";
    AuthenticationErrorCommon["invalidProtocolBugValue"] = "The OP_CHECKMULTISIG protocol bug value must be a VM Number 0 (to comply with the \"NULLDUMMY\" rule).";
    AuthenticationErrorCommon["invalidPublicKeyEncoding"] = "Encountered an improperly encoded public key.";
    AuthenticationErrorCommon["invalidVmNumber"] = "Invalid input: this operation requires a valid VM Number.";
    AuthenticationErrorCommon["invalidSignatureEncoding"] = "Encountered an improperly encoded signature.";
    AuthenticationErrorCommon["invalidSplitIndex"] = "Program called an OP_SPLIT operation with an invalid index.";
    AuthenticationErrorCommon["invalidTransactionInputIndex"] = "Program attempted to read from an invalid transaction input index.";
    AuthenticationErrorCommon["invalidTransactionOutputIndex"] = "Program attempted to read from an invalid transaction output index.";
    AuthenticationErrorCommon["invalidTransactionUtxoIndex"] = "Program attempted to read from an invalid transaction UTXO index.";
    AuthenticationErrorCommon["locktimeDisabled"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation, but locktime is disabled for this transaction.";
    AuthenticationErrorCommon["mismatchedBitwiseOperandLength"] = "Program attempted a bitwise operation on operands of different lengths.";
    AuthenticationErrorCommon["malformedLockingBytecode"] = "The provided locking bytecode is malformed.";
    AuthenticationErrorCommon["malformedP2shBytecode"] = "Redeem bytecode was malformed prior to P2SH evaluation.";
    AuthenticationErrorCommon["malformedPush"] = "Program must be long enough to push the requested number of bytes.";
    AuthenticationErrorCommon["malformedUnlockingBytecode"] = "The provided unlocking bytecode is malformed.";
    AuthenticationErrorCommon["negativeLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY or OP_CHECKSEQUENCEVERIFY operation with a negative locktime.";
    AuthenticationErrorCommon["nonEmptyControlStack"] = "The active bytecode completed with a non-empty control stack (missing `OP_ENDIF`).";
    AuthenticationErrorCommon["nonMinimalPush"] = "Push operations must use the smallest possible encoding.";
    AuthenticationErrorCommon["nonNullSignatureFailure"] = "Program failed a signature verification with a non-null signature (violating the \"NULLFAIL\" rule).";
    AuthenticationErrorCommon["overflowsVmNumberRange"] = "Program attempted an arithmetic operation which exceeds the range of VM Numbers.";
    AuthenticationErrorCommon["requiresCleanStack"] = "Program completed with an unexpected number of items on the stack (must be exactly 1).";
    AuthenticationErrorCommon["requiresPushOnly"] = "Unlocking bytecode may contain only push operations.";
    AuthenticationErrorCommon["schnorrSizedSignatureInCheckMultiSig"] = "Program used a schnorr-sized signature (65 bytes) in an OP_CHECKMULTISIG operation.";
    AuthenticationErrorCommon["unexpectedElse"] = "Encountered an OP_ELSE outside of an OP_IF ... OP_ENDIF block.";
    AuthenticationErrorCommon["unexpectedEndIf"] = "Encountered an OP_ENDIF that is not following a matching OP_IF.";
    AuthenticationErrorCommon["unknownOpcode"] = "Called an unknown opcode.";
    AuthenticationErrorCommon["unmatchedSequenceDisable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation requiring the disable flag, but the input's sequence number is missing the disable flag.";
    AuthenticationErrorCommon["unsatisfiedLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation that requires a locktime greater than the transaction's locktime.";
    AuthenticationErrorCommon["unsatisfiedSequenceNumber"] = "Program called an OP_CHECKSEQUENCEVERIFY operation that requires a sequence number greater than the input's sequence number.";
    AuthenticationErrorCommon["unsuccessfulEvaluation"] = "Unsuccessful evaluation: completed with a non-truthy value on top of the stack.";
})(AuthenticationErrorCommon || (AuthenticationErrorCommon = {}));
/**
 * Applies the `error` to a `state`.
 *
 * @remarks
 * If the state already has an error, this method does not override it.
 * (Evaluation should end after the first encountered error, so further errors
 * aren't relevant.)
 */
const applyError = (state, errorType, errorDetails) => ({
    ...state,
    error: state.error ?? formatError(errorType, errorDetails),
});

/**
 * The `BCH_2023_05` instruction set.
 */
var OpcodesBCH2023;
(function (OpcodesBCH2023) {
    /**
     * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
     */
    OpcodesBCH2023[OpcodesBCH2023["OP_0"] = 0] = "OP_0";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    OpcodesBCH2023[OpcodesBCH2023["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
    OpcodesBCH2023[OpcodesBCH2023["OP_1NEGATE"] = 79] = "OP_1NEGATE";
    OpcodesBCH2023[OpcodesBCH2023["OP_RESERVED"] = 80] = "OP_RESERVED";
    /**
     * A.K.A. `OP_TRUE`
     */
    OpcodesBCH2023[OpcodesBCH2023["OP_1"] = 81] = "OP_1";
    OpcodesBCH2023[OpcodesBCH2023["OP_2"] = 82] = "OP_2";
    OpcodesBCH2023[OpcodesBCH2023["OP_3"] = 83] = "OP_3";
    OpcodesBCH2023[OpcodesBCH2023["OP_4"] = 84] = "OP_4";
    OpcodesBCH2023[OpcodesBCH2023["OP_5"] = 85] = "OP_5";
    OpcodesBCH2023[OpcodesBCH2023["OP_6"] = 86] = "OP_6";
    OpcodesBCH2023[OpcodesBCH2023["OP_7"] = 87] = "OP_7";
    OpcodesBCH2023[OpcodesBCH2023["OP_8"] = 88] = "OP_8";
    OpcodesBCH2023[OpcodesBCH2023["OP_9"] = 89] = "OP_9";
    OpcodesBCH2023[OpcodesBCH2023["OP_10"] = 90] = "OP_10";
    OpcodesBCH2023[OpcodesBCH2023["OP_11"] = 91] = "OP_11";
    OpcodesBCH2023[OpcodesBCH2023["OP_12"] = 92] = "OP_12";
    OpcodesBCH2023[OpcodesBCH2023["OP_13"] = 93] = "OP_13";
    OpcodesBCH2023[OpcodesBCH2023["OP_14"] = 94] = "OP_14";
    OpcodesBCH2023[OpcodesBCH2023["OP_15"] = 95] = "OP_15";
    OpcodesBCH2023[OpcodesBCH2023["OP_16"] = 96] = "OP_16";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP"] = 97] = "OP_NOP";
    OpcodesBCH2023[OpcodesBCH2023["OP_VER"] = 98] = "OP_VER";
    OpcodesBCH2023[OpcodesBCH2023["OP_IF"] = 99] = "OP_IF";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOTIF"] = 100] = "OP_NOTIF";
    OpcodesBCH2023[OpcodesBCH2023["OP_VERIF"] = 101] = "OP_VERIF";
    OpcodesBCH2023[OpcodesBCH2023["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
    OpcodesBCH2023[OpcodesBCH2023["OP_ELSE"] = 103] = "OP_ELSE";
    OpcodesBCH2023[OpcodesBCH2023["OP_ENDIF"] = 104] = "OP_ENDIF";
    OpcodesBCH2023[OpcodesBCH2023["OP_VERIFY"] = 105] = "OP_VERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_RETURN"] = 106] = "OP_RETURN";
    OpcodesBCH2023[OpcodesBCH2023["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
    OpcodesBCH2023[OpcodesBCH2023["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
    OpcodesBCH2023[OpcodesBCH2023["OP_2DROP"] = 109] = "OP_2DROP";
    OpcodesBCH2023[OpcodesBCH2023["OP_2DUP"] = 110] = "OP_2DUP";
    OpcodesBCH2023[OpcodesBCH2023["OP_3DUP"] = 111] = "OP_3DUP";
    OpcodesBCH2023[OpcodesBCH2023["OP_2OVER"] = 112] = "OP_2OVER";
    OpcodesBCH2023[OpcodesBCH2023["OP_2ROT"] = 113] = "OP_2ROT";
    OpcodesBCH2023[OpcodesBCH2023["OP_2SWAP"] = 114] = "OP_2SWAP";
    OpcodesBCH2023[OpcodesBCH2023["OP_IFDUP"] = 115] = "OP_IFDUP";
    OpcodesBCH2023[OpcodesBCH2023["OP_DEPTH"] = 116] = "OP_DEPTH";
    OpcodesBCH2023[OpcodesBCH2023["OP_DROP"] = 117] = "OP_DROP";
    OpcodesBCH2023[OpcodesBCH2023["OP_DUP"] = 118] = "OP_DUP";
    OpcodesBCH2023[OpcodesBCH2023["OP_NIP"] = 119] = "OP_NIP";
    OpcodesBCH2023[OpcodesBCH2023["OP_OVER"] = 120] = "OP_OVER";
    OpcodesBCH2023[OpcodesBCH2023["OP_PICK"] = 121] = "OP_PICK";
    OpcodesBCH2023[OpcodesBCH2023["OP_ROLL"] = 122] = "OP_ROLL";
    OpcodesBCH2023[OpcodesBCH2023["OP_ROT"] = 123] = "OP_ROT";
    OpcodesBCH2023[OpcodesBCH2023["OP_SWAP"] = 124] = "OP_SWAP";
    OpcodesBCH2023[OpcodesBCH2023["OP_TUCK"] = 125] = "OP_TUCK";
    OpcodesBCH2023[OpcodesBCH2023["OP_CAT"] = 126] = "OP_CAT";
    OpcodesBCH2023[OpcodesBCH2023["OP_SPLIT"] = 127] = "OP_SPLIT";
    OpcodesBCH2023[OpcodesBCH2023["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
    OpcodesBCH2023[OpcodesBCH2023["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
    OpcodesBCH2023[OpcodesBCH2023["OP_SIZE"] = 130] = "OP_SIZE";
    OpcodesBCH2023[OpcodesBCH2023["OP_INVERT"] = 131] = "OP_INVERT";
    OpcodesBCH2023[OpcodesBCH2023["OP_AND"] = 132] = "OP_AND";
    OpcodesBCH2023[OpcodesBCH2023["OP_OR"] = 133] = "OP_OR";
    OpcodesBCH2023[OpcodesBCH2023["OP_XOR"] = 134] = "OP_XOR";
    OpcodesBCH2023[OpcodesBCH2023["OP_EQUAL"] = 135] = "OP_EQUAL";
    OpcodesBCH2023[OpcodesBCH2023["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_RESERVED1"] = 137] = "OP_RESERVED1";
    OpcodesBCH2023[OpcodesBCH2023["OP_RESERVED2"] = 138] = "OP_RESERVED2";
    OpcodesBCH2023[OpcodesBCH2023["OP_1ADD"] = 139] = "OP_1ADD";
    OpcodesBCH2023[OpcodesBCH2023["OP_1SUB"] = 140] = "OP_1SUB";
    OpcodesBCH2023[OpcodesBCH2023["OP_2MUL"] = 141] = "OP_2MUL";
    OpcodesBCH2023[OpcodesBCH2023["OP_2DIV"] = 142] = "OP_2DIV";
    OpcodesBCH2023[OpcodesBCH2023["OP_NEGATE"] = 143] = "OP_NEGATE";
    OpcodesBCH2023[OpcodesBCH2023["OP_ABS"] = 144] = "OP_ABS";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOT"] = 145] = "OP_NOT";
    OpcodesBCH2023[OpcodesBCH2023["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
    OpcodesBCH2023[OpcodesBCH2023["OP_ADD"] = 147] = "OP_ADD";
    OpcodesBCH2023[OpcodesBCH2023["OP_SUB"] = 148] = "OP_SUB";
    OpcodesBCH2023[OpcodesBCH2023["OP_MUL"] = 149] = "OP_MUL";
    OpcodesBCH2023[OpcodesBCH2023["OP_DIV"] = 150] = "OP_DIV";
    OpcodesBCH2023[OpcodesBCH2023["OP_MOD"] = 151] = "OP_MOD";
    OpcodesBCH2023[OpcodesBCH2023["OP_LSHIFT"] = 152] = "OP_LSHIFT";
    OpcodesBCH2023[OpcodesBCH2023["OP_RSHIFT"] = 153] = "OP_RSHIFT";
    OpcodesBCH2023[OpcodesBCH2023["OP_BOOLAND"] = 154] = "OP_BOOLAND";
    OpcodesBCH2023[OpcodesBCH2023["OP_BOOLOR"] = 155] = "OP_BOOLOR";
    OpcodesBCH2023[OpcodesBCH2023["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
    OpcodesBCH2023[OpcodesBCH2023["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
    OpcodesBCH2023[OpcodesBCH2023["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
    OpcodesBCH2023[OpcodesBCH2023["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
    OpcodesBCH2023[OpcodesBCH2023["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
    OpcodesBCH2023[OpcodesBCH2023["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
    OpcodesBCH2023[OpcodesBCH2023["OP_MIN"] = 163] = "OP_MIN";
    OpcodesBCH2023[OpcodesBCH2023["OP_MAX"] = 164] = "OP_MAX";
    OpcodesBCH2023[OpcodesBCH2023["OP_WITHIN"] = 165] = "OP_WITHIN";
    OpcodesBCH2023[OpcodesBCH2023["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
    OpcodesBCH2023[OpcodesBCH2023["OP_SHA1"] = 167] = "OP_SHA1";
    OpcodesBCH2023[OpcodesBCH2023["OP_SHA256"] = 168] = "OP_SHA256";
    OpcodesBCH2023[OpcodesBCH2023["OP_HASH160"] = 169] = "OP_HASH160";
    OpcodesBCH2023[OpcodesBCH2023["OP_HASH256"] = 170] = "OP_HASH256";
    OpcodesBCH2023[OpcodesBCH2023["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP1"] = 176] = "OP_NOP1";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP4"] = 179] = "OP_NOP4";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP5"] = 180] = "OP_NOP5";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP6"] = 181] = "OP_NOP6";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP7"] = 182] = "OP_NOP7";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP8"] = 183] = "OP_NOP8";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP9"] = 184] = "OP_NOP9";
    OpcodesBCH2023[OpcodesBCH2023["OP_NOP10"] = 185] = "OP_NOP10";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
    OpcodesBCH2023[OpcodesBCH2023["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
    OpcodesBCH2023[OpcodesBCH2023["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
    /**
     * First codepoint left undefined before nullary introspection operations.
     */
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
    /**
     * Last codepoint left undefined before nullary introspection operations.
     */
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
    OpcodesBCH2023[OpcodesBCH2023["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
    OpcodesBCH2023[OpcodesBCH2023["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
    OpcodesBCH2023[OpcodesBCH2023["OP_TXVERSION"] = 194] = "OP_TXVERSION";
    OpcodesBCH2023[OpcodesBCH2023["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
    OpcodesBCH2023[OpcodesBCH2023["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
    OpcodesBCH2023[OpcodesBCH2023["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
    OpcodesBCH2023[OpcodesBCH2023["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
    OpcodesBCH2023[OpcodesBCH2023["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
    OpcodesBCH2023[OpcodesBCH2023["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
    OpcodesBCH2023[OpcodesBCH2023["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
    OpcodesBCH2023[OpcodesBCH2023["OP_UTXOTOKENCATEGORY"] = 206] = "OP_UTXOTOKENCATEGORY";
    OpcodesBCH2023[OpcodesBCH2023["OP_UTXOTOKENCOMMITMENT"] = 207] = "OP_UTXOTOKENCOMMITMENT";
    OpcodesBCH2023[OpcodesBCH2023["OP_UTXOTOKENAMOUNT"] = 208] = "OP_UTXOTOKENAMOUNT";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTTOKENCATEGORY"] = 209] = "OP_OUTPUTTOKENCATEGORY";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTTOKENCOMMITMENT"] = 210] = "OP_OUTPUTTOKENCOMMITMENT";
    OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTTOKENAMOUNT"] = 211] = "OP_OUTPUTTOKENAMOUNT";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
    /**
     * A.K.A. `OP_PREFIX_BEGIN`
     */
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
    /**
     * A.K.A. `OP_PREFIX_END`
     */
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
    OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH2023 || (OpcodesBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
const OpcodesBCH = OpcodesBCH2023;
// eslint-disable-next-line @typescript-eslint/naming-convention
const Opcodes = OpcodesBCH;

/**
 *  `OpcodesBTC` currently represents the `BTC_2017_08` instruction set.
 */
var OpcodesBTC;
(function (OpcodesBTC) {
    OpcodesBTC[OpcodesBTC["OP_0"] = 0] = "OP_0";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
    OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
    OpcodesBTC[OpcodesBTC["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    OpcodesBTC[OpcodesBTC["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    OpcodesBTC[OpcodesBTC["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
    OpcodesBTC[OpcodesBTC["OP_1NEGATE"] = 79] = "OP_1NEGATE";
    OpcodesBTC[OpcodesBTC["OP_RESERVED"] = 80] = "OP_RESERVED";
    OpcodesBTC[OpcodesBTC["OP_1"] = 81] = "OP_1";
    OpcodesBTC[OpcodesBTC["OP_2"] = 82] = "OP_2";
    OpcodesBTC[OpcodesBTC["OP_3"] = 83] = "OP_3";
    OpcodesBTC[OpcodesBTC["OP_4"] = 84] = "OP_4";
    OpcodesBTC[OpcodesBTC["OP_5"] = 85] = "OP_5";
    OpcodesBTC[OpcodesBTC["OP_6"] = 86] = "OP_6";
    OpcodesBTC[OpcodesBTC["OP_7"] = 87] = "OP_7";
    OpcodesBTC[OpcodesBTC["OP_8"] = 88] = "OP_8";
    OpcodesBTC[OpcodesBTC["OP_9"] = 89] = "OP_9";
    OpcodesBTC[OpcodesBTC["OP_10"] = 90] = "OP_10";
    OpcodesBTC[OpcodesBTC["OP_11"] = 91] = "OP_11";
    OpcodesBTC[OpcodesBTC["OP_12"] = 92] = "OP_12";
    OpcodesBTC[OpcodesBTC["OP_13"] = 93] = "OP_13";
    OpcodesBTC[OpcodesBTC["OP_14"] = 94] = "OP_14";
    OpcodesBTC[OpcodesBTC["OP_15"] = 95] = "OP_15";
    OpcodesBTC[OpcodesBTC["OP_16"] = 96] = "OP_16";
    OpcodesBTC[OpcodesBTC["OP_NOP"] = 97] = "OP_NOP";
    OpcodesBTC[OpcodesBTC["OP_VER"] = 98] = "OP_VER";
    OpcodesBTC[OpcodesBTC["OP_IF"] = 99] = "OP_IF";
    OpcodesBTC[OpcodesBTC["OP_NOTIF"] = 100] = "OP_NOTIF";
    OpcodesBTC[OpcodesBTC["OP_VERIF"] = 101] = "OP_VERIF";
    OpcodesBTC[OpcodesBTC["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
    OpcodesBTC[OpcodesBTC["OP_ELSE"] = 103] = "OP_ELSE";
    OpcodesBTC[OpcodesBTC["OP_ENDIF"] = 104] = "OP_ENDIF";
    OpcodesBTC[OpcodesBTC["OP_VERIFY"] = 105] = "OP_VERIFY";
    OpcodesBTC[OpcodesBTC["OP_RETURN"] = 106] = "OP_RETURN";
    OpcodesBTC[OpcodesBTC["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
    OpcodesBTC[OpcodesBTC["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
    OpcodesBTC[OpcodesBTC["OP_2DROP"] = 109] = "OP_2DROP";
    OpcodesBTC[OpcodesBTC["OP_2DUP"] = 110] = "OP_2DUP";
    OpcodesBTC[OpcodesBTC["OP_3DUP"] = 111] = "OP_3DUP";
    OpcodesBTC[OpcodesBTC["OP_2OVER"] = 112] = "OP_2OVER";
    OpcodesBTC[OpcodesBTC["OP_2ROT"] = 113] = "OP_2ROT";
    OpcodesBTC[OpcodesBTC["OP_2SWAP"] = 114] = "OP_2SWAP";
    OpcodesBTC[OpcodesBTC["OP_IFDUP"] = 115] = "OP_IFDUP";
    OpcodesBTC[OpcodesBTC["OP_DEPTH"] = 116] = "OP_DEPTH";
    OpcodesBTC[OpcodesBTC["OP_DROP"] = 117] = "OP_DROP";
    OpcodesBTC[OpcodesBTC["OP_DUP"] = 118] = "OP_DUP";
    OpcodesBTC[OpcodesBTC["OP_NIP"] = 119] = "OP_NIP";
    OpcodesBTC[OpcodesBTC["OP_OVER"] = 120] = "OP_OVER";
    OpcodesBTC[OpcodesBTC["OP_PICK"] = 121] = "OP_PICK";
    OpcodesBTC[OpcodesBTC["OP_ROLL"] = 122] = "OP_ROLL";
    OpcodesBTC[OpcodesBTC["OP_ROT"] = 123] = "OP_ROT";
    OpcodesBTC[OpcodesBTC["OP_SWAP"] = 124] = "OP_SWAP";
    OpcodesBTC[OpcodesBTC["OP_TUCK"] = 125] = "OP_TUCK";
    OpcodesBTC[OpcodesBTC["OP_CAT"] = 126] = "OP_CAT";
    OpcodesBTC[OpcodesBTC["OP_SUBSTR"] = 127] = "OP_SUBSTR";
    OpcodesBTC[OpcodesBTC["OP_LEFT"] = 128] = "OP_LEFT";
    OpcodesBTC[OpcodesBTC["OP_RIGHT"] = 129] = "OP_RIGHT";
    OpcodesBTC[OpcodesBTC["OP_SIZE"] = 130] = "OP_SIZE";
    OpcodesBTC[OpcodesBTC["OP_INVERT"] = 131] = "OP_INVERT";
    OpcodesBTC[OpcodesBTC["OP_AND"] = 132] = "OP_AND";
    OpcodesBTC[OpcodesBTC["OP_OR"] = 133] = "OP_OR";
    OpcodesBTC[OpcodesBTC["OP_XOR"] = 134] = "OP_XOR";
    OpcodesBTC[OpcodesBTC["OP_EQUAL"] = 135] = "OP_EQUAL";
    OpcodesBTC[OpcodesBTC["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
    OpcodesBTC[OpcodesBTC["OP_RESERVED1"] = 137] = "OP_RESERVED1";
    OpcodesBTC[OpcodesBTC["OP_RESERVED2"] = 138] = "OP_RESERVED2";
    OpcodesBTC[OpcodesBTC["OP_1ADD"] = 139] = "OP_1ADD";
    OpcodesBTC[OpcodesBTC["OP_1SUB"] = 140] = "OP_1SUB";
    OpcodesBTC[OpcodesBTC["OP_2MUL"] = 141] = "OP_2MUL";
    OpcodesBTC[OpcodesBTC["OP_2DIV"] = 142] = "OP_2DIV";
    OpcodesBTC[OpcodesBTC["OP_NEGATE"] = 143] = "OP_NEGATE";
    OpcodesBTC[OpcodesBTC["OP_ABS"] = 144] = "OP_ABS";
    OpcodesBTC[OpcodesBTC["OP_NOT"] = 145] = "OP_NOT";
    OpcodesBTC[OpcodesBTC["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
    OpcodesBTC[OpcodesBTC["OP_ADD"] = 147] = "OP_ADD";
    OpcodesBTC[OpcodesBTC["OP_SUB"] = 148] = "OP_SUB";
    OpcodesBTC[OpcodesBTC["OP_MUL"] = 149] = "OP_MUL";
    OpcodesBTC[OpcodesBTC["OP_DIV"] = 150] = "OP_DIV";
    OpcodesBTC[OpcodesBTC["OP_MOD"] = 151] = "OP_MOD";
    OpcodesBTC[OpcodesBTC["OP_LSHIFT"] = 152] = "OP_LSHIFT";
    OpcodesBTC[OpcodesBTC["OP_RSHIFT"] = 153] = "OP_RSHIFT";
    OpcodesBTC[OpcodesBTC["OP_BOOLAND"] = 154] = "OP_BOOLAND";
    OpcodesBTC[OpcodesBTC["OP_BOOLOR"] = 155] = "OP_BOOLOR";
    OpcodesBTC[OpcodesBTC["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
    OpcodesBTC[OpcodesBTC["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
    OpcodesBTC[OpcodesBTC["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
    OpcodesBTC[OpcodesBTC["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
    OpcodesBTC[OpcodesBTC["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
    OpcodesBTC[OpcodesBTC["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
    OpcodesBTC[OpcodesBTC["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
    OpcodesBTC[OpcodesBTC["OP_MIN"] = 163] = "OP_MIN";
    OpcodesBTC[OpcodesBTC["OP_MAX"] = 164] = "OP_MAX";
    OpcodesBTC[OpcodesBTC["OP_WITHIN"] = 165] = "OP_WITHIN";
    OpcodesBTC[OpcodesBTC["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
    OpcodesBTC[OpcodesBTC["OP_SHA1"] = 167] = "OP_SHA1";
    OpcodesBTC[OpcodesBTC["OP_SHA256"] = 168] = "OP_SHA256";
    OpcodesBTC[OpcodesBTC["OP_HASH160"] = 169] = "OP_HASH160";
    OpcodesBTC[OpcodesBTC["OP_HASH256"] = 170] = "OP_HASH256";
    OpcodesBTC[OpcodesBTC["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
    OpcodesBTC[OpcodesBTC["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
    OpcodesBTC[OpcodesBTC["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
    OpcodesBTC[OpcodesBTC["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
    OpcodesBTC[OpcodesBTC["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
    OpcodesBTC[OpcodesBTC["OP_NOP1"] = 176] = "OP_NOP1";
    OpcodesBTC[OpcodesBTC["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
    OpcodesBTC[OpcodesBTC["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
    OpcodesBTC[OpcodesBTC["OP_NOP4"] = 179] = "OP_NOP4";
    OpcodesBTC[OpcodesBTC["OP_NOP5"] = 180] = "OP_NOP5";
    OpcodesBTC[OpcodesBTC["OP_NOP6"] = 181] = "OP_NOP6";
    OpcodesBTC[OpcodesBTC["OP_NOP7"] = 182] = "OP_NOP7";
    OpcodesBTC[OpcodesBTC["OP_NOP8"] = 183] = "OP_NOP8";
    OpcodesBTC[OpcodesBTC["OP_NOP9"] = 184] = "OP_NOP9";
    OpcodesBTC[OpcodesBTC["OP_NOP10"] = 185] = "OP_NOP10";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN186"] = 186] = "OP_UNKNOWN186";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN187"] = 187] = "OP_UNKNOWN187";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN188"] = 188] = "OP_UNKNOWN188";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
    /**
     * Used internally in the C++ implementation.
     */
    OpcodesBTC[OpcodesBTC["OP_SMALLINTEGER"] = 250] = "OP_SMALLINTEGER";
    /**
     * Used internally in the C++ implementation.
     */
    OpcodesBTC[OpcodesBTC["OP_PUBKEYS"] = 251] = "OP_PUBKEYS";
    OpcodesBTC[OpcodesBTC["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
    /**
     * Used internally in the C++ implementation.
     */
    OpcodesBTC[OpcodesBTC["OP_PUBKEYHASH"] = 253] = "OP_PUBKEYHASH";
    /**
     * Used internally in the C++ implementation.
     */
    OpcodesBTC[OpcodesBTC["OP_PUBKEY"] = 254] = "OP_PUBKEY";
    /**
     * Used internally in the C++ implementation.
     */
    OpcodesBTC[OpcodesBTC["OP_INVALIDOPCODE"] = 255] = "OP_INVALIDOPCODE";
})(OpcodesBTC || (OpcodesBTC = {}));

/**
 * A type-guard that checks if the provided instruction is malformed.
 * @param instruction - the instruction to check
 */
const authenticationInstructionIsMalformed = (instruction) => 'malformed' in instruction;
/**
 * A type-guard that checks if the final instruction in the provided array of
 * instructions is malformed. (Only the final instruction can be malformed.)
 * @param instructions - the array of instructions to check
 */
const authenticationInstructionsAreMalformed = (instructions) => instructions.length > 0 &&
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
const authenticationInstructionsArePushInstructions = (instructions) => instructions.every((instruction) => 'data' in instruction);
const uint8Bytes = 1;
const uint16Bytes = 2;
const uint32Bytes = 4;
/**
 * Read a little endian number of `length` from the provided
 * {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading
 * @param length - the length of the little endian number to read
 */
const readLittleEndianNumber = (position, length) => {
    const view = new DataView(position.bin.buffer, position.index, length);
    const readAsLittleEndian = true;
    return length === uint8Bytes
        ? view.getUint8(0)
        : length === uint16Bytes
            ? view.getUint16(0, readAsLittleEndian)
            : view.getUint32(0, readAsLittleEndian);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode - an opcode between 0x00 and 0xff
 */
const opcodeToPushLength = (opcode) => ({
    [76 /* CommonPushOpcodes.OP_PUSHDATA_1 */]: uint8Bytes,
    [77 /* CommonPushOpcodes.OP_PUSHDATA_2 */]: uint16Bytes,
    [78 /* CommonPushOpcodes.OP_PUSHDATA_4 */]: uint32Bytes,
})[opcode] ?? 0;
/**
 * Decode one virtual machine bytecode instruction from the
 * provided {@link ReadPosition}.
 *
 * Returns an object with an `instruction` referencing a
 * {@link AuthenticationInstructionMaybeMalformed} and the next position.
 *
 * If the next index is greater than or equal to the length of the bytecode, the
 * bytecode has been fully decoded.
 *
 * The final {@link AuthenticationInstructionMaybeMalformed} in the bytecode may
 * be malformed if 1) the final operation is a push and 2) too few bytes remain
 * for the push operation to complete.
 *
 * @param position - the {@link ReadPosition} at which to start reading
 */
// eslint-disable-next-line complexity
const readAuthenticationInstruction = (position) => {
    const { bin, index } = position;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const opcode = bin[index];
    if (opcode > 78 /* CommonPushOpcodes.OP_PUSHDATA_4 */) {
        return {
            instruction: { opcode },
            position: { bin, index: index + 1 },
        };
    }
    const lengthBytes = opcodeToPushLength(opcode);
    if (lengthBytes !== 0 && index + lengthBytes >= bin.length) {
        const sliceStart = index + 1;
        const sliceEnd = sliceStart + lengthBytes;
        return {
            instruction: {
                expectedLengthBytes: lengthBytes,
                length: bin.slice(sliceStart, sliceEnd),
                malformed: true,
                opcode,
            },
            position: { bin, index: sliceEnd },
        };
    }
    const dataBytes = lengthBytes === 0
        ? opcode
        : readLittleEndianNumber({ bin, index: index + 1 }, lengthBytes);
    const dataStart = index + 1 + lengthBytes;
    const dataEnd = dataStart + dataBytes;
    return {
        instruction: {
            data: bin.slice(dataStart, dataEnd),
            ...(dataEnd > bin.length
                ? { expectedDataBytes: dataEnd - dataStart, malformed: true }
                : undefined),
            opcode,
        },
        position: { bin, index: dataEnd },
    };
};
/**
 * @param instruction - the {@link AuthenticationInstruction} to clone.
 * @returns A copy of the provided {@link AuthenticationInstruction}.
 *
 * @deprecated use `structuredClone` instead
 */
const cloneAuthenticationInstruction = (instruction) => ({
    ...('data' in instruction ? { data: instruction.data } : {}),
    opcode: instruction.opcode,
});
/**
 * Decode authentication virtual machine bytecode (`lockingBytecode` or
 * `unlockingBytecode`) into {@link AuthenticationInstructionsMaybeMalformed}.
 * The method {@link authenticationInstructionsAreMalformed} can be used to
 * check if these instructions include a malformed instruction. If not, they are
 * valid {@link AuthenticationInstructions}.
 *
 * @param bytecode - the authentication virtual machine bytecode to decode
 */
const decodeAuthenticationInstructions = (bytecode) => {
    const instructions = [];
    // eslint-disable-next-line functional/no-let
    let i = 0;
    // eslint-disable-next-line functional/no-loop-statements
    while (i < bytecode.length) {
        const { instruction, position } = readAuthenticationInstruction({
            bin: bytecode,
            index: i,
        });
        // eslint-disable-next-line functional/no-expression-statements
        i = position.index;
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        instructions.push(instruction);
    }
    return instructions;
};
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */
const isMultiWordPush = (opcode) => opcode !== 0 /* CommonPushOpcodes.OP_0 */;
const formatAsmPushHex = (data) => data.length > 0 ? `0x${binToHex(data)}` : '';
const formatMissingBytesAsm = (missing) => `[missing ${missing} byte${missing === 1 ? '' : 's'}]`;
const hasMalformedLength = (instruction) => 'length' in instruction;
const isPushData = (pushOpcode) => pushOpcode >= 76 /* CommonPushOpcodes.OP_PUSHDATA_1 */;
/**
 * Disassemble a malformed authentication instruction into a string description.
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the {@link AuthenticationInstructionMalformed} to
 * disassemble
 */
const disassembleAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode] ?? 'OP_UNKNOWN'} ${hasMalformedLength(instruction)
    ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}`
    : `${isPushData(instruction.opcode)
        ? `${instruction.expectedDataBytes} `
        : ''}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
/**
 * Disassemble a properly-formed authentication instruction into a string
 * description.
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the instruction to disassemble
 */
const disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode] ?? 'OP_UNKNOWN'}${'data' in instruction && isMultiWordPush(instruction.opcode)
    ? ` ${isPushData(instruction.opcode) ? `${instruction.data.length} ` : ''}${formatAsmPushHex(instruction.data)}`
    : ''}`;
/**
 * Disassemble a single {@link AuthenticationInstructionMaybeMalformed} into its
 * ASM representation.
 *
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the instruction to disassemble
 */
const disassembleAuthenticationInstructionMaybeMalformed = (opcodes, instruction) => authenticationInstructionIsMalformed(instruction)
    ? disassembleAuthenticationInstructionMalformed(opcodes, instruction)
    : disassembleAuthenticationInstruction(opcodes, instruction);
/**
 * Disassemble an array of {@link AuthenticationInstructionMaybeMalformed}
 * (including potentially malformed instructions) into its ASM representation.
 *
 * This method supports disassembling an array including multiple
 * {@link AuthenticationInstructionMaybeMalformed}s, rather than the more
 * constrained {@link AuthenticationInstructionsMaybeMalformed} (may only
 * include one malformed instruction as the last item in the array).
 *
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instructions - the array of instructions to disassemble
 */
const disassembleAuthenticationInstructionsMaybeMalformed = (opcodes, instructions) => instructions
    .map((instruction) => disassembleAuthenticationInstructionMaybeMalformed(opcodes, instruction))
    .join(' ');
/**
 * Disassemble authentication bytecode into a lossless ASM representation. (All
 * push operations are represented with the same opcodes used in the bytecode,
 * even when non-minimally encoded.)
 *
 * For the reverse, see {@link assembleBytecode}.
 *
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param bytecode - the authentication bytecode to disassemble
 */
const disassembleBytecode = (opcodes, bytecode) => disassembleAuthenticationInstructionsMaybeMalformed(opcodes, decodeAuthenticationInstructions(bytecode));
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 *
 * Note, this method automatically uses the latest BCH instruction set. To
 * manually select an instruction set, use {@link disassembleBytecode}.
 *
 * For the reverse, see {@link assembleBytecodeBCH}.
 *
 * @param bytecode - the virtual machine bytecode to disassemble
 */
const disassembleBytecodeBCH = (bytecode) => disassembleAuthenticationInstructionsMaybeMalformed(OpcodesBCH, decodeAuthenticationInstructions(bytecode));
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 *
 * Note, this method automatically uses the latest BTC instruction set. To
 * manually select an instruction set, use {@link disassembleBytecode}.
 *
 * For the reverse, see {@link assembleBytecodeBTC}.
 *
 * @param bytecode - the virtual machine bytecode to disassemble
 */
const disassembleBytecodeBTC = (bytecode) => disassembleAuthenticationInstructionsMaybeMalformed(OpcodesBTC, decodeAuthenticationInstructions(bytecode));
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes - An opcode enum, e.g. {@link OpcodesBCH}
 */
const generateBytecodeMap = (opcodes) => Object.entries(opcodes)
    .filter((entry) => typeof entry[1] === 'number')
    .reduce((identifiers, pair) => ({
    ...identifiers,
    [pair[0]]: Uint8Array.of(pair[1]),
}), {});
const getInstructionLengthBytes = (instruction) => {
    const { opcode } = instruction;
    const expectedLength = opcodeToPushLength(opcode);
    return expectedLength === uint8Bytes
        ? Uint8Array.of(instruction.data.length)
        : expectedLength === uint16Bytes
            ? numberToBinUint16LE(instruction.data.length)
            : numberToBinUint32LE(instruction.data.length);
};
/**
 * Re-encode a valid authentication instruction.
 * @param instruction - the instruction to encode
 */
const encodeAuthenticationInstruction = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...('data' in instruction
        ? [
            ...(isPushData(instruction.opcode)
                ? getInstructionLengthBytes(instruction)
                : []),
            ...instruction.data,
        ]
        : []),
]);
/**
 * Re-encode a malformed authentication instruction.
 * @param instruction - the {@link AuthenticationInstructionMalformed} to encode
 */
const encodeAuthenticationInstructionMalformed = (instruction) => {
    const { opcode } = instruction;
    if (hasMalformedLength(instruction)) {
        return Uint8Array.from([opcode, ...instruction.length]);
    }
    if (isPushData(opcode)) {
        return Uint8Array.from([
            opcode,
            ...(opcode === 76 /* CommonPushOpcodes.OP_PUSHDATA_1 */
                ? Uint8Array.of(instruction.expectedDataBytes)
                : opcode === 77 /* CommonPushOpcodes.OP_PUSHDATA_2 */
                    ? numberToBinUint16LE(instruction.expectedDataBytes)
                    : numberToBinUint32LE(instruction.expectedDataBytes)),
            ...instruction.data,
        ]);
    }
    return Uint8Array.from([opcode, ...instruction.data]);
};
/**
 * Re-encode a potentially-malformed authentication instruction.
 * @param instruction - the {@link AuthenticationInstructionMaybeMalformed}
 * to encode
 */
const encodeAuthenticationInstructionMaybeMalformed = (instruction) => authenticationInstructionIsMalformed(instruction)
    ? encodeAuthenticationInstructionMalformed(instruction)
    : encodeAuthenticationInstruction(instruction);
/**
 * Re-encode an array of valid authentication instructions.
 * @param instructions - the array of valid instructions to encode
 */
const encodeAuthenticationInstructions = (instructions) => flattenBinArray(instructions.map(encodeAuthenticationInstruction));
/**
 * Re-encode an array of potentially-malformed authentication instructions.
 * @param instructions - the array of
 * {@link AuthenticationInstructionMaybeMalformed}s to encode
 */
const encodeAuthenticationInstructionsMaybeMalformed = (instructions) => flattenBinArray(instructions.map(encodeAuthenticationInstructionMaybeMalformed));
var VmNumberError;
(function (VmNumberError) {
    VmNumberError["outOfRange"] = "Failed to decode VM Number: overflows VM Number range.";
    VmNumberError["requiresMinimal"] = "Failed to decode VM Number: the number is not minimally-encoded.";
})(VmNumberError || (VmNumberError = {}));
const isVmNumberError = (value) => value === VmNumberError.outOfRange || value === VmNumberError.requiresMinimal;
const typicalMaximumVmNumberByteLength$1 = 8;
/**
 * This method attempts to decode a VM Number, a format in which numeric values
 * are represented on the stack. (The Satoshi implementation calls this
 * `CScriptNum`.)
 *
 * If `bytes` is a valid VM Number, this method returns the represented number
 * in BigInt format. If `bytes` is not valid, a {@link VmNumberError}
 * is returned.
 *
 * All common operations accepting numeric parameters or pushing numeric values
 * to the stack currently use the VM Number format. The binary format of numbers
 * wouldn't be important if they could only be operated on by arithmetic
 * operators, but since the results of these operations may become input to
 * other operations (e.g. hashing), the specific representation is consensus-
 * critical.
 *
 * For the reverse, see {@link bigIntToVmNumber}.
 *
 * @param bytes - a Uint8Array from the stack
 */
// eslint-disable-next-line complexity
const vmNumberToBigInt = (bytes, { maximumVmNumberByteLength = typicalMaximumVmNumberByteLength$1, requireMinimalEncoding = true, } = {
    maximumVmNumberByteLength: typicalMaximumVmNumberByteLength$1,
    requireMinimalEncoding: true,
}) => {
    if (bytes.length === 0) {
        return 0n;
    }
    if (bytes.length > maximumVmNumberByteLength) {
        return VmNumberError.outOfRange;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const mostSignificantByte = bytes[bytes.length - 1];
    const secondMostSignificantByte = bytes[bytes.length - 1 - 1];
    const allButTheSignBit = 127;
    const justTheSignBit = 128;
    if (requireMinimalEncoding &&
        // eslint-disable-next-line no-bitwise
        (mostSignificantByte & allButTheSignBit) === 0 &&
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
        (bytes.length <= 1 || (secondMostSignificantByte & justTheSignBit) === 0)) {
        return VmNumberError.requiresMinimal;
    }
    const bitsPerByte = 8;
    const signFlippingByte = 0x80;
    // eslint-disable-next-line functional/no-let
    let result = 0n;
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let byte = 0; byte < bytes.length; byte++) {
        // eslint-disable-next-line functional/no-expression-statements,  no-bitwise, @typescript-eslint/no-non-null-assertion
        result |= BigInt(bytes[byte]) << BigInt(byte * bitsPerByte);
    }
    /* eslint-disable no-bitwise */
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const isNegative = (bytes[bytes.length - 1] & signFlippingByte) !== 0;
    return isNegative
        ? -(result &
            ~(BigInt(signFlippingByte) << BigInt(bitsPerByte * (bytes.length - 1))))
        : result;
    /* eslint-enable no-bitwise */
};
/**
 * Convert a BigInt into the VM Number format. See {@link vmNumberToBigInt} for
 * more information.
 *
 * For the reverse, use {@link vmNumberToBigInt}.
 *
 * @param integer - the BigInt to encode as a VM Number
 */
// eslint-disable-next-line complexity
const bigIntToVmNumber = (integer) => {
    if (integer === 0n) {
        return new Uint8Array();
    }
    const bytes = [];
    const isNegative = integer < 0;
    const byteStates = 0xff;
    const bitsPerByte = 8;
    // eslint-disable-next-line functional/no-let
    let remaining = isNegative ? -integer : integer;
    // eslint-disable-next-line functional/no-loop-statements
    while (remaining > 0) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data, no-bitwise
        bytes.push(Number(remaining & BigInt(byteStates)));
        // eslint-disable-next-line functional/no-expression-statements, no-bitwise
        remaining >>= BigInt(bitsPerByte);
    }
    const signFlippingByte = 0x80;
    // eslint-disable-next-line no-bitwise, functional/no-conditional-statements, @typescript-eslint/no-non-null-assertion
    if ((bytes[bytes.length - 1] & signFlippingByte) > 0) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        bytes.push(isNegative ? signFlippingByte : 0x00);
        // eslint-disable-next-line functional/no-conditional-statements
    }
    else if (isNegative) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data, no-bitwise
        bytes[bytes.length - 1] |= signFlippingByte;
    }
    return new Uint8Array(bytes);
};
/**
 * Returns true if the provided stack item is "truthy" in the sense required
 * by several operations (anything but zero and "negative zero").
 *
 * The Satoshi implementation calls this method `CastToBool`.
 *
 * To cast a boolean value to a stack item (VM number),
 * use {@link booleanToVmNumber}.
 *
 * @param item - the stack item to check for truthiness
 */
const stackItemIsTruthy = (item) => {
    const signFlippingByte = 0x80;
    // eslint-disable-next-line functional/no-let, functional/no-loop-statements, no-plusplus
    for (let i = 0; i < item.length; i++) {
        if (item[i] !== 0) {
            if (i === item.length - 1 && item[i] === signFlippingByte) {
                return false;
            }
            return true;
        }
    }
    return false;
};
/**
 * Convert a boolean into VM Number format (the type used to express
 * boolean values emitted by several operations).
 *
 * For the less-strict inverse used by the VM, see {@link stackItemIsTruthy}.
 *
 * @param value - the boolean value to convert
 */
const booleanToVmNumber = (value) => value ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n);
/**
 * From C++ implementation:
 * Note that IsPushOnly() *does* consider OP_RESERVED to be a push-type
 * opcode, however execution of OP_RESERVED fails, so it's not relevant to
 * P2SH/BIP62 as the scriptSig would fail prior to the P2SH special
 * validation code being executed.
 */
const isPushOperation = (opcode) => opcode <= 96 /* Opcodes.OP_16 */;
const isPushOnly = (bytecode) => {
    const instructions = decodeAuthenticationInstructions(bytecode);
    return instructions.every((instruction) => isPushOperation(instruction.opcode));
};
const isPushOnlyAccurate = (bytecode) => {
    const instructions = decodeAuthenticationInstructions(bytecode);
    return (!authenticationInstructionsAreMalformed(instructions) &&
        authenticationInstructionsArePushInstructions(instructions));
};
/**
 * Test if the provided locking bytecode is an arbitrary data output (A.K.A.
 * `TX_NULL_DATA`, "data carrier", or OP_RETURN output).
 * @param lockingBytecode - the locking bytecode to test
 */
const isArbitraryDataOutput = (lockingBytecode) => lockingBytecode.length >= 1 &&
    lockingBytecode[0] === 106 /* Opcodes.OP_RETURN */ &&
    isPushOnly(lockingBytecode.slice(1));
/**
 * Given a number of bytes and a fee rate in satoshis-per-kilobyte, return the
 * minimum required fee. This calculation is important for standardness in dust
 * threshold calculation.
 *
 * @param length - the number of bytes for which the fee is to be paid
 * @param feeRateSatsPerKb - the fee rate in satoshis per 1000 bytes
 */
const getMinimumFee = (length, feeRateSatsPerKb) => {
    if (length < 1n)
        return 0n;
    const truncated = (length * feeRateSatsPerKb) / BigInt(1000 /* Dust.bytesPerKb */);
    return truncated === 0n ? 1n : truncated;
};
/**
 * Given an encoded output length, return the minimum output value in satoshis
 * required to exceed the dust threshold. See {@link getDustThreshold}
 * for details.
 *
 * Most applications should instead use {@link getDustThreshold} to ensure
 * proper encoding and proper treatment of arbitrary data outputs
 * ({@link isArbitraryDataOutput}).
 *
 * @param outputLength - the length of the serialized output
 * @param dustRelayFeeSatPerKb - the "dust relay fee", defaults to `1000n`
 */
const getDustThresholdForLength = (outputLength, dustRelayFeeSatPerKb = BigInt(1000 /* Dust.standardDustRelayFee */)) => {
    const expectedTotalLength = outputLength + 148 /* Dust.p2pkhInputLength */;
    return (BigInt(3 /* Dust.minimumFeeMultiple */) *
        getMinimumFee(BigInt(expectedTotalLength), dustRelayFeeSatPerKb));
};
/**
 * Given an {@link Output} and (optionally) a dust relay fee in
 * satoshis-per-kilobyte, return the minimum satoshi value for this output to
 * not be considered a "dust output". **For nodes to relay or mine a transaction
 * with this output, the output must have a satoshi value greater than or equal
 * to this threshold.**
 *
 * By standardness, if an output is expected to cost more than 1/3 of it's value
 * in fees to spend, it is considered dust. When calculating the expected fee,
 * the input size is assumed to be (at least) the size of a typical P2PKH input
 * spent using a 72-byte ECDSA signature, 148 bytes:
 * - Outpoint transaction hash: 32 bytes
 * - Outpoint index: 4 bytes
 * - Unlocking bytecode length: 1 byte
 * - Push of 72-byte ECDSA signature: 72 + 1 byte
 * - Push of public key: 33 + 1 byte
 * - Sequence number: 4 bytes
 *
 * The encoded length of the serialized output is added to 148 bytes, and the
 * dust threshold for the output is 3 times the minimum fee for the total bytes.
 * For a P2PKH output (34 bytes) and the standard 1000 sat/Kb dust relay fee,
 * this results in a dust limit of `546` satoshis (`(34+148)*3*1000/1000`).
 *
 * Note, arbitrary data outputs are not required to meet the dust limit as
 * they are provably unspendable and can be pruned from the UTXO set.
 *
 * @param output - the output to test
 * @param dustRelayFeeSatPerKb - the "dust relay fee", defaults to `1000n`
 */
const getDustThreshold = (output, dustRelayFeeSatPerKb = BigInt(1000 /* Dust.standardDustRelayFee */)) => {
    if (isArbitraryDataOutput(output.lockingBytecode)) {
        return 0n;
    }
    const encodedOutputLength = encodeTransactionOutput(output).length;
    return getDustThresholdForLength(encodedOutputLength, dustRelayFeeSatPerKb);
};
/**
 * Given an {@link Output} and (optionally) a dust relay fee in
 * satoshis-per-kilobyte, return `true` if the provided output is considered
 * a "dust output", or `false` otherwise.
 *
 * @param output - the output to test
 * @param dustRelayFeeSatPerKb - the "dust relay fee", defaults to `1000n`
 */
const isDustOutput = (output, dustRelayFeeSatPerKb = BigInt(1000 /* Dust.standardDustRelayFee */)) => output.valueSatoshis < getDustThreshold(output, dustRelayFeeSatPerKb);
const isValidUncompressedPublicKeyEncoding = (publicKey) => publicKey.length === 65 /* PublicKey.uncompressedByteLength */ &&
    publicKey[0] === 4 /* PublicKey.uncompressedHeaderByte */;
const isValidCompressedPublicKeyEncoding = (publicKey) => publicKey.length === 33 /* PublicKey.compressedByteLength */ &&
    (publicKey[0] === 2 /* PublicKey.compressedHeaderByteEven */ ||
        publicKey[0] === 3 /* PublicKey.compressedHeaderByteOdd */);
const isValidPublicKeyEncoding = (publicKey) => isValidCompressedPublicKeyEncoding(publicKey) ||
    isValidUncompressedPublicKeyEncoding(publicKey);
// eslint-disable-next-line complexity
const pushNumberOpcodeToNumber = (opcode) => {
    if (opcode === 0 /* Opcodes.OP_0 */) {
        return 0;
    }
    if (opcode === 79 /* Opcodes.OP_1NEGATE */) {
        return -1;
    }
    if (!Number.isInteger(opcode) ||
        opcode < 81 /* Opcodes.OP_1 */ ||
        opcode > 96 /* Opcodes.OP_16 */) {
        return false;
    }
    return opcode - 80 /* Opcodes.OP_RESERVED */;
};
// eslint-disable-next-line complexity
const isSimpleMultisig = (lockingBytecode) => {
    const instructions = decodeAuthenticationInstructions(lockingBytecode);
    if (authenticationInstructionsAreMalformed(instructions)) {
        return false;
    }
    const lastIndex = instructions.length - 1;
    if (instructions.length < 4 /* Multisig.minimumInstructions */ ||
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        instructions[lastIndex].opcode !== 174 /* Opcodes.OP_CHECKMULTISIG */) {
        return false;
    }
    /**
     * The required count of signers (the `m` in `m-of-n`).
     */
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const m = pushNumberOpcodeToNumber(instructions[0].opcode);
    /**
     * The total count of signers (the `n` in `m-of-n`).
     */
    const n = pushNumberOpcodeToNumber(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    instructions[lastIndex - 1].opcode);
    if (n === false || m === false) {
        return false;
    }
    const publicKeyInstructions = instructions.slice(1 /* Multisig.keyStart */, -2 /* Multisig.keyEnd */);
    if (!authenticationInstructionsArePushInstructions(publicKeyInstructions)) {
        return false;
    }
    const publicKeys = publicKeyInstructions.map((instruction) => instruction.data);
    if (publicKeys.some((key) => !isValidPublicKeyEncoding(key))) {
        return false;
    }
    return { m, n, publicKeys };
};
// eslint-disable-next-line complexity
const isStandardMultisig = (lockingBytecode) => {
    const multisigProperties = isSimpleMultisig(lockingBytecode);
    if (multisigProperties === false) {
        return false;
    }
    const { m, n } = multisigProperties;
    if (n < 1 || n > 3 /* Multisig.maximumStandardN */ || m < 1 || m > n) {
        return false;
    }
    return true;
};
const isStandardOutputBytecode = (lockingBytecode) => isPayToPublicKeyHash(lockingBytecode) ||
    isPayToScriptHash20(lockingBytecode) ||
    isPayToPublicKey(lockingBytecode) ||
    isArbitraryDataOutput(lockingBytecode) ||
    isStandardMultisig(lockingBytecode);
// eslint-disable-next-line complexity
const isStandardOutputBytecode2023 = (lockingBytecode) => isPayToPublicKeyHash(lockingBytecode) ||
    isPayToScriptHash20(lockingBytecode) ||
    isPayToScriptHash32(lockingBytecode) ||
    isPayToPublicKey(lockingBytecode) ||
    isArbitraryDataOutput(lockingBytecode) ||
    isStandardMultisig(lockingBytecode);
/**
 * Test a stack item for the SegWit Recovery Rules activated in `BCH_2019_05`.
 *
 * @param bytecode - the stack item to test
 */
// eslint-disable-next-line complexity
const isWitnessProgram = (bytecode) => {
    const correctLength = bytecode.length >= 4 /* SegWit.minimumLength */ &&
        bytecode.length <= 42 /* SegWit.maximumLength */;
    const validVersionPush = bytecode[0] === 0 /* SegWit.OP_0 */ ||
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (bytecode[0] >= 81 /* SegWit.OP_1 */ && bytecode[0] <= 96 /* SegWit.OP_16 */);
    const correctLengthByte = 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    bytecode[1] + 2 /* SegWit.versionAndLengthBytes */ === bytecode.length;
    return correctLength && validVersionPush && correctLengthByte;
};

const incrementOperationCount = (operation) => (state) => {
    const nextState = operation(state);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    nextState.operationCount += 1;
    return nextState;
};
const conditionallyEvaluate = (operation) => (state) => state.controlStack.every((item) => item) ? operation(state) : state;
/**
 * Map a function over each operation in an {@link InstructionSet.operations}
 * object, assigning the result to the same `opcode` in the resulting object.
 * @param operationMap - an operations map from an {@link InstructionSet}
 * @param combinators - a list of functions to apply (in order) to
 * each operation
 */
const mapOverOperations = (combinators, operationMap) => Object.keys(operationMap).reduce((result, opcode) => ({
    ...result,
    [opcode]: combinators.reduce((op, combinator) => combinator(op), 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operationMap[Number(opcode)]),
}), {});
/**
 * Pop one stack item off of `state.stack` and provide that item to `operation`.
 */
const useOneStackItem = (state, operation) => {
    // eslint-disable-next-line functional/immutable-data
    const item = state.stack.pop();
    if (item === undefined) {
        return applyError(state, AuthenticationErrorCommon.emptyStack);
    }
    return operation(state, [item]);
};
const useTwoStackItems = (state, operation) => useOneStackItem(state, (nextState, [valueTwo]) => useOneStackItem(nextState, (lastState, [valueTop]) => operation(lastState, [valueTop, valueTwo])));
const useThreeStackItems = (state, operation) => useOneStackItem(state, (nextState, [valueThree]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree])));
const useFourStackItems = (state, operation) => useTwoStackItems(state, (nextState, [valueThree, valueFour]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree, valueFour])));
const useSixStackItems = (state, operation) => useFourStackItems(state, (nextState, [valueThree, valueFour, valueFive, valueSix]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [
    valueTop,
    valueTwo,
    valueThree,
    valueFour,
    valueFive,
    valueSix,
])));
const typicalMaximumVmNumberByteLength = 8;
const useOneVmNumber = (state, operation, { maximumVmNumberByteLength = typicalMaximumVmNumberByteLength, requireMinimalEncoding = true, } = {
    maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
    requireMinimalEncoding: true,
}) => useOneStackItem(state, (nextState, [item]) => {
    const value = vmNumberToBigInt(item, {
        maximumVmNumberByteLength,
        requireMinimalEncoding,
    });
    if (isVmNumberError(value)) {
        return applyError(state, AuthenticationErrorCommon.invalidVmNumber);
    }
    return operation(nextState, [value]);
});
const useTwoVmNumbers = (state, operation, { maximumVmNumberByteLength = typicalMaximumVmNumberByteLength, requireMinimalEncoding = true, } = {
    maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
    requireMinimalEncoding: true,
}) => useOneVmNumber(state, (nextState, [secondValue]) => useOneVmNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue]), {
    maximumVmNumberByteLength,
    requireMinimalEncoding,
}), {
    maximumVmNumberByteLength,
    requireMinimalEncoding,
});
const useThreeVmNumbers = (state, operation, { maximumVmNumberByteLength = typicalMaximumVmNumberByteLength, requireMinimalEncoding = true, } = {
    maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
    requireMinimalEncoding: true,
}) => useTwoVmNumbers(state, (nextState, [secondValue, thirdValue]) => useOneVmNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue, thirdValue]), {
    maximumVmNumberByteLength,
    requireMinimalEncoding,
}), {
    maximumVmNumberByteLength,
    requireMinimalEncoding,
});
/**
 * Return the provided state with the provided value pushed to its stack.
 * @param state - the state to update and return
 * @param data - the value to push to the stack
 */
const pushToStack = (state, 
// eslint-disable-next-line functional/functional-parameters
...data) => {
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.stack.push(...data);
    return state;
};
/**
 * If the provided item exceeds the maximum stack item length, apply an error.
 * Otherwise, return the provided state with the item pushed to its stack.
 * @param state - the state to update and return
 * @param item - the value to push to the stack
 */
const pushToStackChecked = (state, item, maximumLength = ConsensusCommon.maximumStackItemLength) => {
    if (item.length > maximumLength) {
        return applyError(state, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${item.length} bytes.`);
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.stack.push(item);
    return state;
};
/**
 * Return the provided state with the VM number pushed to its stack.
 * @param state - the state to update and return
 * @param vmNumber - the number to push to the stack
 */
const pushToStackVmNumber = (state, vmNumber) => pushToStack(state, bigIntToVmNumber(vmNumber));
/**
 * If the provided number is outside the VM number range, apply an error.
 * Otherwise, return the provided state with the VM number pushed to its stack.
 * @param state - the state to update and return
 * @param vmNumber - the VM number to push to the stack
 */
const pushToStackVmNumberChecked = (state, vmNumber, { minVmNumber = BigInt(ConsensusCommon.minVmNumber), maxVmNumber = BigInt(ConsensusCommon.maxVmNumber), } = {}) => {
    if (vmNumber > maxVmNumber || vmNumber < minVmNumber) {
        return applyError(state, AuthenticationErrorCommon.overflowsVmNumberRange);
    }
    return pushToStackVmNumber(state, vmNumber);
};
const combineOperations = (firstOperation, secondOperation) => (state) => secondOperation(firstOperation(state));

const opVerify = (state) => useOneStackItem(state, (nextState, [item]) => stackItemIsTruthy(item)
    ? nextState
    : applyError(nextState, AuthenticationErrorCommon.failedVerify));
const reservedOperation = (state) => applyError(state, AuthenticationErrorCommon.calledReserved);
const opReturn = (state) => applyError(state, AuthenticationErrorCommon.calledReturn);
const opIf = (state) => {
    if (state.controlStack.every((item) => item)) {
        return useOneStackItem(state, (nextState, [item]) => {
            // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
            nextState.controlStack.push(stackItemIsTruthy(item));
            return state;
        });
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.controlStack.push(false);
    return state;
};
/**
 * Note, `OP_NOTIF` is not completely equivalent to `OP_NOT OP_IF`. `OP_NOT`
 * operates on a VM Number (as the inverse of `OP_0NOTEQUAL`), while `OP_NOTIF`
 * checks the "truthy-ness" of a stack item like `OP_IF`.
 */
const opNotIf = (state) => {
    if (state.controlStack.every((item) => item)) {
        return useOneStackItem(state, (nextState, [item]) => {
            // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
            nextState.controlStack.push(!stackItemIsTruthy(item));
            return state;
        });
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.controlStack.push(false);
    return state;
};
const opEndIf = (state) => {
    // eslint-disable-next-line functional/immutable-data
    const element = state.controlStack.pop();
    if (element === undefined) {
        return applyError(state, AuthenticationErrorCommon.unexpectedEndIf);
    }
    return state;
};
const opElse = (state) => {
    const top = state.controlStack[state.controlStack.length - 1];
    if (top === undefined) {
        return applyError(state, AuthenticationErrorCommon.unexpectedElse);
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.controlStack[state.controlStack.length - 1] = !top;
    return state;
};

const op1Add = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStackVmNumberChecked(nextState, value + 1n));
const op1Sub = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value - 1n)));
const opNegate = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(-value)));
const opAbs = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value < 0 ? -value : value)));
const opNot = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n)));
const op0NotEqual = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(0n) : bigIntToVmNumber(1n)));
const opAdd = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStackVmNumberChecked(nextState, firstValue + secondValue));
const opSub = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue - secondValue)));
const opBoolAnd = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n && secondValue !== 0n)));
const opBoolOr = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n || secondValue !== 0n)));
const opNumEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue === secondValue)));
const opNumEqualVerify = combineOperations(opNumEqual, opVerify);
const opNumNotEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== secondValue)));
const opLessThan = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue < secondValue)));
const opLessThanOrEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue <= secondValue)));
const opGreaterThan = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue > secondValue)));
const opGreaterThanOrEqual = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue >= secondValue)));
const opMin = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue < secondValue ? firstValue : secondValue)));
const opMax = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue > secondValue ? firstValue : secondValue)));
const opWithin = (state) => useThreeVmNumbers(state, (nextState, [firstValue, secondValue, thirdValue]) => pushToStack(nextState, booleanToVmNumber(secondValue <= firstValue && firstValue < thirdValue)));
const opMul = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStackVmNumberChecked(nextState, firstValue * secondValue));
const opDiv = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => secondValue === 0n
    ? applyError(nextState, AuthenticationErrorCommon.divisionByZero)
    : pushToStack(nextState, bigIntToVmNumber(firstValue / secondValue)));
const opMod = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => secondValue === 0n
    ? applyError(nextState, AuthenticationErrorCommon.divisionByZero)
    : pushToStack(nextState, bigIntToVmNumber(firstValue % secondValue)));

const opEqual = (state) => useTwoStackItems(state, (nextState, [element1, element2]) => pushToStack(nextState, booleanToVmNumber(binsAreEqual(element1, element2))));
const opEqualVerify = combineOperations(opEqual, opVerify);
const bitwiseOperation = (combine) => (state) => useTwoStackItems(state, (nextState, [a, b]) => a.length === b.length
    ? pushToStack(nextState, combine(a, b))
    : applyError(nextState, AuthenticationErrorCommon.mismatchedBitwiseOperandLength));
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
const opAnd = bitwiseOperation((a, b) => a.map((v, i) => v & b[i]));
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
const opOr = bitwiseOperation((a, b) => a.map((v, i) => v | b[i]));
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
const opXor = bitwiseOperation((a, b) => a.map((v, i) => v ^ b[i]));

const undefinedOperation = conditionallyEvaluate((state) => applyError(state, AuthenticationErrorCommon.unknownOpcode));
const checkLimitsCommon = (operation) => (state) => {
    const nextState = operation(state);
    return nextState.stack.length + nextState.alternateStack.length >
        ConsensusCommon.maximumStackDepth
        ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumStackDepth)
        : nextState.operationCount > ConsensusCommon.maximumOperationCount
            ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumOperationCount)
            : nextState;
};
/**
 * @deprecated use `structuredClone` instead
 */
const cloneStack = (stack) => stack.map((item) => item.slice());
const createAuthenticationProgramStateCommon = ({ program, instructions, stack, }) => ({
    alternateStack: [],
    controlStack: [],
    instructions,
    ip: 0,
    lastCodeSeparator: -1,
    operationCount: 0,
    program,
    signatureOperationsCount: 0,
    signedMessages: [],
    stack,
});
/**
 * @deprecated use `structuredClone` instead
 */
const cloneAuthenticationProgramCommon = (program) => ({
    inputIndex: program.inputIndex,
    sourceOutputs: cloneTransactionOutputsCommon(program.sourceOutputs),
    transaction: cloneTransactionCommon(program.transaction),
});
/**
 * @deprecated use `structuredClone` instead
 */
const cloneAuthenticationProgramStateCommon = (state) => ({
    ...(state.error === undefined ? {} : { error: state.error }),
    alternateStack: cloneStack(state.alternateStack),
    controlStack: state.controlStack.slice(),
    instructions: state.instructions.map(cloneAuthenticationInstruction),
    ip: state.ip,
    lastCodeSeparator: state.lastCodeSeparator,
    operationCount: state.operationCount,
    program: cloneAuthenticationProgramCommon(state.program),
    signatureOperationsCount: state.signatureOperationsCount,
    signedMessages: state.signedMessages.map((item) => ({
        digest: item.digest.slice(),
        ...('serialization' in item
            ? { serialization: item.serialization.slice() }
            : { message: item.message.slice() }),
    })),
    stack: cloneStack(state.stack),
});
/**
 * @deprecated use `structuredClone` instead
 */
const cloneAuthenticationProgramStateBCH = cloneAuthenticationProgramStateCommon;
/**
 * @deprecated use `structuredClone` instead
 */
const cloneAuthenticationProgramState = cloneAuthenticationProgramStateBCH;
const sha256HashLength = 32;
/**
 * This is a meaningless but complete {@link CompilationContextCommon} that uses
 * a default value for each property. This is useful for testing
 * and debugging.
 */
// eslint-disable-next-line complexity
const createCompilationContextCommonTesting = ({ sourceOutputs, inputs, locktime, version, outputs, } = {}) => ({
    inputIndex: 0,
    sourceOutputs: sourceOutputs
        ? sourceOutputs
        : [
            {
                lockingBytecode: Uint8Array.from([]),
                valueSatoshis: 0xffffffffffffffffn,
            },
        ],
    transaction: {
        inputs: inputs
            ? inputs
            : [
                {
                    outpointIndex: 0,
                    outpointTransactionHash: new Uint8Array(sha256HashLength).fill(1),
                    sequenceNumber: 0,
                    unlockingBytecode: undefined,
                },
            ],
        locktime: locktime ?? 0,
        outputs: outputs ?? [
            {
                lockingBytecode: Uint8Array.from([]),
                valueSatoshis: 0xffffffffffffffffn,
            },
        ],
        version: version ?? 0,
    },
});

const isNegative = (value) => 
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
(value & 128 /* Mask.negative */) !== 0;
const hasUnnecessaryPadding = (length, firstByte, secondByte) => length > 1 && firstByte === 0 && !isNegative(secondByte);
const isValidInteger = (signature, tagIndex, length, valueIndex) => signature[tagIndex] === 2 /* ASN1.integerTagType */ &&
    length !== 0 &&
    !isNegative(signature[valueIndex]) &&
    !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
/**
 * Validate a DER-encoded signature.
 *
 * @remarks
 * This function is consensus-critical since BIP66, but differs from the BIP66
 * specification in that it does not validate the existence of a signing
 * serialization type byte at the end of the signature (to support
 * OP_CHECKDATASIG). To validate a bitcoin-encoded signature (including null
 * signatures), use {@link isValidSignatureEncodingBCHTransaction}.
 *
 * @privateRemarks
 * From the Bitcoin ABC C++ implementation:
 *
 * Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
 * total-length: 1-byte length descriptor of everything that follows,
 * excluding the sighash byte.
 * R-length: 1-byte length descriptor of the R value that follows.
 * R: arbitrary-length big-endian encoded R value. It must use the
 * shortest possible encoding for a positive integers (which means no null
 * bytes at the start, except a single one when the next byte has its highest
 * bit set).
 * S-length: 1-byte length descriptor of the S value that follows.
 * S: arbitrary-length big-endian encoded S value. The same rules apply.
 */
// eslint-disable-next-line complexity
const isValidSignatureEncodingDER = (signature) => {
    const correctLengthRange = signature.length > 8 /* DER.minimumLength */ &&
        signature.length < 72 /* DER.maximumLength */;
    const correctSequenceTagType = signature[0 /* DER.sequenceTagIndex */] === 48 /* ASN1.sequenceTagType */;
    const correctSequenceLength = signature[1 /* DER.sequenceLengthIndex */] ===
        signature.length - 2 /* DER.sequenceMetadataBytes */;
    const rLength = signature[3 /* DER.rLengthIndex */];
    if (rLength === undefined) {
        return false;
    }
    const consistentRLength = rLength <= signature.length - 7 /* DER.minimumNonRValueBytes */;
    const rIsValid = isValidInteger(signature, 2 /* DER.rTagIndex */, rLength, 4 /* DER.rValueIndex */);
    const sTagIndex = 4 /* DER.rValueIndex */ + rLength;
    const sLengthIndex = sTagIndex + 1;
    const sLength = signature[sLengthIndex];
    if (sLength === undefined) {
        return false;
    }
    const sValueIndex = sLengthIndex + 1;
    const consistentSLength = sValueIndex + sLength === signature.length;
    const sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
    return (correctLengthRange &&
        correctSequenceTagType &&
        correctSequenceLength &&
        consistentRLength &&
        rIsValid &&
        consistentSLength &&
        sIsValid);
};
/**
 * Validate the encoding of a transaction signature, including a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param transactionSignature - the full transaction signature
 */
const isValidSignatureEncodingBCHTransaction = (transactionSignature, validSigningSerializationTypes) => transactionSignature.length === 0 ||
    (validSigningSerializationTypes.includes(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    transactionSignature[transactionSignature.length - 1]) &&
        (transactionSignature.length ===
            ConsensusCommon.schnorrSignatureLength + 1 ||
            isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1))));
/**
 * Split a bitcoin-encoded signature into a signature and signing serialization
 * type.
 *
 * While a bitcoin-encoded signature only includes a single byte to encode the
 * signing serialization type, a 3-byte forkId can be appended to the signing
 * serialization to provide replay-protection between different forks. (See
 * Bitcoin Cash's Replay Protected Sighash spec for details.)
 *
 * @param encodedSignature - a signature that passes
 * {@link isValidSignatureEncodingBCHTransaction}
 */
const decodeBitcoinSignature = (encodedSignature) => ({
    signature: encodedSignature.slice(0, -1),
    signingSerializationType: encodedSignature.slice(-1),
});

const opRipemd160 = ({ ripemd160: ripemd160$1, } = { ripemd160: ripemd160 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, ripemd160$1.hash(value)));
const opSha1 = ({ sha1: sha1$1, } = { sha1: sha1 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, sha1$1.hash(value)));
const opSha256 = ({ sha256: sha256$1, } = { sha256: sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, sha256$1.hash(value)));
const opHash160 = ({ ripemd160: ripemd160$1, sha256: sha256$1, } = { ripemd160: ripemd160, sha256: sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, ripemd160$1.hash(sha256$1.hash(value))));
const opHash256 = ({ sha256: sha256$1, } = { sha256: sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => pushToStack(nextState, hash256(value, sha256$1)));
const opCodeSeparator = (state) => {
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.lastCodeSeparator = state.ip;
    return state;
};
const opCheckSig = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => (s) => 
// eslint-disable-next-line complexity
useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!isValidPublicKeyEncoding(publicKey)) {
        return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH)) {
        return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization): ${binToHex(bitcoinEncodedSignature)}`);
    }
    const coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha256$1);
    const digest = hash256(serialization, sha256$1);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.signedMessages.push({ digest, serialization });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1$1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0
        ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure)
        : pushToStack(state, booleanToVmNumber(success));
});
// TODO: implement schnorr multisig https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2019-11-15-schnorrmultisig.md
const opCheckMultiSig = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => (s) => useOneVmNumber(s, (state, publicKeysValue) => {
    const potentialPublicKeys = Number(publicKeysValue);
    if (potentialPublicKeys < 0) {
        return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
    }
    if (potentialPublicKeys > 20 /* Multisig.maximumPublicKeys */) {
        return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
    }
    const publicKeys = 
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.operationCount += potentialPublicKeys;
    return state.operationCount > ConsensusCommon.maximumOperationCount
        ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount)
        : useOneVmNumber(state, (nextState, approvingKeys) => {
            const requiredApprovingPublicKeys = Number(approvingKeys);
            if (requiredApprovingPublicKeys < 0) {
                return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
            }
            if (requiredApprovingPublicKeys > potentialPublicKeys) {
                return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
            }
            const signatures = requiredApprovingPublicKeys > 0
                ? // eslint-disable-next-line functional/immutable-data
                    nextState.stack.splice(-requiredApprovingPublicKeys)
                : [];
            return useOneStackItem(nextState, 
            // eslint-disable-next-line complexity
            (finalState, [protocolBugValue]) => {
                if (protocolBugValue.length !== 0) {
                    return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
                }
                const coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
                let approvingPublicKeys = 0; // eslint-disable-line functional/no-let
                let remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
                let remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
                // eslint-disable-next-line functional/no-loop-statements
                while (remainingSignatures > 0 &&
                    remainingPublicKeys > 0 &&
                    approvingPublicKeys + remainingPublicKeys >=
                        remainingSignatures &&
                    approvingPublicKeys !== requiredApprovingPublicKeys) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const publicKey = publicKeys[remainingPublicKeys - 1];
                    const bitcoinEncodedSignature = 
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    signatures[remainingSignatures - 1];
                    if (!isValidPublicKeyEncoding(publicKey)) {
                        return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
                    }
                    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH)) {
                        return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
                    }
                    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
                    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha256$1);
                    const digest = hash256(serialization, sha256$1);
                    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
                    finalState.signedMessages.push({ digest, serialization });
                    if (signature.length ===
                        ConsensusCommon.schnorrSignatureLength) {
                        return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
                    }
                    const signed = secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
                    // eslint-disable-next-line functional/no-conditional-statements
                    if (signed) {
                        approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statements
                        remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statements
                    }
                    remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statements
                }
                const success = approvingPublicKeys === requiredApprovingPublicKeys;
                if (!success &&
                    !signatures.every((signature) => signature.length === 0)) {
                    return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
                }
                return pushToStack(finalState, booleanToVmNumber(success));
            });
        });
});
const opCheckSigVerify = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => combineOperations(opCheckSig({ secp256k1: secp256k1$1, sha256: sha256$1 }), opVerify);
const opCheckMultiSigVerify = ({ secp256k1, sha256, }) => combineOperations(opCheckMultiSig({ secp256k1, sha256 }), opVerify);
/**
 * Validate the encoding of a raw signature – a signature without a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param signature - the raw signature
 */
const isValidSignatureEncodingBCHRaw = (signature) => signature.length === 0 ||
    signature.length === ConsensusCommon.schnorrSignatureLength ||
    isValidSignatureEncodingDER(signature);
const opCheckDataSig = ({ secp256k1, sha256, }) => (state) => 
// eslint-disable-next-line complexity
useThreeStackItems(state, (nextState, [signature, message, publicKey]) => {
    if (!isValidSignatureEncodingBCHRaw(signature)) {
        return applyError(nextState, AuthenticationErrorCommon.invalidSignatureEncoding, `Data signature: ${binToHex(signature)}`);
    }
    if (!isValidPublicKeyEncoding(publicKey)) {
        return applyError(nextState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    const digest = sha256.hash(message);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    nextState.signedMessages.push({ digest, message });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0
        ? applyError(nextState, AuthenticationErrorCommon.nonNullSignatureFailure)
        : pushToStack(nextState, booleanToVmNumber(success));
});
const opCheckDataSigVerify = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => combineOperations(opCheckDataSig({ secp256k1: secp256k1$1, sha256: sha256$1 }), opVerify);
const opReverseBytes = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item.slice().reverse()));

const opCat = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStackChecked(nextState, flattenBinArray([a, b])));
const opSplit = (state) => useOneVmNumber(state, (nextState, value) => {
    const index = Number(value);
    return useOneStackItem(nextState, (finalState, [item]) => index < 0 || index > item.length
        ? applyError(finalState, AuthenticationErrorCommon.invalidSplitIndex)
        : pushToStack(finalState, item.slice(0, index), item.slice(index)));
});
/**
 * Pad a minimally-encoded VM number for `OP_NUM2BIN`.
 */
const padMinimallyEncodedVmNumber = (vmNumber, length) => {
    // eslint-disable-next-line functional/no-let
    let signBit = 0 /* Constants.positiveSign */;
    // eslint-disable-next-line functional/no-conditional-statements
    if (vmNumber.length > 0) {
        // eslint-disable-next-line functional/no-expression-statements, no-bitwise, @typescript-eslint/no-non-null-assertion
        signBit = vmNumber[vmNumber.length - 1] & 128 /* Constants.negativeSign */;
        // eslint-disable-next-line functional/no-expression-statements, no-bitwise, functional/immutable-data
        vmNumber[vmNumber.length - 1] &= 128 /* Constants.negativeSign */ - 1;
    }
    const result = Array.from(vmNumber);
    // eslint-disable-next-line functional/no-loop-statements
    while (result.length < length - 1) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        result.push(0);
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    result.push(signBit);
    return Uint8Array.from(result);
};
const opNum2Bin = (state) => useOneVmNumber(state, (nextState, value) => {
    const targetLength = Number(value);
    return targetLength > ConsensusCommon.maximumStackItemLength
        ? applyError(nextState, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${targetLength} bytes.`)
        : useOneVmNumber(nextState, (finalState, [target]) => {
            const minimallyEncoded = bigIntToVmNumber(target);
            return minimallyEncoded.length > targetLength
                ? applyError(finalState, AuthenticationErrorCommon.insufficientLength)
                : minimallyEncoded.length === targetLength
                    ? pushToStack(finalState, minimallyEncoded)
                    : pushToStack(finalState, padMinimallyEncodedVmNumber(minimallyEncoded, targetLength));
        }, {
            maximumVmNumberByteLength: 
            // TODO: is this right?
            ConsensusCommon.maximumStackItemLength,
            requireMinimalEncoding: false,
        });
});
const opBin2Num = (state) => useOneVmNumber(state, (nextState, [target]) => {
    const minimallyEncoded = bigIntToVmNumber(target);
    return minimallyEncoded.length > ConsensusCommon.maximumVmNumberLength
        ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumVmNumberLength)
        : pushToStack(nextState, minimallyEncoded);
}, {
    // TODO: is this right?
    maximumVmNumberByteLength: ConsensusCommon.maximumStackItemLength,
    requireMinimalEncoding: false,
});

const opInputIndex = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.inputIndex));
const opActiveBytecode = (state) => pushToStackChecked(state, encodeAuthenticationInstructions(state.instructions.slice(state.lastCodeSeparator + 1)));
const opTxVersion = (state) => pushToStackVmNumberChecked(state, BigInt(int32UnsignedToSigned(state.program.transaction.version)));
const opTxInputCount = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.transaction.inputs.length));
const opTxOutputCount = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.transaction.outputs.length));
const opTxLocktime = (state) => pushToStackVmNumberChecked(state, BigInt(state.program.transaction.locktime));
const useTransactionUtxo = (state, operation) => useOneVmNumber(state, (nextState, [index]) => {
    const utxo = nextState.program.sourceOutputs[Number(index)];
    if (utxo === undefined) {
        return applyError(nextState, AuthenticationErrorCommon.invalidTransactionUtxoIndex);
    }
    return operation(state, [utxo]);
});
const opUtxoValue = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushToStackVmNumberChecked(nextState, utxo.valueSatoshis));
const opUtxoBytecode = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushToStackChecked(nextState, utxo.lockingBytecode.slice()));
const useTransactionInput = (state, operation) => useOneVmNumber(state, (nextState, [index]) => {
    const input = nextState.program.transaction.inputs[Number(index)];
    if (input === undefined) {
        return applyError(nextState, AuthenticationErrorCommon.invalidTransactionInputIndex);
    }
    return operation(state, [input]);
});
const opOutpointTxHash = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackChecked(nextState, input.outpointTransactionHash.slice().reverse()));
const opOutpointIndex = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackVmNumberChecked(nextState, BigInt(input.outpointIndex)));
const opInputBytecode = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackChecked(nextState, input.unlockingBytecode.slice()));
const opInputSequenceNumber = (state) => useTransactionInput(state, (nextState, [input]) => pushToStackVmNumberChecked(nextState, BigInt(input.sequenceNumber)));
const useTransactionOutput = (state, operation) => useOneVmNumber(state, (nextState, [index]) => {
    const input = nextState.program.transaction.outputs[Number(index)];
    if (input === undefined) {
        return applyError(nextState, AuthenticationErrorCommon.invalidTransactionOutputIndex);
    }
    return operation(state, [input]);
});
const opOutputValue = (state) => useTransactionOutput(state, (nextState, [output]) => pushToStackVmNumberChecked(nextState, output.valueSatoshis));
const opOutputBytecode = (state) => useTransactionOutput(state, (nextState, [output]) => pushToStackChecked(nextState, output.lockingBytecode.slice()));

const opNop = (state) => state;
const opNopDisallowed = (state) => applyError(state, AuthenticationErrorCommon.calledUpgradableNop);
/**
 * "Disabled" operations are explicitly forbidden from occurring anywhere in VM
 * bytecode, even within an unexecuted branch.
 */
const disabledOperation = (state) => applyError(state, AuthenticationErrorCommon.unknownOpcode);

/**
 * Returns the minimal bytecode required to push the provided `data` to the
 * stack.
 *
 * @remarks
 * This method conservatively encodes a `Uint8Array` as a data push. For VM
 * Numbers that can be pushed using a single opcode (-1 through 16), the
 * equivalent bytecode value is returned. Other `data` values will be prefixed
 * with the proper opcode and push length bytes (if necessary) to create the
 * minimal push instruction.
 *
 * Note, while some single-byte VM Number pushes will be minimally-encoded by
 * this method, all larger inputs will be encoded as-is (it cannot be assumed
 * that inputs are intended to be used as VM Numbers). To encode the push of a
 * VM Number, minimally-encode the number before passing it to this
 * method, e.g.:
 * `encodeDataPush(bigIntToVmNumber(decodeVmNumber(nonMinimalNumber)))`.
 *
 * The maximum `bytecode` length that can be encoded for a push in the Bitcoin
 * system is `4294967295` (~4GB). This method assumes a smaller input – if
 * `bytecode` has the potential to be longer, it should be checked (and the
 * error handled) prior to calling this method.
 *
 * @param data - the Uint8Array to push to the stack
 */
// eslint-disable-next-line complexity
const encodeDataPush = (data) => data.length <= 75 /* PushOperationConstants.maximumPushByteOperationSize */
    ? data.length === 0
        ? Uint8Array.of(0)
        : data.length === 1
            ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                data[0] !== 0 && data[0] <= 16 /* PushOperationConstants.pushNumberOpcodes */
                    ? Uint8Array.of(
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    data[0] + 80 /* PushOperationConstants.pushNumberOpcodesOffset */)
                    : data[0] === 129 /* PushOperationConstants.negativeOne */
                        ? Uint8Array.of(79 /* PushOperationConstants.OP_1NEGATE */)
                        : Uint8Array.from([1, ...data])
            : Uint8Array.from([data.length, ...data])
    : data.length <= 255 /* PushOperationConstants.maximumPushData1Size */
        ? Uint8Array.from([
            76 /* PushOperationConstants.OP_PUSHDATA_1 */,
            data.length,
            ...data,
        ])
        : data.length <= 65535 /* PushOperationConstants.maximumPushData2Size */
            ? Uint8Array.from([
                77 /* PushOperationConstants.OP_PUSHDATA_2 */,
                ...numberToBinUint16LE(data.length),
                ...data,
            ])
            : Uint8Array.from([
                78 /* PushOperationConstants.OP_PUSHDATA_4 */,
                ...numberToBinUint32LE(data.length),
                ...data,
            ]);
/**
 * Returns true if the provided `data` is minimally-encoded by the provided
 * `opcode`.
 * @param opcode - the opcode used to push `data`
 * @param data - the contents of the push
 */
// eslint-disable-next-line complexity
const isMinimalDataPush = (opcode, data) => {
    if (data.length === 0) {
        return opcode === 0 /* PushOperationConstants.OP_0 */;
    }
    if (data.length === 1) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (data[0] >= 1 && data[0] <= 16 /* PushOperationConstants.pushNumberOpcodes */) {
            return (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            opcode === data[0] + 80 /* PushOperationConstants.pushNumberOpcodesOffset */);
        }
        if (data[0] === 129 /* PushOperationConstants.negativeOne */) {
            return opcode === 79 /* PushOperationConstants.OP_1NEGATE */;
        }
        return true;
    }
    if (data.length <= 75 /* PushOperationConstants.maximumPushByteOperationSize */) {
        return opcode === data.length;
    }
    if (data.length <= 255 /* PushOperationConstants.maximumPushData1Size */) {
        return opcode === 76 /* PushOperationConstants.OP_PUSHDATA_1 */;
    }
    if (data.length <= 65535 /* PushOperationConstants.maximumPushData2Size */) {
        return opcode === 77 /* PushOperationConstants.OP_PUSHDATA_2 */;
    }
    if (data.length <= 4294967295 /* PushOperationConstants.maximumPushData4Size */) {
        return opcode === 78 /* PushOperationConstants.OP_PUSHDATA_4 */;
    }
    return false;
};
const executionIsActive$1 = (state) => state.controlStack.every((item) => item);
// TODO: add tests that verify the order of operations below (are non-minimal pushes OK inside unexecuted conditionals?)
const pushOperation = (maximumPushSize = ConsensusCommon.maximumStackItemLength) => (state) => {
    const instruction = state.instructions[state.ip];
    return instruction.data.length > maximumPushSize
        ? applyError(state, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${instruction.data.length} bytes.`)
        : executionIsActive$1(state)
            ? isMinimalDataPush(instruction.opcode, instruction.data)
                ? pushToStack(state, instruction.data)
                : applyError(state, AuthenticationErrorCommon.nonMinimalPush)
            : state;
};
/**
 * @param number - the number that is pushed to the stack by this operation.
 * @returns an operation that pushes a number to the stack.
 */
const pushNumberOperation = (number) => {
    const value = bigIntToVmNumber(BigInt(number));
    return (state) => pushToStack(state, value);
};

const opToAltStack = (state) => useOneStackItem(state, (nextState, [item]) => {
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    nextState.alternateStack.push(item);
    return nextState;
});
const opFromAltStack = (state) => {
    // eslint-disable-next-line functional/immutable-data
    const item = state.alternateStack.pop();
    if (item === undefined) {
        return applyError(state, AuthenticationErrorCommon.emptyAlternateStack);
    }
    return pushToStack(state, item);
};
const op2Drop = (state) => useTwoStackItems(state, (nextState) => nextState);
const op2Dup = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, a, b, a.slice(), b.slice()));
const op3Dup = (state) => useThreeStackItems(state, (nextState, [a, b, c]) => pushToStack(nextState, a, b, c, a.slice(), b.slice(), c.slice()));
const op2Over = (state) => useFourStackItems(state, (nextState, [a, b, c, d]) => pushToStack(nextState, a, b, c, d, a.slice(), b.slice()));
const op2Rot = (state) => useSixStackItems(state, (nextState, [a, b, c, d, e, f]) => pushToStack(nextState, c, d, e, f, a, b));
const op2Swap = (state) => useFourStackItems(state, (nextState, [a, b, c, d]) => pushToStack(nextState, c, d, a, b));
const opIfDup = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, ...(stackItemIsTruthy(item) ? [item, item.slice()] : [item])));
const opDepth = (state) => pushToStack(state, bigIntToVmNumber(BigInt(state.stack.length)));
const opDrop = (state) => useOneStackItem(state, (nextState) => nextState);
const opDup = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item, item.slice()));
const opNip = (state) => useTwoStackItems(state, (nextState, [, b]) => pushToStack(nextState, b));
const opOver = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, a, b, a.slice()));
const opPick = (state) => useOneVmNumber(state, (nextState, depth) => {
    const item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
    if (item === undefined) {
        return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    return pushToStack(nextState, item.slice());
});
const opRoll = (state) => useOneVmNumber(state, (nextState, depth) => {
    const index = nextState.stack.length - 1 - Number(depth);
    if (index < 0 || index > nextState.stack.length - 1) {
        return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    // eslint-disable-next-line functional/immutable-data, @typescript-eslint/no-non-null-assertion
    return pushToStack(nextState, nextState.stack.splice(index, 1)[0]);
});
const opRot = (state) => useThreeStackItems(state, (nextState, [a, b, c]) => pushToStack(nextState, b, c, a));
const opSwap = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, b, a));
const opTuck = (state) => useTwoStackItems(state, (nextState, [a, b]) => pushToStack(nextState, b.slice(), a, b));
const opSize = (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item, bigIntToVmNumber(BigInt(item.length))));

const useLocktime = (state, operation) => {
    const item = state.stack[state.stack.length - 1];
    if (item === undefined) {
        return applyError(state, AuthenticationErrorCommon.emptyStack);
    }
    const decodedLocktime = vmNumberToBigInt(item, {
        maximumVmNumberByteLength: 5 /* Constants.locktimeVmNumberByteLength */,
        requireMinimalEncoding: true,
    });
    if (isVmNumberError(decodedLocktime)) {
        return applyError(state, AuthenticationErrorCommon.invalidVmNumber);
    }
    const locktime = Number(decodedLocktime);
    if (locktime < 0) {
        return applyError(state, AuthenticationErrorCommon.negativeLocktime);
    }
    return operation(state, locktime);
};
const locktimeTypesAreCompatible = (locktime, requiredLocktime) => (locktime < 500000000 /* Constants.locktimeThreshold */ &&
    requiredLocktime < 500000000 /* Constants.locktimeThreshold */) ||
    (locktime >= 500000000 /* Constants.locktimeThreshold */ &&
        requiredLocktime >= 500000000 /* Constants.locktimeThreshold */);
const opCheckLockTimeVerify = (state) => useLocktime(state, (nextState, requiredLocktime) => {
    if (!locktimeTypesAreCompatible(nextState.program.transaction.locktime, requiredLocktime)) {
        return applyError(nextState, AuthenticationErrorCommon.incompatibleLocktimeType);
    }
    if (requiredLocktime > nextState.program.transaction.locktime) {
        return applyError(nextState, AuthenticationErrorCommon.unsatisfiedLocktime);
    }
    const { sequenceNumber } = 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    nextState.program.transaction.inputs[nextState.program.inputIndex];
    if (sequenceNumber === 4294967295 /* Constants.locktimeDisablingSequenceNumber */) {
        return applyError(nextState, AuthenticationErrorCommon.locktimeDisabled);
    }
    return nextState;
});
// eslint-disable-next-line no-bitwise
const includesFlag = (value, flag) => (value & flag) !== 0;
const opCheckSequenceVerify = (state) => useLocktime(state, 
// eslint-disable-next-line complexity
(nextState, requiredSequence) => {
    const { sequenceNumber } = 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    nextState.program.transaction.inputs[nextState.program.inputIndex];
    const sequenceLocktimeDisabled = includesFlag(requiredSequence, 2147483648 /* Constants.sequenceLocktimeDisableFlag */);
    if (sequenceLocktimeDisabled) {
        return nextState;
    }
    if (nextState.program.transaction.version <
        2 /* Constants.sequenceLocktimeTransactionVersionMinimum */) {
        return applyError(nextState, AuthenticationErrorCommon.checkSequenceUnavailable);
    }
    if (includesFlag(sequenceNumber, 2147483648 /* Constants.sequenceLocktimeDisableFlag */)) {
        return applyError(nextState, AuthenticationErrorCommon.unmatchedSequenceDisable);
    }
    if (includesFlag(requiredSequence, 4194304 /* Constants.sequenceLocktimeTypeFlag */) !==
        includesFlag(sequenceNumber, 4194304 /* Constants.sequenceLocktimeTypeFlag */)) {
        return applyError(nextState, AuthenticationErrorCommon.incompatibleSequenceType);
    }
    if (
    // eslint-disable-next-line no-bitwise
    (requiredSequence & 65535 /* Constants.sequenceLocktimeMask */) >
        // eslint-disable-next-line no-bitwise
        (sequenceNumber & 65535 /* Constants.sequenceLocktimeMask */)) {
        return applyError(nextState, AuthenticationErrorCommon.unsatisfiedSequenceNumber);
    }
    return nextState;
});

/**
 * Consensus settings for the `BCH_2023_05` instruction set.
 */
var ConsensusBCH2023;
(function (ConsensusBCH2023) {
    /**
     * A.K.A. `MAX_SCRIPT_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
    /**
     * A.K.A. `MAX_OP_RETURN_RELAY`, `nMaxDatacarrierBytes`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumDataCarrierBytes"] = 223] = "maximumDataCarrierBytes";
    /**
     * A.K.A. `MAX_OPS_PER_SCRIPT`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumOperationCount"] = 201] = "maximumOperationCount";
    /**
     * A.K.A. `MAX_STACK_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumStackDepth"] = 1000] = "maximumStackDepth";
    /**
     * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumStackItemLength"] = 520] = "maximumStackItemLength";
    /**
     * A.K.A. `MAX_STANDARD_VERSION`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumStandardVersion"] = 2] = "maximumStandardVersion";
    /**
     * A.K.A. `MAX_TX_IN_SCRIPT_SIG_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumStandardUnlockingBytecodeLength"] = 1650] = "maximumStandardUnlockingBytecodeLength";
    /**
     * Transactions smaller than 65 bytes are forbidden to prevent exploits of the
     * transaction Merkle tree design.
     *
     * A.K.A. `MIN_TX_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["minimumTransactionSize"] = 65] = "minimumTransactionSize";
    /**
     * A.K.A. `MAX_STANDARD_TX_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumStandardTransactionSize"] = 100000] = "maximumStandardTransactionSize";
    /**
     * A.K.A. `MAX_TX_SIZE`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumTransactionSize"] = 1000000] = "maximumTransactionSize";
    /**
     * A.K.A. `MAXIMUM_ELEMENT_SIZE_64_BIT`
     */
    ConsensusBCH2023[ConsensusBCH2023["maximumVmNumberLength"] = 8] = "maximumVmNumberLength";
    // eslint-disable-next-line @typescript-eslint/no-mixed-enums
    ConsensusBCH2023["minVmNumber"] = "-9223372036854775807";
    ConsensusBCH2023["maxVmNumber"] = "9223372036854775807";
    ConsensusBCH2023[ConsensusBCH2023["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
    ConsensusBCH2023[ConsensusBCH2023["maximumCommitmentLength"] = 40] = "maximumCommitmentLength";
})(ConsensusBCH2023 || (ConsensusBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
const SigningSerializationTypesBCH2023 = [
    ...SigningSerializationTypesBCH,
    SigningSerializationTypeBCH.allOutputsAllUtxos,
    SigningSerializationTypeBCH.correspondingOutputAllUtxos,
    SigningSerializationTypeBCH.noOutputsAllUtxos,
];

const opCheckSigBCH2023 = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => (s) => 
// eslint-disable-next-line complexity
useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!isValidPublicKeyEncoding(publicKey)) {
        return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
        return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization): ${binToHex(bitcoinEncodedSignature)}`);
    }
    const coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha256$1);
    const digest = hash256(serialization, sha256$1);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.signedMessages.push({ digest, serialization });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1$1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0
        ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure)
        : pushToStack(state, booleanToVmNumber(success));
});
// TODO: implement schnorr multisig https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2019-11-15-schnorrmultisig.md
const opCheckMultiSigBCH2023 = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => (s) => useOneVmNumber(s, (state, publicKeysValue) => {
    const potentialPublicKeys = Number(publicKeysValue);
    if (potentialPublicKeys < 0) {
        return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
    }
    if (potentialPublicKeys > 20 /* Multisig.maximumPublicKeys */) {
        return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
    }
    const publicKeys = 
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.operationCount += potentialPublicKeys;
    return state.operationCount > ConsensusCommon.maximumOperationCount
        ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount)
        : useOneVmNumber(state, (nextState, approvingKeys) => {
            const requiredApprovingPublicKeys = Number(approvingKeys);
            if (requiredApprovingPublicKeys < 0) {
                return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
            }
            if (requiredApprovingPublicKeys > potentialPublicKeys) {
                return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
            }
            const signatures = requiredApprovingPublicKeys > 0
                ? // eslint-disable-next-line functional/immutable-data
                    nextState.stack.splice(-requiredApprovingPublicKeys)
                : [];
            return useOneStackItem(nextState, 
            // eslint-disable-next-line complexity
            (finalState, [protocolBugValue]) => {
                if (protocolBugValue.length !== 0) {
                    return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
                }
                const coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
                let approvingPublicKeys = 0; // eslint-disable-line functional/no-let
                let remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
                let remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
                // eslint-disable-next-line functional/no-loop-statements
                while (remainingSignatures > 0 &&
                    remainingPublicKeys > 0 &&
                    approvingPublicKeys + remainingPublicKeys >=
                        remainingSignatures &&
                    approvingPublicKeys !== requiredApprovingPublicKeys) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const publicKey = publicKeys[remainingPublicKeys - 1];
                    const bitcoinEncodedSignature = 
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    signatures[remainingSignatures - 1];
                    if (!isValidPublicKeyEncoding(publicKey)) {
                        return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
                    }
                    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
                        return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
                    }
                    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
                    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha256$1);
                    const digest = hash256(serialization, sha256$1);
                    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
                    finalState.signedMessages.push({ digest, serialization });
                    if (signature.length ===
                        ConsensusCommon.schnorrSignatureLength) {
                        return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
                    }
                    const signed = secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
                    // eslint-disable-next-line functional/no-conditional-statements
                    if (signed) {
                        approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statements
                        remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statements
                    }
                    remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statements
                }
                const success = approvingPublicKeys === requiredApprovingPublicKeys;
                if (!success &&
                    !signatures.every((signature) => signature.length === 0)) {
                    return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
                }
                return pushToStack(finalState, booleanToVmNumber(success));
            });
        });
});
const opCheckSigVerifyBCH2023 = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => combineOperations(opCheckSigBCH2023({ secp256k1: secp256k1$1, sha256: sha256$1 }), opVerify);
const opCheckMultiSigVerifyBCH2023 = ({ secp256k1, sha256, }) => combineOperations(opCheckMultiSigBCH2023({ secp256k1, sha256 }), opVerify);

var OpcodeDescriptionsBCH2023;
(function (OpcodeDescriptionsBCH2023) {
    OpcodeDescriptionsBCH2023["OP_0"] = "Push the VM Number 0 onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCH2023["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
    OpcodeDescriptionsBCH2023["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_1"] = "Push a 1 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_2"] = "Push a 2 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_3"] = "Push a 3 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_4"] = "Push a 4 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_5"] = "Push a 5 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_6"] = "Push a 6 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_7"] = "Push a 7 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_8"] = "Push a 8 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_9"] = "Push a 9 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_10"] = "Push a 10 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_11"] = "Push a 11 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_12"] = "Push a 12 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_13"] = "Push a 13 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_14"] = "Push a 14 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_15"] = "Push a 15 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_16"] = "Push a 16 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2023["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
    OpcodeDescriptionsBCH2023["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBCH2023["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBCH2023["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
    OpcodeDescriptionsBCH2023["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
    OpcodeDescriptionsBCH2023["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
    OpcodeDescriptionsBCH2023["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
    OpcodeDescriptionsBCH2023["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
    OpcodeDescriptionsBCH2023["OP_RETURN"] = "Error when executed.";
    OpcodeDescriptionsBCH2023["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
    OpcodeDescriptionsBCH2023["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
    OpcodeDescriptionsBCH2023["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
    OpcodeDescriptionsBCH2023["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
    OpcodeDescriptionsBCH2023["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
    OpcodeDescriptionsBCH2023["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
    OpcodeDescriptionsBCH2023["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
    OpcodeDescriptionsBCH2023["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
    OpcodeDescriptionsBCH2023["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
    OpcodeDescriptionsBCH2023["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
    OpcodeDescriptionsBCH2023["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
    OpcodeDescriptionsBCH2023["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
    OpcodeDescriptionsBCH2023["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
    OpcodeDescriptionsBCH2023["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
    OpcodeDescriptionsBCH2023["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
    OpcodeDescriptionsBCH2023["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
    OpcodeDescriptionsBCH2023["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
    OpcodeDescriptionsBCH2023["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
    OpcodeDescriptionsBCH2023["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
    OpcodeDescriptionsBCH2023["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
    OpcodeDescriptionsBCH2023["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
    OpcodeDescriptionsBCH2023["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
    OpcodeDescriptionsBCH2023["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
    OpcodeDescriptionsBCH2023["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCH2023["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCH2023["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCH2023["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2023["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
    OpcodeDescriptionsBCH2023["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
    OpcodeDescriptionsBCH2023["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
    OpcodeDescriptionsBCH2023["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
    OpcodeDescriptionsBCH2023["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
    OpcodeDescriptionsBCH2023["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
    OpcodeDescriptionsBCH2023["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
    OpcodeDescriptionsBCH2023["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
    OpcodeDescriptionsBCH2023["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
    OpcodeDescriptionsBCH2023["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
    OpcodeDescriptionsBCH2023["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
    OpcodeDescriptionsBCH2023["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
    OpcodeDescriptionsBCH2023["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
    OpcodeDescriptionsBCH2023["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2023["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
    OpcodeDescriptionsBCH2023["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
    OpcodeDescriptionsBCH2023["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
    OpcodeDescriptionsBCH2023["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2023["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2023["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2023["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2023["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2023["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
    OpcodeDescriptionsBCH2023["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2023["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2023["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
    OpcodeDescriptionsBCH2023["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
    OpcodeDescriptionsBCH2023["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2023["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2023["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
    OpcodeDescriptionsBCH2023["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
    OpcodeDescriptionsBCH2023["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
    OpcodeDescriptionsBCH2023["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash \u2013 the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack in OP_HASH256 byte order.";
    OpcodeDescriptionsBCH2023["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index \u2013 the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
    OpcodeDescriptionsBCH2023["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
    OpcodeDescriptionsBCH2023["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
    OpcodeDescriptionsBCH2023["OP_UTXOTOKENCATEGORY"] = "Pop the top item from the stack as an input index (VM Number). If the Unspent Transaction Output (UTXO) spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the UTXO does not include a non-fungible token with a capability, push the UTXO's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_UTXOTOKENCOMMITMENT"] = "Pop the top item from the stack as an input index (VM Number). Push the token commitment of the Unspent Transaction Output (UTXO) spent by that input to the stack. If the UTXO does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_UTXOTOKENAMOUNT"] = "Pop the top item from the stack as an input index (VM Number). Push the fungible token amount of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number. If the UTXO includes no fungible tokens, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_OUTPUTTOKENCATEGORY"] = "Pop the top item from the stack as an output index (VM Number). If the output spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the output does not include a non-fungible token with a capability, push the output's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_OUTPUTTOKENCOMMITMENT"] = "Pop the top item from the stack as an output index (VM Number). Push the token commitment of the output at that index to the stack. If the output does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2023["OP_OUTPUTTOKENAMOUNT"] = "Pop the top item from the stack as an output index (VM Number). Push the fungible token amount of the output at that index to the stack as a VM Number. If the output includes no fungible tokens, push a 0 (VM Number).";
})(OpcodeDescriptionsBCH2023 || (OpcodeDescriptionsBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
const OpcodeDescriptionsBCH = OpcodeDescriptionsBCH2023;
// eslint-disable-next-line @typescript-eslint/naming-convention
const OpcodeDescriptions = OpcodeDescriptionsBCH;

var AuthenticationErrorBCH2023;
(function (AuthenticationErrorBCH2023) {
    AuthenticationErrorBCH2023["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length (8 bytes).";
})(AuthenticationErrorBCH2023 || (AuthenticationErrorBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
const AuthenticationErrorBCH = AuthenticationErrorBCH2023;

/**
 * Given a list of transaction inputs, extract a hex-encoded list of all
 * {@link Input.outpointTransactionHash}es from inputs that spend output `0` of
 * that transaction (i.e. where {@link Input.outpointIndex} is `0`).
 * @param inputs - a list of transaction inputs
 * @returns a hex-encoded list of {@link Input.outpointTransactionHash}es
 */
const extractGenesisCategories = (inputs) => inputs.reduce((agg, input) => input.outpointIndex === 0
    ? [...agg, binToHex(input.outpointTransactionHash)]
    : agg, []);
/**
 * Given the resolved list of a transaction's source outputs – the Unspent
 * Transaction Outputs (UTXOs) spent by the transaction, extract all token data
 * for token-aware validation. See CHIP-2022-02-CashTokens for details.
 * @param sourceOutputs - a list of resolved source outputs (UTXOs)
 * @returns an object containing `availableImmutableTokens`,
 * `availableMutableTokensByCategory`, `availableSumsByCategory`, and
 * `inputMintingCategories`. See CHIP-2022-02-CashTokens for details.
 */
const extractSourceOutputTokenData = (sourceOutputs) => sourceOutputs.reduce(
// eslint-disable-next-line complexity
(agg, sourceOutput) => {
    if (sourceOutput.token === undefined)
        return agg;
    const categoryHex = binToHex(sourceOutput.token.category);
    return {
        availableImmutableTokens: [
            ...agg.availableImmutableTokens,
            ...(sourceOutput.token.nft?.capability === 'none'
                ? [
                    {
                        categoryHex: binToHex(sourceOutput.token.category),
                        commitmentHex: binToHex(sourceOutput.token.nft.commitment),
                    },
                ]
                : []),
        ],
        availableMutableTokensByCategory: sourceOutput.token.nft?.capability === 'mutable'
            ? {
                ...agg.availableMutableTokensByCategory,
                [categoryHex]: (agg.availableMutableTokensByCategory[categoryHex] ?? 0) + 1,
            }
            : agg.availableMutableTokensByCategory,
        availableSumsByCategory: {
            ...agg.availableSumsByCategory,
            [categoryHex]: (agg.availableSumsByCategory[categoryHex] ?? 0n) +
                sourceOutput.token.amount,
        },
        inputMintingCategories: [
            ...agg.inputMintingCategories,
            ...(sourceOutput.token.nft?.capability === 'minting'
                ? [binToHex(sourceOutput.token.category)]
                : []),
        ],
    };
}, {
    availableImmutableTokens: [],
    availableMutableTokensByCategory: {},
    availableSumsByCategory: {},
    inputMintingCategories: [],
});
/**
 * Given a transaction's outputs, extract all token data for token-aware
 * validation. See CHIP-2022-02-CashTokens for details.
 * @param outputs - a list of transaction outputs
 * @returns an object containing `outputImmutableTokens`,
 * `outputMintingCategories`, `outputMutableTokensByCategory`, and
 * `outputSumsByCategory`. See CHIP-2022-02-CashTokens for details.
 */
const extractTransactionOutputTokenData = (outputs) => outputs.reduce(
// eslint-disable-next-line complexity
(agg, output) => {
    if (output.token === undefined)
        return agg;
    const categoryHex = binToHex(output.token.category);
    return {
        outputImmutableTokens: [
            ...agg.outputImmutableTokens,
            ...(output.token.nft?.capability === 'none'
                ? [
                    {
                        categoryHex: binToHex(output.token.category),
                        commitmentHex: binToHex(output.token.nft.commitment),
                    },
                ]
                : []),
        ],
        outputMintingCategories: [
            ...agg.outputMintingCategories,
            ...(output.token.nft?.capability === 'minting'
                ? [binToHex(output.token.category)]
                : []),
        ],
        outputMutableTokensByCategory: output.token.nft?.capability === 'mutable'
            ? {
                ...agg.outputMutableTokensByCategory,
                [categoryHex]: (agg.outputMutableTokensByCategory[categoryHex] ?? 0) + 1,
            }
            : agg.outputMutableTokensByCategory,
        outputSumsByCategory: {
            ...agg.outputSumsByCategory,
            [categoryHex]: (agg.outputSumsByCategory[categoryHex] ?? 0n) + output.token.amount,
        },
    };
}, {
    outputImmutableTokens: [],
    outputMintingCategories: [],
    outputMutableTokensByCategory: {},
    outputSumsByCategory: {},
});
/**
 * Given a transaction and its resolved source outputs – the Unspent Transaction
 * Outputs (UTXOs) it spends – verify that the transaction passes token-aware
 * validation.
 * @param transaction - the transaction to verify
 * @param sourceOutputs - the resolved list of the transaction's source outputs
 * @returns `true` on success, or an error message (string) on failure.
 */
// eslint-disable-next-line complexity
const verifyTransactionTokens = (transaction, sourceOutputs) => {
    const excessiveCommitment = [...sourceOutputs, ...transaction.outputs].find((output) => output.token?.nft?.commitment !== undefined &&
        output.token.nft.commitment.length >
            ConsensusBCH2023.maximumCommitmentLength);
    if (excessiveCommitment !== undefined) {
        return `Transaction violates token validation: a token commitment exceeds the consensus limit of ${ConsensusBCH2023.maximumCommitmentLength} bytes. Excessive token commitment length: ${
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        excessiveCommitment.token.nft.commitment.length}`;
    }
    const genesisCategories = extractGenesisCategories(transaction.inputs);
    const { availableSumsByCategory, availableMutableTokensByCategory, inputMintingCategories, availableImmutableTokens, } = extractSourceOutputTokenData(sourceOutputs);
    const { outputSumsByCategory, outputMutableTokensByCategory, outputMintingCategories, outputImmutableTokens, } = extractTransactionOutputTokenData(transaction.outputs);
    const availableMintingCategories = [
        ...genesisCategories,
        ...inputMintingCategories,
    ];
    const missingMintingCategory = outputMintingCategories.find((category) => !availableMintingCategories.includes(category));
    if (missingMintingCategory !== undefined) {
        return `Transaction violates token validation: the transaction outputs include a minting token that is not substantiated by the transaction's inputs. Invalid output minting token category: ${missingMintingCategory}`;
    }
    // eslint-disable-next-line functional/no-loop-statements
    for (const [categoryHex, sum] of Object.entries(outputSumsByCategory)) {
        if (sum > BigInt(ConsensusBCH2023.maxVmNumber)) {
            return `Transaction violates token validation: the transaction outputs include a sum of fungible tokens for a category exceeding the maximum supply (${ConsensusBCH2023.maxVmNumber}). Category: ${categoryHex}, total amount: ${sum.toString()}.`;
        }
        const availableSum = availableSumsByCategory[categoryHex];
        if (availableSum === undefined &&
            sum > 0 &&
            !genesisCategories.includes(categoryHex)) {
            return `Transaction violates token validation: the transaction creates new fungible tokens for a category without a matching genesis input. Category: ${categoryHex}, tokens created: ${sum}`;
        }
        if (availableSum !== undefined && sum > availableSum) {
            return `Transaction violates token validation: the sum of fungible tokens in the transaction's outputs exceed that of the transactions inputs for a category. Category: ${categoryHex}, input amount: ${availableSum}, output amount: ${sum}`;
        }
    }
    const remainingMutableTokens = Object.entries(outputMutableTokensByCategory).reduce((agg, [categoryHex, sum]) => {
        if (availableMintingCategories.includes(categoryHex)) {
            return agg;
        }
        return { ...agg, [categoryHex]: (agg[categoryHex] ?? 0) - sum };
    }, availableMutableTokensByCategory);
    // eslint-disable-next-line functional/no-loop-statements
    for (const [categoryHex, sum] of Object.entries(remainingMutableTokens)) {
        if (sum < 0) {
            return `Transaction violates token validation: the transaction creates more mutable tokens than are available for a category without a matching minting token. Category: ${categoryHex}, excess mutable tokens: ${0 - sum}`;
        }
    }
    const { unmatchedImmutableTokens } = outputImmutableTokens.reduce((agg, token) => {
        const { categoryHex, commitmentHex } = token;
        if (availableMintingCategories.includes(categoryHex)) {
            return agg;
        }
        const firstMatch = availableImmutableTokens.findIndex((available) => available.categoryHex === categoryHex &&
            available.commitmentHex === commitmentHex);
        if (firstMatch === -1) {
            return {
                availableImmutableTokens: agg.availableImmutableTokens,
                unmatchedImmutableTokens: [...agg.unmatchedImmutableTokens, token],
            };
        }
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        agg.availableImmutableTokens.splice(firstMatch, 1);
        return agg;
    }, {
        availableImmutableTokens,
        unmatchedImmutableTokens: [],
    });
    const requiredMutableTokens = unmatchedImmutableTokens.reduce((agg, token) => ({
        ...agg,
        [token.categoryHex]: (agg[token.categoryHex] ?? 0) + 1,
    }), {});
    // eslint-disable-next-line functional/no-loop-statements
    for (const [categoryHex, required] of Object.entries(requiredMutableTokens)) {
        const available = remainingMutableTokens[categoryHex] ?? 0;
        if (available < required) {
            return `Transaction violates token validation: the transaction creates an immutable token for a category without a matching minting token or sufficient mutable tokens. Category ${categoryHex}, available mutable tokens: ${available}, new immutable tokens: ${required}`;
        }
    }
    return true;
};
const pushTokenExtendedCategory = (state, utxo) => {
    const { token } = utxo;
    if (token === undefined) {
        return pushToStackVmNumber(state, 0n);
    }
    const capabilityByte = token.nft?.capability === 'minting'
        ? [2 /* Constants.mintingCapabilityByte */]
        : token.nft?.capability === 'mutable'
            ? [1 /* Constants.mutableCapabilityByte */]
            : [];
    const extendedCategory = flattenBinArray([
        token.category.slice().reverse(),
        Uint8Array.from(capabilityByte),
    ]);
    return pushToStackChecked(state, extendedCategory);
};
const pushTokenCommitment = (state, utxo) => {
    const { token } = utxo;
    if (token?.nft === undefined) {
        return pushToStackVmNumber(state, 0n);
    }
    return pushToStackChecked(state, token.nft.commitment);
};
const pushTokenAmount = (state, utxo) => {
    const { token } = utxo;
    if (token === undefined) {
        return pushToStackVmNumber(state, 0n);
    }
    return pushToStackVmNumberChecked(state, token.amount);
};
const opUtxoTokenCategory = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushTokenExtendedCategory(nextState, utxo));
const opUtxoTokenCommitment = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushTokenCommitment(nextState, utxo));
const opUtxoTokenAmount = (state) => useTransactionUtxo(state, (nextState, [utxo]) => pushTokenAmount(nextState, utxo));
const opOutputTokenCategory = (state) => useTransactionOutput(state, (nextState, [output]) => pushTokenExtendedCategory(nextState, output));
const opOutputTokenCommitment = (state) => useTransactionOutput(state, (nextState, [output]) => pushTokenCommitment(nextState, output));
const opOutputTokenAmount = (state) => useTransactionOutput(state, (nextState, [output]) => pushTokenAmount(nextState, output));

/**
 * create an instance of the BCH 2023 virtual machine instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createInstructionSetBCH2023 = (standard = true, { ripemd160: ripemd160$1, secp256k1: secp256k1$1, sha1: sha1$1, sha256: sha256$1, } = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha1: sha1,
    sha256: sha256,
}) => {
    const conditionallyPush = pushOperation();
    return {
        clone: cloneAuthenticationProgramStateBCH,
        continue: (state) => state.error === undefined && state.ip < state.instructions.length,
        // eslint-disable-next-line complexity
        evaluate: (program, stateEvaluate) => {
            const { unlockingBytecode } = 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            program.transaction.inputs[program.inputIndex];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const { lockingBytecode } = program.sourceOutputs[program.inputIndex];
            const unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
            const lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
            const initialState = createAuthenticationProgramStateCommon({
                instructions: unlockingInstructions,
                program,
                stack: [],
            });
            if (unlockingBytecode.length > ConsensusBCH2023.maximumBytecodeLength) {
                return applyError(initialState, `The provided unlocking bytecode (${unlockingBytecode.length} bytes) exceeds the maximum bytecode length (${ConsensusBCH2023.maximumBytecodeLength} bytes).`);
            }
            if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
                return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
            }
            if (!isPushOnly(unlockingBytecode)) {
                return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
            }
            if (lockingBytecode.length > ConsensusBCH2023.maximumBytecodeLength) {
                return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
            }
            if (authenticationInstructionsAreMalformed(lockingInstructions)) {
                return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
            }
            const unlockingResult = stateEvaluate(initialState);
            if (unlockingResult.error !== undefined) {
                return unlockingResult;
            }
            if (unlockingResult.controlStack.length !== 0) {
                return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
            }
            const lockingResult = stateEvaluate(createAuthenticationProgramStateCommon({
                instructions: lockingInstructions,
                program,
                stack: unlockingResult.stack,
            }));
            const p2sh20 = isPayToScriptHash20(lockingBytecode);
            const p2sh32 = isPayToScriptHash32(lockingBytecode);
            if (!p2sh20 && !p2sh32) {
                return lockingResult;
            }
            const p2shStack = cloneStack(unlockingResult.stack);
            // eslint-disable-next-line functional/immutable-data
            const p2shScript = p2shStack.pop() ?? Uint8Array.of();
            if (p2sh20 && p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
                return lockingResult;
            }
            const p2shInstructions = decodeAuthenticationInstructions(p2shScript);
            return authenticationInstructionsAreMalformed(p2shInstructions)
                ? {
                    ...lockingResult,
                    error: AuthenticationErrorCommon.malformedP2shBytecode,
                }
                : stateEvaluate(createAuthenticationProgramStateCommon({
                    instructions: p2shInstructions,
                    program,
                    stack: p2shStack,
                }));
        },
        every: (state) => 
        // TODO: implement sigchecks https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2020-05-15-sigchecks.md
        state.stack.length + state.alternateStack.length >
            ConsensusBCH2023.maximumStackDepth
            ? applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth)
            : state.operationCount > ConsensusBCH2023.maximumOperationCount
                ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount)
                : state,
        operations: {
            [OpcodesBCH2023.OP_0]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_1]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_2]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_3]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_4]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_5]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_6]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_7]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_8]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_9]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_10]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_11]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_12]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_13]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_14]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_15]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_16]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_17]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_18]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_19]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_20]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_21]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_22]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_23]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_24]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_25]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_26]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_27]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_28]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_29]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_30]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_31]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_32]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_33]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_34]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_35]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_36]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_37]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_38]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_39]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_40]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_41]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_42]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_43]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_44]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_45]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_46]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_47]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_48]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_49]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_50]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_51]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_52]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_53]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_54]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_55]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_56]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_57]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_58]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_59]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_60]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_61]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_62]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_63]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_64]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_65]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_66]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_67]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_68]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_69]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_70]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_71]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_72]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_73]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_74]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHBYTES_75]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHDATA_1]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHDATA_2]: conditionallyPush,
            [OpcodesBCH2023.OP_PUSHDATA_4]: conditionallyPush,
            [OpcodesBCH2023.OP_1NEGATE]: conditionallyEvaluate(pushNumberOperation(-1)),
            [OpcodesBCH2023.OP_RESERVED]: conditionallyEvaluate(reservedOperation),
            [OpcodesBCH2023.OP_1]: conditionallyEvaluate(pushNumberOperation(1)),
            /* eslint-disable @typescript-eslint/no-magic-numbers */
            [OpcodesBCH2023.OP_2]: conditionallyEvaluate(pushNumberOperation(2)),
            [OpcodesBCH2023.OP_3]: conditionallyEvaluate(pushNumberOperation(3)),
            [OpcodesBCH2023.OP_4]: conditionallyEvaluate(pushNumberOperation(4)),
            [OpcodesBCH2023.OP_5]: conditionallyEvaluate(pushNumberOperation(5)),
            [OpcodesBCH2023.OP_6]: conditionallyEvaluate(pushNumberOperation(6)),
            [OpcodesBCH2023.OP_7]: conditionallyEvaluate(pushNumberOperation(7)),
            [OpcodesBCH2023.OP_8]: conditionallyEvaluate(pushNumberOperation(8)),
            [OpcodesBCH2023.OP_9]: conditionallyEvaluate(pushNumberOperation(9)),
            [OpcodesBCH2023.OP_10]: conditionallyEvaluate(pushNumberOperation(10)),
            [OpcodesBCH2023.OP_11]: conditionallyEvaluate(pushNumberOperation(11)),
            [OpcodesBCH2023.OP_12]: conditionallyEvaluate(pushNumberOperation(12)),
            [OpcodesBCH2023.OP_13]: conditionallyEvaluate(pushNumberOperation(13)),
            [OpcodesBCH2023.OP_14]: conditionallyEvaluate(pushNumberOperation(14)),
            [OpcodesBCH2023.OP_15]: conditionallyEvaluate(pushNumberOperation(15)),
            [OpcodesBCH2023.OP_16]: conditionallyEvaluate(pushNumberOperation(16)),
            /* eslint-enable @typescript-eslint/no-magic-numbers */
            ...mapOverOperations([incrementOperationCount], {
                [OpcodesBCH2023.OP_NOP]: conditionallyEvaluate(opNop),
                [OpcodesBCH2023.OP_VER]: conditionallyEvaluate(reservedOperation),
                [OpcodesBCH2023.OP_IF]: opIf,
                [OpcodesBCH2023.OP_NOTIF]: opNotIf,
                [OpcodesBCH2023.OP_VERIF]: reservedOperation,
                [OpcodesBCH2023.OP_VERNOTIF]: reservedOperation,
                [OpcodesBCH2023.OP_ELSE]: opElse,
                [OpcodesBCH2023.OP_ENDIF]: opEndIf,
                [OpcodesBCH2023.OP_VERIFY]: conditionallyEvaluate(opVerify),
                [OpcodesBCH2023.OP_RETURN]: conditionallyEvaluate(opReturn),
                [OpcodesBCH2023.OP_TOALTSTACK]: conditionallyEvaluate(opToAltStack),
                [OpcodesBCH2023.OP_FROMALTSTACK]: conditionallyEvaluate(opFromAltStack),
                [OpcodesBCH2023.OP_2DROP]: conditionallyEvaluate(op2Drop),
                [OpcodesBCH2023.OP_2DUP]: conditionallyEvaluate(op2Dup),
                [OpcodesBCH2023.OP_3DUP]: conditionallyEvaluate(op3Dup),
                [OpcodesBCH2023.OP_2OVER]: conditionallyEvaluate(op2Over),
                [OpcodesBCH2023.OP_2ROT]: conditionallyEvaluate(op2Rot),
                [OpcodesBCH2023.OP_2SWAP]: conditionallyEvaluate(op2Swap),
                [OpcodesBCH2023.OP_IFDUP]: conditionallyEvaluate(opIfDup),
                [OpcodesBCH2023.OP_DEPTH]: conditionallyEvaluate(opDepth),
                [OpcodesBCH2023.OP_DROP]: conditionallyEvaluate(opDrop),
                [OpcodesBCH2023.OP_DUP]: conditionallyEvaluate(opDup),
                [OpcodesBCH2023.OP_NIP]: conditionallyEvaluate(opNip),
                [OpcodesBCH2023.OP_OVER]: conditionallyEvaluate(opOver),
                [OpcodesBCH2023.OP_PICK]: conditionallyEvaluate(opPick),
                [OpcodesBCH2023.OP_ROLL]: conditionallyEvaluate(opRoll),
                [OpcodesBCH2023.OP_ROT]: conditionallyEvaluate(opRot),
                [OpcodesBCH2023.OP_SWAP]: conditionallyEvaluate(opSwap),
                [OpcodesBCH2023.OP_TUCK]: conditionallyEvaluate(opTuck),
                [OpcodesBCH2023.OP_CAT]: conditionallyEvaluate(opCat),
                [OpcodesBCH2023.OP_SPLIT]: conditionallyEvaluate(opSplit),
                [OpcodesBCH2023.OP_NUM2BIN]: conditionallyEvaluate(opNum2Bin),
                [OpcodesBCH2023.OP_BIN2NUM]: conditionallyEvaluate(opBin2Num),
                [OpcodesBCH2023.OP_SIZE]: conditionallyEvaluate(opSize),
                [OpcodesBCH2023.OP_INVERT]: disabledOperation,
                [OpcodesBCH2023.OP_AND]: conditionallyEvaluate(opAnd),
                [OpcodesBCH2023.OP_OR]: conditionallyEvaluate(opOr),
                [OpcodesBCH2023.OP_XOR]: conditionallyEvaluate(opXor),
                [OpcodesBCH2023.OP_EQUAL]: conditionallyEvaluate(opEqual),
                [OpcodesBCH2023.OP_EQUALVERIFY]: conditionallyEvaluate(opEqualVerify),
                [OpcodesBCH2023.OP_RESERVED1]: conditionallyEvaluate(reservedOperation),
                [OpcodesBCH2023.OP_RESERVED2]: conditionallyEvaluate(reservedOperation),
                [OpcodesBCH2023.OP_1ADD]: conditionallyEvaluate(op1Add),
                [OpcodesBCH2023.OP_1SUB]: conditionallyEvaluate(op1Sub),
                [OpcodesBCH2023.OP_2MUL]: disabledOperation,
                [OpcodesBCH2023.OP_2DIV]: disabledOperation,
                [OpcodesBCH2023.OP_NEGATE]: conditionallyEvaluate(opNegate),
                [OpcodesBCH2023.OP_ABS]: conditionallyEvaluate(opAbs),
                [OpcodesBCH2023.OP_NOT]: conditionallyEvaluate(opNot),
                [OpcodesBCH2023.OP_0NOTEQUAL]: conditionallyEvaluate(op0NotEqual),
                [OpcodesBCH2023.OP_ADD]: conditionallyEvaluate(opAdd),
                [OpcodesBCH2023.OP_SUB]: conditionallyEvaluate(opSub),
                [OpcodesBCH2023.OP_MUL]: conditionallyEvaluate(opMul),
                [OpcodesBCH2023.OP_DIV]: conditionallyEvaluate(opDiv),
                [OpcodesBCH2023.OP_MOD]: conditionallyEvaluate(opMod),
                [OpcodesBCH2023.OP_LSHIFT]: disabledOperation,
                [OpcodesBCH2023.OP_RSHIFT]: disabledOperation,
                [OpcodesBCH2023.OP_BOOLAND]: conditionallyEvaluate(opBoolAnd),
                [OpcodesBCH2023.OP_BOOLOR]: conditionallyEvaluate(opBoolOr),
                [OpcodesBCH2023.OP_NUMEQUAL]: conditionallyEvaluate(opNumEqual),
                [OpcodesBCH2023.OP_NUMEQUALVERIFY]: conditionallyEvaluate(opNumEqualVerify),
                [OpcodesBCH2023.OP_NUMNOTEQUAL]: conditionallyEvaluate(opNumNotEqual),
                [OpcodesBCH2023.OP_LESSTHAN]: conditionallyEvaluate(opLessThan),
                [OpcodesBCH2023.OP_GREATERTHAN]: conditionallyEvaluate(opGreaterThan),
                [OpcodesBCH2023.OP_LESSTHANOREQUAL]: conditionallyEvaluate(opLessThanOrEqual),
                [OpcodesBCH2023.OP_GREATERTHANOREQUAL]: conditionallyEvaluate(opGreaterThanOrEqual),
                [OpcodesBCH2023.OP_MIN]: conditionallyEvaluate(opMin),
                [OpcodesBCH2023.OP_MAX]: conditionallyEvaluate(opMax),
                [OpcodesBCH2023.OP_WITHIN]: conditionallyEvaluate(opWithin),
                [OpcodesBCH2023.OP_RIPEMD160]: conditionallyEvaluate(opRipemd160({ ripemd160: ripemd160$1 })),
                [OpcodesBCH2023.OP_SHA1]: conditionallyEvaluate(opSha1({ sha1: sha1$1 })),
                [OpcodesBCH2023.OP_SHA256]: conditionallyEvaluate(opSha256({ sha256: sha256$1 })),
                [OpcodesBCH2023.OP_HASH160]: conditionallyEvaluate(opHash160({ ripemd160: ripemd160$1, sha256: sha256$1 })),
                [OpcodesBCH2023.OP_HASH256]: conditionallyEvaluate(opHash256({ sha256: sha256$1 })),
                [OpcodesBCH2023.OP_CODESEPARATOR]: conditionallyEvaluate(opCodeSeparator),
                [OpcodesBCH2023.OP_CHECKSIG]: conditionallyEvaluate(opCheckSigBCH2023({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH2023.OP_CHECKSIGVERIFY]: conditionallyEvaluate(opCheckSigVerifyBCH2023({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH2023.OP_CHECKMULTISIG]: conditionallyEvaluate(opCheckMultiSigBCH2023({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH2023.OP_CHECKMULTISIGVERIFY]: conditionallyEvaluate(opCheckMultiSigVerifyBCH2023({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                ...(standard
                    ? {
                        [OpcodesBCH2023.OP_NOP1]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
                        [OpcodesBCH2023.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
                        [OpcodesBCH2023.OP_NOP4]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_NOP5]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_NOP6]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_NOP7]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_NOP8]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_NOP9]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH2023.OP_NOP10]: conditionallyEvaluate(opNopDisallowed),
                    }
                    : {
                        [OpcodesBCH2023.OP_NOP1]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
                        [OpcodesBCH2023.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
                        [OpcodesBCH2023.OP_NOP4]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_NOP5]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_NOP6]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_NOP7]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_NOP8]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_NOP9]: conditionallyEvaluate(opNop),
                        [OpcodesBCH2023.OP_NOP10]: conditionallyEvaluate(opNop),
                    }),
                [OpcodesBCH2023.OP_CHECKDATASIG]: conditionallyEvaluate(opCheckDataSig({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH2023.OP_CHECKDATASIGVERIFY]: conditionallyEvaluate(opCheckDataSigVerify({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH2023.OP_REVERSEBYTES]: conditionallyEvaluate(opReverseBytes),
                [OpcodesBCH2023.OP_INPUTINDEX]: conditionallyEvaluate(opInputIndex),
                [OpcodesBCH2023.OP_ACTIVEBYTECODE]: conditionallyEvaluate(opActiveBytecode),
                [OpcodesBCH2023.OP_TXVERSION]: conditionallyEvaluate(opTxVersion),
                [OpcodesBCH2023.OP_TXINPUTCOUNT]: conditionallyEvaluate(opTxInputCount),
                [OpcodesBCH2023.OP_TXOUTPUTCOUNT]: conditionallyEvaluate(opTxOutputCount),
                [OpcodesBCH2023.OP_TXLOCKTIME]: conditionallyEvaluate(opTxLocktime),
                [OpcodesBCH2023.OP_UTXOVALUE]: conditionallyEvaluate(opUtxoValue),
                [OpcodesBCH2023.OP_UTXOBYTECODE]: conditionallyEvaluate(opUtxoBytecode),
                [OpcodesBCH2023.OP_OUTPOINTTXHASH]: conditionallyEvaluate(opOutpointTxHash),
                [OpcodesBCH2023.OP_OUTPOINTINDEX]: conditionallyEvaluate(opOutpointIndex),
                [OpcodesBCH2023.OP_INPUTBYTECODE]: conditionallyEvaluate(opInputBytecode),
                [OpcodesBCH2023.OP_INPUTSEQUENCENUMBER]: conditionallyEvaluate(opInputSequenceNumber),
                [OpcodesBCH2023.OP_OUTPUTVALUE]: conditionallyEvaluate(opOutputValue),
                [OpcodesBCH2023.OP_OUTPUTBYTECODE]: conditionallyEvaluate(opOutputBytecode),
                [OpcodesBCH2023.OP_UTXOTOKENCATEGORY]: conditionallyEvaluate(opUtxoTokenCategory),
                [OpcodesBCH2023.OP_UTXOTOKENCOMMITMENT]: conditionallyEvaluate(opUtxoTokenCommitment),
                [OpcodesBCH2023.OP_UTXOTOKENAMOUNT]: conditionallyEvaluate(opUtxoTokenAmount),
                [OpcodesBCH2023.OP_OUTPUTTOKENCATEGORY]: conditionallyEvaluate(opOutputTokenCategory),
                [OpcodesBCH2023.OP_OUTPUTTOKENCOMMITMENT]: conditionallyEvaluate(opOutputTokenCommitment),
                [OpcodesBCH2023.OP_OUTPUTTOKENAMOUNT]: conditionallyEvaluate(opOutputTokenAmount),
            }),
        },
        success: (state) => {
            if (state.error !== undefined) {
                return state.error;
            }
            if (state.controlStack.length !== 0) {
                return AuthenticationErrorCommon.nonEmptyControlStack;
            }
            if (state.stack.length !== 1) {
                return AuthenticationErrorCommon.requiresCleanStack;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (!stackItemIsTruthy(state.stack[0])) {
                return AuthenticationErrorCommon.unsuccessfulEvaluation;
            }
            return true;
        },
        undefined: undefinedOperation,
        // eslint-disable-next-line complexity
        verify: ({ sourceOutputs, transaction }, evaluate, stateSuccess) => {
            if (transaction.inputs.length === 0) {
                return 'Transactions must have at least one input.';
            }
            if (transaction.outputs.length === 0) {
                return 'Transactions must have at least one output.';
            }
            if (transaction.inputs.length !== sourceOutputs.length) {
                return 'Unable to verify transaction: a single spent output must be provided for each transaction input.';
            }
            const transactionSize = encodeTransactionBCH(transaction).length;
            if (transactionSize < ConsensusBCH2023.minimumTransactionSize) {
                return `Invalid transaction size: the transaction is ${transactionSize} bytes, but transactions must be no smaller than ${ConsensusBCH2023.minimumTransactionSize} bytes to prevent an exploit of the transaction Merkle tree design.`;
            }
            if (transactionSize > ConsensusBCH2023.maximumTransactionSize) {
                return `Transaction exceeds maximum size: the transaction is ${transactionSize} bytes, but the maximum transaction size is ${ConsensusBCH2023.maximumTransactionSize} bytes.`;
            }
            const inputValue = sourceOutputs.reduce((sum, utxo) => sum + utxo.valueSatoshis, 0n);
            const outputValue = transaction.outputs.reduce((sum, output) => sum + output.valueSatoshis, 0n);
            if (outputValue > inputValue) {
                return `Unable to verify transaction: the sum of transaction outputs exceeds the sum of transaction inputs. Input value: ${inputValue}, output value: ${outputValue}`;
            }
            const outpointList = transaction.inputs.map((input) => `outpointTransactionHash: ${binToHex(input.outpointTransactionHash)}, outpointIndex: ${input.outpointIndex}`);
            const firstDuplicate = outpointList.find((outpoint, index) => outpointList.lastIndexOf(outpoint) !== index);
            /**
             * This check isn't strictly necessary to perform in the VM (assuming the
             * provider of `sourceOutputs` is checking for double spends), but it's
             * included here for debugging purposes.
             */
            if (firstDuplicate !== undefined) {
                return `Unable to verify transaction: the transaction attempts to spend the same outpoint in multiple inputs. ${firstDuplicate}`;
            }
            if (standard) {
                if (transaction.version < 1 ||
                    transaction.version > ConsensusBCH2023.maximumStandardVersion) {
                    return `Standard transactions must have a version no less than 1 and no greater than ${ConsensusBCH2023.maximumStandardVersion}.`;
                }
                if (transactionSize > ConsensusBCH2023.maximumStandardTransactionSize) {
                    return `Transaction exceeds maximum standard size: this transaction is ${transactionSize} bytes, but the maximum standard transaction size is ${ConsensusBCH2023.maximumStandardTransactionSize} bytes.`;
                }
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, output] of sourceOutputs.entries()) {
                    if (!isStandardOutputBytecode2023(output.lockingBytecode)) {
                        return `Standard transactions may only spend standard output types, but source output ${index} is non-standard.`;
                    }
                }
                // eslint-disable-next-line functional/no-let
                let totalArbitraryDataBytes = 0;
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, output] of transaction.outputs.entries()) {
                    if (!isStandardOutputBytecode2023(output.lockingBytecode)) {
                        return `Standard transactions may only create standard output types, but transaction output ${index} is non-standard.`;
                    }
                    // eslint-disable-next-line functional/no-conditional-statements
                    if (isArbitraryDataOutput(output.lockingBytecode)) {
                        // eslint-disable-next-line functional/no-expression-statements
                        totalArbitraryDataBytes += output.lockingBytecode.length + 1;
                    }
                    if (isDustOutput(output)) {
                        return `Standard transactions may not have dust outputs, but transaction output ${index} is a dust output. Output ${index} must have a value of at least ${getDustThreshold(output)} satoshis. Current value: ${output.valueSatoshis}`;
                    }
                }
                if (totalArbitraryDataBytes > ConsensusBCH2023.maximumDataCarrierBytes) {
                    return `Standard transactions may carry no more than ${ConsensusBCH2023.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${totalArbitraryDataBytes} bytes of arbitrary data.`;
                }
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, input] of transaction.inputs.entries()) {
                    if (input.unlockingBytecode.length >
                        ConsensusBCH2023.maximumStandardUnlockingBytecodeLength) {
                        return `Input index ${index} is non-standard: the unlocking bytecode (${input.unlockingBytecode.length} bytes) exceeds the maximum standard unlocking bytecode length (${ConsensusBCH2023.maximumStandardUnlockingBytecodeLength} bytes).`;
                    }
                    if (!isPushOnly(input.unlockingBytecode)) {
                        return `Input index ${index} is non-standard: unlocking bytecode may contain only push operations.`;
                    }
                }
            }
            const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs);
            if (tokenValidationResult !== true) {
                return tokenValidationResult;
            }
            // eslint-disable-next-line functional/no-loop-statements
            for (const index of transaction.inputs.keys()) {
                const state = evaluate({
                    inputIndex: index,
                    sourceOutputs,
                    transaction,
                });
                const result = stateSuccess(state);
                if (typeof result === 'string') {
                    return `Error in evaluating input index ${index}: ${result}`;
                }
            }
            return true;
        },
    };
};
const createInstructionSetBCH = createInstructionSetBCH2023;

/**
 * Create an {@link AuthenticationVirtualMachine} to evaluate authentication
 * programs constructed from operations in the `instructionSet`.
 * @param instructionSet - an {@link InstructionSet}
 */
const createVirtualMachine = (instructionSet) => {
    const availableOpcodes = 256;
    const operators = range(availableOpcodes).map((codepoint) => instructionSet.operations[codepoint] ?? instructionSet.undefined);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const getCodepoint = (state) => state.instructions[state.ip];
    const after = (state) => {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        state.ip += 1;
        return state;
    };
    const getOperation = (state) => 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operators[getCodepoint(state).opcode];
    const noOp = ((state) => state);
    const stateEvery = instructionSet.every ?? noOp;
    const stateStepMutate = (state) => {
        const operator = getOperation(state);
        return after(stateEvery(operator(state)));
    };
    const stateContinue = instructionSet.continue;
    /**
     * When we get real tail call optimization, this can be replaced
     * with recursion.
     */
    const untilComplete = (state, stepFunction) => {
        // eslint-disable-next-line functional/no-loop-statements
        while (stateContinue(state)) {
            // eslint-disable-next-line functional/no-expression-statements, no-param-reassign
            state = stepFunction(state);
        }
        return state;
    };
    const stateClone = instructionSet.clone;
    const { success } = instructionSet;
    const stateEvaluate = (state) => untilComplete(stateClone(state), stateStepMutate);
    const stateDebugStep = (state) => {
        const operator = getOperation(state);
        return after(stateEvery(operator(stateClone(state))));
    };
    const stateDebug = (state) => {
        const trace = [];
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        trace.push(state);
        // eslint-disable-next-line functional/no-expression-statements
        untilComplete(state, (currentState) => {
            const nextState = stateDebugStep(currentState);
            // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
            trace.push(nextState);
            return nextState;
        });
        return trace;
    };
    const stateStep = (state) => stateStepMutate(stateClone(state));
    const evaluate = (program) => instructionSet.evaluate(program, stateEvaluate);
    const debug = (program) => {
        const results = [];
        const proxyDebug = (state) => {
            const debugResult = stateDebug(state);
            // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
            results.push(...debugResult);
            return debugResult[debugResult.length - 1] ?? state;
        };
        const finalResult = instructionSet.evaluate(program, proxyDebug);
        return [...results, finalResult];
    };
    const verify = (resolvedTransaction) => instructionSet.verify(resolvedTransaction, evaluate, success);
    return {
        debug,
        evaluate,
        stateClone,
        stateContinue,
        stateDebug,
        stateEvaluate,
        stateStep,
        stateStepMutate,
        stateSuccess: success,
        verify,
    };
};
const createAuthenticationVirtualMachine = createVirtualMachine;

/**
 * Initialize a virtual machine using the `BCH_2023_05` instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createVirtualMachineBCH2023 = (standard = true) => createVirtualMachine(createInstructionSetBCH2023(standard));
const createVirtualMachineBCH = createVirtualMachineBCH2023;

/**
 * create an instance of the BCH 2022 virtual machine instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createInstructionSetBCH2022 = (standard = true, { ripemd160: ripemd160$1, secp256k1: secp256k1$1, sha1: sha1$1, sha256: sha256$1, } = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha1: sha1,
    sha256: sha256,
}) => {
    const conditionallyPush = pushOperation();
    return {
        clone: cloneAuthenticationProgramStateBCH,
        continue: (state) => state.error === undefined && state.ip < state.instructions.length,
        // eslint-disable-next-line complexity
        evaluate: (program, stateEvaluate) => {
            const { unlockingBytecode } = 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            program.transaction.inputs[program.inputIndex];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const { lockingBytecode } = program.sourceOutputs[program.inputIndex];
            const unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
            const lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
            const initialState = createAuthenticationProgramStateCommon({
                instructions: unlockingInstructions,
                program,
                stack: [],
            });
            if (unlockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
                return applyError(initialState, `The provided unlocking bytecode (${unlockingBytecode.length} bytes) exceeds the maximum bytecode length (${ConsensusBCH.maximumBytecodeLength} bytes).`);
            }
            if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
                return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
            }
            if (!isPushOnly(unlockingBytecode)) {
                return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
            }
            if (lockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
                return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
            }
            if (authenticationInstructionsAreMalformed(lockingInstructions)) {
                return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
            }
            const unlockingResult = stateEvaluate(initialState);
            if (unlockingResult.error !== undefined) {
                return unlockingResult;
            }
            if (unlockingResult.controlStack.length !== 0) {
                return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
            }
            const lockingResult = stateEvaluate(createAuthenticationProgramStateCommon({
                instructions: lockingInstructions,
                program,
                stack: unlockingResult.stack,
            }));
            if (!isPayToScriptHash20(lockingBytecode)) {
                return lockingResult;
            }
            const p2shStack = cloneStack(unlockingResult.stack);
            // eslint-disable-next-line functional/immutable-data
            const p2shScript = p2shStack.pop() ?? Uint8Array.of();
            if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
                return lockingResult;
            }
            const p2shInstructions = decodeAuthenticationInstructions(p2shScript);
            return authenticationInstructionsAreMalformed(p2shInstructions)
                ? {
                    ...lockingResult,
                    error: AuthenticationErrorCommon.malformedP2shBytecode,
                }
                : stateEvaluate(createAuthenticationProgramStateCommon({
                    instructions: p2shInstructions,
                    program,
                    stack: p2shStack,
                }));
        },
        every: (state) => 
        // TODO: implement sigchecks https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2020-05-15-sigchecks.md
        state.stack.length + state.alternateStack.length >
            ConsensusBCH.maximumStackDepth
            ? applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth)
            : state.operationCount > ConsensusBCH.maximumOperationCount
                ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount)
                : state,
        operations: {
            [OpcodesBCH.OP_0]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_1]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_2]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_3]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_4]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_5]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_6]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_7]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_8]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_9]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_10]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_11]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_12]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_13]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_14]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_15]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_16]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_17]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_18]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_19]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_20]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_21]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_22]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_23]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_24]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_25]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_26]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_27]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_28]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_29]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_30]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_31]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_32]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_33]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_34]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_35]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_36]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_37]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_38]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_39]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_40]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_41]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_42]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_43]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_44]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_45]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_46]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_47]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_48]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_49]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_50]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_51]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_52]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_53]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_54]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_55]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_56]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_57]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_58]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_59]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_60]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_61]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_62]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_63]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_64]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_65]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_66]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_67]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_68]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_69]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_70]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_71]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_72]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_73]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_74]: conditionallyPush,
            [OpcodesBCH.OP_PUSHBYTES_75]: conditionallyPush,
            [OpcodesBCH.OP_PUSHDATA_1]: conditionallyPush,
            [OpcodesBCH.OP_PUSHDATA_2]: conditionallyPush,
            [OpcodesBCH.OP_PUSHDATA_4]: conditionallyPush,
            [OpcodesBCH.OP_1NEGATE]: conditionallyEvaluate(pushNumberOperation(-1)),
            [OpcodesBCH.OP_RESERVED]: conditionallyEvaluate(reservedOperation),
            [OpcodesBCH.OP_1]: conditionallyEvaluate(pushNumberOperation(1)),
            /* eslint-disable @typescript-eslint/no-magic-numbers */
            [OpcodesBCH.OP_2]: conditionallyEvaluate(pushNumberOperation(2)),
            [OpcodesBCH.OP_3]: conditionallyEvaluate(pushNumberOperation(3)),
            [OpcodesBCH.OP_4]: conditionallyEvaluate(pushNumberOperation(4)),
            [OpcodesBCH.OP_5]: conditionallyEvaluate(pushNumberOperation(5)),
            [OpcodesBCH.OP_6]: conditionallyEvaluate(pushNumberOperation(6)),
            [OpcodesBCH.OP_7]: conditionallyEvaluate(pushNumberOperation(7)),
            [OpcodesBCH.OP_8]: conditionallyEvaluate(pushNumberOperation(8)),
            [OpcodesBCH.OP_9]: conditionallyEvaluate(pushNumberOperation(9)),
            [OpcodesBCH.OP_10]: conditionallyEvaluate(pushNumberOperation(10)),
            [OpcodesBCH.OP_11]: conditionallyEvaluate(pushNumberOperation(11)),
            [OpcodesBCH.OP_12]: conditionallyEvaluate(pushNumberOperation(12)),
            [OpcodesBCH.OP_13]: conditionallyEvaluate(pushNumberOperation(13)),
            [OpcodesBCH.OP_14]: conditionallyEvaluate(pushNumberOperation(14)),
            [OpcodesBCH.OP_15]: conditionallyEvaluate(pushNumberOperation(15)),
            [OpcodesBCH.OP_16]: conditionallyEvaluate(pushNumberOperation(16)),
            /* eslint-enable @typescript-eslint/no-magic-numbers */
            ...mapOverOperations([incrementOperationCount], {
                [OpcodesBCH.OP_NOP]: conditionallyEvaluate(opNop),
                [OpcodesBCH.OP_VER]: conditionallyEvaluate(reservedOperation),
                [OpcodesBCH.OP_IF]: opIf,
                [OpcodesBCH.OP_NOTIF]: opNotIf,
                [OpcodesBCH.OP_VERIF]: reservedOperation,
                [OpcodesBCH.OP_VERNOTIF]: reservedOperation,
                [OpcodesBCH.OP_ELSE]: opElse,
                [OpcodesBCH.OP_ENDIF]: opEndIf,
                [OpcodesBCH.OP_VERIFY]: conditionallyEvaluate(opVerify),
                [OpcodesBCH.OP_RETURN]: conditionallyEvaluate(opReturn),
                [OpcodesBCH.OP_TOALTSTACK]: conditionallyEvaluate(opToAltStack),
                [OpcodesBCH.OP_FROMALTSTACK]: conditionallyEvaluate(opFromAltStack),
                [OpcodesBCH.OP_2DROP]: conditionallyEvaluate(op2Drop),
                [OpcodesBCH.OP_2DUP]: conditionallyEvaluate(op2Dup),
                [OpcodesBCH.OP_3DUP]: conditionallyEvaluate(op3Dup),
                [OpcodesBCH.OP_2OVER]: conditionallyEvaluate(op2Over),
                [OpcodesBCH.OP_2ROT]: conditionallyEvaluate(op2Rot),
                [OpcodesBCH.OP_2SWAP]: conditionallyEvaluate(op2Swap),
                [OpcodesBCH.OP_IFDUP]: conditionallyEvaluate(opIfDup),
                [OpcodesBCH.OP_DEPTH]: conditionallyEvaluate(opDepth),
                [OpcodesBCH.OP_DROP]: conditionallyEvaluate(opDrop),
                [OpcodesBCH.OP_DUP]: conditionallyEvaluate(opDup),
                [OpcodesBCH.OP_NIP]: conditionallyEvaluate(opNip),
                [OpcodesBCH.OP_OVER]: conditionallyEvaluate(opOver),
                [OpcodesBCH.OP_PICK]: conditionallyEvaluate(opPick),
                [OpcodesBCH.OP_ROLL]: conditionallyEvaluate(opRoll),
                [OpcodesBCH.OP_ROT]: conditionallyEvaluate(opRot),
                [OpcodesBCH.OP_SWAP]: conditionallyEvaluate(opSwap),
                [OpcodesBCH.OP_TUCK]: conditionallyEvaluate(opTuck),
                [OpcodesBCH.OP_CAT]: conditionallyEvaluate(opCat),
                [OpcodesBCH.OP_SPLIT]: conditionallyEvaluate(opSplit),
                [OpcodesBCH.OP_NUM2BIN]: conditionallyEvaluate(opNum2Bin),
                [OpcodesBCH.OP_BIN2NUM]: conditionallyEvaluate(opBin2Num),
                [OpcodesBCH.OP_SIZE]: conditionallyEvaluate(opSize),
                [OpcodesBCH.OP_INVERT]: disabledOperation,
                [OpcodesBCH.OP_AND]: conditionallyEvaluate(opAnd),
                [OpcodesBCH.OP_OR]: conditionallyEvaluate(opOr),
                [OpcodesBCH.OP_XOR]: conditionallyEvaluate(opXor),
                [OpcodesBCH.OP_EQUAL]: conditionallyEvaluate(opEqual),
                [OpcodesBCH.OP_EQUALVERIFY]: conditionallyEvaluate(opEqualVerify),
                [OpcodesBCH.OP_RESERVED1]: conditionallyEvaluate(reservedOperation),
                [OpcodesBCH.OP_RESERVED2]: conditionallyEvaluate(reservedOperation),
                [OpcodesBCH.OP_1ADD]: conditionallyEvaluate(op1Add),
                [OpcodesBCH.OP_1SUB]: conditionallyEvaluate(op1Sub),
                [OpcodesBCH.OP_2MUL]: disabledOperation,
                [OpcodesBCH.OP_2DIV]: disabledOperation,
                [OpcodesBCH.OP_NEGATE]: conditionallyEvaluate(opNegate),
                [OpcodesBCH.OP_ABS]: conditionallyEvaluate(opAbs),
                [OpcodesBCH.OP_NOT]: conditionallyEvaluate(opNot),
                [OpcodesBCH.OP_0NOTEQUAL]: conditionallyEvaluate(op0NotEqual),
                [OpcodesBCH.OP_ADD]: conditionallyEvaluate(opAdd),
                [OpcodesBCH.OP_SUB]: conditionallyEvaluate(opSub),
                [OpcodesBCH.OP_MUL]: conditionallyEvaluate(opMul),
                [OpcodesBCH.OP_DIV]: conditionallyEvaluate(opDiv),
                [OpcodesBCH.OP_MOD]: conditionallyEvaluate(opMod),
                [OpcodesBCH.OP_LSHIFT]: disabledOperation,
                [OpcodesBCH.OP_RSHIFT]: disabledOperation,
                [OpcodesBCH.OP_BOOLAND]: conditionallyEvaluate(opBoolAnd),
                [OpcodesBCH.OP_BOOLOR]: conditionallyEvaluate(opBoolOr),
                [OpcodesBCH.OP_NUMEQUAL]: conditionallyEvaluate(opNumEqual),
                [OpcodesBCH.OP_NUMEQUALVERIFY]: conditionallyEvaluate(opNumEqualVerify),
                [OpcodesBCH.OP_NUMNOTEQUAL]: conditionallyEvaluate(opNumNotEqual),
                [OpcodesBCH.OP_LESSTHAN]: conditionallyEvaluate(opLessThan),
                [OpcodesBCH.OP_GREATERTHAN]: conditionallyEvaluate(opGreaterThan),
                [OpcodesBCH.OP_LESSTHANOREQUAL]: conditionallyEvaluate(opLessThanOrEqual),
                [OpcodesBCH.OP_GREATERTHANOREQUAL]: conditionallyEvaluate(opGreaterThanOrEqual),
                [OpcodesBCH.OP_MIN]: conditionallyEvaluate(opMin),
                [OpcodesBCH.OP_MAX]: conditionallyEvaluate(opMax),
                [OpcodesBCH.OP_WITHIN]: conditionallyEvaluate(opWithin),
                [OpcodesBCH.OP_RIPEMD160]: conditionallyEvaluate(opRipemd160({ ripemd160: ripemd160$1 })),
                [OpcodesBCH.OP_SHA1]: conditionallyEvaluate(opSha1({ sha1: sha1$1 })),
                [OpcodesBCH.OP_SHA256]: conditionallyEvaluate(opSha256({ sha256: sha256$1 })),
                [OpcodesBCH.OP_HASH160]: conditionallyEvaluate(opHash160({ ripemd160: ripemd160$1, sha256: sha256$1 })),
                [OpcodesBCH.OP_HASH256]: conditionallyEvaluate(opHash256({ sha256: sha256$1 })),
                [OpcodesBCH.OP_CODESEPARATOR]: conditionallyEvaluate(opCodeSeparator),
                [OpcodesBCH.OP_CHECKSIG]: conditionallyEvaluate(opCheckSig({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH.OP_CHECKSIGVERIFY]: conditionallyEvaluate(opCheckSigVerify({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH.OP_CHECKMULTISIG]: conditionallyEvaluate(opCheckMultiSig({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH.OP_CHECKMULTISIGVERIFY]: conditionallyEvaluate(opCheckMultiSigVerify({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                ...(standard
                    ? {
                        [OpcodesBCH.OP_NOP1]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
                        [OpcodesBCH.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
                        [OpcodesBCH.OP_NOP4]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_NOP5]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_NOP6]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_NOP7]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_NOP8]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_NOP9]: conditionallyEvaluate(opNopDisallowed),
                        [OpcodesBCH.OP_NOP10]: conditionallyEvaluate(opNopDisallowed),
                    }
                    : {
                        [OpcodesBCH.OP_NOP1]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluate(opCheckLockTimeVerify),
                        [OpcodesBCH.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluate(opCheckSequenceVerify),
                        [OpcodesBCH.OP_NOP4]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_NOP5]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_NOP6]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_NOP7]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_NOP8]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_NOP9]: conditionallyEvaluate(opNop),
                        [OpcodesBCH.OP_NOP10]: conditionallyEvaluate(opNop),
                    }),
                [OpcodesBCH.OP_CHECKDATASIG]: conditionallyEvaluate(opCheckDataSig({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH.OP_CHECKDATASIGVERIFY]: conditionallyEvaluate(opCheckDataSigVerify({ secp256k1: secp256k1$1, sha256: sha256$1 })),
                [OpcodesBCH.OP_REVERSEBYTES]: conditionallyEvaluate(opReverseBytes),
                [OpcodesBCH.OP_INPUTINDEX]: conditionallyEvaluate(opInputIndex),
                [OpcodesBCH.OP_ACTIVEBYTECODE]: conditionallyEvaluate(opActiveBytecode),
                [OpcodesBCH.OP_TXVERSION]: conditionallyEvaluate(opTxVersion),
                [OpcodesBCH.OP_TXINPUTCOUNT]: conditionallyEvaluate(opTxInputCount),
                [OpcodesBCH.OP_TXOUTPUTCOUNT]: conditionallyEvaluate(opTxOutputCount),
                [OpcodesBCH.OP_TXLOCKTIME]: conditionallyEvaluate(opTxLocktime),
                [OpcodesBCH.OP_UTXOVALUE]: conditionallyEvaluate(opUtxoValue),
                [OpcodesBCH.OP_UTXOBYTECODE]: conditionallyEvaluate(opUtxoBytecode),
                [OpcodesBCH.OP_OUTPOINTTXHASH]: conditionallyEvaluate(opOutpointTxHash),
                [OpcodesBCH.OP_OUTPOINTINDEX]: conditionallyEvaluate(opOutpointIndex),
                [OpcodesBCH.OP_INPUTBYTECODE]: conditionallyEvaluate(opInputBytecode),
                [OpcodesBCH.OP_INPUTSEQUENCENUMBER]: conditionallyEvaluate(opInputSequenceNumber),
                [OpcodesBCH.OP_OUTPUTVALUE]: conditionallyEvaluate(opOutputValue),
                [OpcodesBCH.OP_OUTPUTBYTECODE]: conditionallyEvaluate(opOutputBytecode),
            }),
        },
        success: (state) => {
            if (state.error !== undefined) {
                return state.error;
            }
            if (state.controlStack.length !== 0) {
                return AuthenticationErrorCommon.nonEmptyControlStack;
            }
            if (state.stack.length !== 1) {
                return AuthenticationErrorCommon.requiresCleanStack;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (!stackItemIsTruthy(state.stack[0])) {
                return AuthenticationErrorCommon.unsuccessfulEvaluation;
            }
            return true;
        },
        undefined: undefinedOperation,
        // eslint-disable-next-line complexity
        verify: ({ sourceOutputs, transaction }, evaluate, stateSuccess) => {
            if (transaction.inputs.length === 0) {
                return 'Transactions must have at least one input.';
            }
            if (transaction.outputs.length === 0) {
                return 'Transactions must have at least one output.';
            }
            if (transaction.inputs.length !== sourceOutputs.length) {
                return 'Unable to verify transaction: a single spent output must be provided for each transaction input.';
            }
            const transactionSize = encodeTransactionBCH(transaction).length;
            if (transactionSize < ConsensusBCH.minimumTransactionSize) {
                return `Transaction does not meet minimum size: the transaction is ${transactionSize} bytes, but the minimum transaction size is ${ConsensusBCH.minimumTransactionSize} bytes.`;
            }
            if (transactionSize > ConsensusBCH.maximumTransactionSize) {
                return `Transaction exceeds maximum size: the transaction is ${transactionSize} bytes, but the maximum transaction size is ${ConsensusBCH.maximumTransactionSize} bytes.`;
            }
            if (standard) {
                if (transaction.version < 1 ||
                    transaction.version > ConsensusBCH.maximumStandardVersion) {
                    return `Standard transactions must have a version no less than 1 and no greater than ${ConsensusBCH.maximumStandardVersion}.`;
                }
                if (transactionSize > ConsensusBCH.maximumStandardTransactionSize) {
                    return `Transaction exceeds maximum standard size: this transaction is ${transactionSize} bytes, but the maximum standard transaction size is ${ConsensusBCH.maximumStandardTransactionSize} bytes.`;
                }
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, output] of sourceOutputs.entries()) {
                    if (!isStandardOutputBytecode(output.lockingBytecode)) {
                        return `Standard transactions may only spend standard output types, but source output ${index} is non-standard.`;
                    }
                }
                // eslint-disable-next-line functional/no-let
                let totalArbitraryDataBytes = 0;
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, output] of transaction.outputs.entries()) {
                    if (!isStandardOutputBytecode(output.lockingBytecode)) {
                        return `Standard transactions may only create standard output types, but transaction output ${index} is non-standard.`;
                    }
                    // eslint-disable-next-line functional/no-conditional-statements
                    if (isArbitraryDataOutput(output.lockingBytecode)) {
                        // eslint-disable-next-line functional/no-expression-statements
                        totalArbitraryDataBytes += output.lockingBytecode.length + 1;
                    }
                    /*
                     * TODO: disallow dust outputs
                     * if(IsDustOutput(output)) {
                     *   return ``;
                     * }
                     */
                }
                if (totalArbitraryDataBytes > ConsensusBCH.maximumDataCarrierBytes) {
                    return `Standard transactions may carry no more than ${ConsensusBCH.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${totalArbitraryDataBytes} bytes of arbitrary data.`;
                }
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, input] of transaction.inputs.entries()) {
                    if (input.unlockingBytecode.length >
                        ConsensusBCH.maximumStandardUnlockingBytecodeLength) {
                        return `Input index ${index} is non-standard: the unlocking bytecode (${input.unlockingBytecode.length} bytes) exceeds the maximum standard unlocking bytecode length (${ConsensusBCH.maximumStandardUnlockingBytecodeLength} bytes).`;
                    }
                    if (!isPushOnly(input.unlockingBytecode)) {
                        return `Input index ${index} is non-standard: unlocking bytecode may contain only push operations.`;
                    }
                }
            }
            // eslint-disable-next-line functional/no-loop-statements
            for (const index of transaction.inputs.keys()) {
                const state = evaluate({
                    inputIndex: index,
                    sourceOutputs,
                    transaction,
                });
                const result = stateSuccess(state);
                if (typeof result === 'string') {
                    return `Error in evaluating input index ${index}: ${result}`;
                }
            }
            return true;
        },
    };
};

/**
 * The `BCH_2022_05` instruction set.
 */
var OpcodesBCH2022;
(function (OpcodesBCH2022) {
    /**
     * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_0"] = 0] = "OP_0";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    OpcodesBCH2022[OpcodesBCH2022["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
    OpcodesBCH2022[OpcodesBCH2022["OP_1NEGATE"] = 79] = "OP_1NEGATE";
    OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED"] = 80] = "OP_RESERVED";
    /**
     * A.K.A. `OP_TRUE`
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_1"] = 81] = "OP_1";
    OpcodesBCH2022[OpcodesBCH2022["OP_2"] = 82] = "OP_2";
    OpcodesBCH2022[OpcodesBCH2022["OP_3"] = 83] = "OP_3";
    OpcodesBCH2022[OpcodesBCH2022["OP_4"] = 84] = "OP_4";
    OpcodesBCH2022[OpcodesBCH2022["OP_5"] = 85] = "OP_5";
    OpcodesBCH2022[OpcodesBCH2022["OP_6"] = 86] = "OP_6";
    OpcodesBCH2022[OpcodesBCH2022["OP_7"] = 87] = "OP_7";
    OpcodesBCH2022[OpcodesBCH2022["OP_8"] = 88] = "OP_8";
    OpcodesBCH2022[OpcodesBCH2022["OP_9"] = 89] = "OP_9";
    OpcodesBCH2022[OpcodesBCH2022["OP_10"] = 90] = "OP_10";
    OpcodesBCH2022[OpcodesBCH2022["OP_11"] = 91] = "OP_11";
    OpcodesBCH2022[OpcodesBCH2022["OP_12"] = 92] = "OP_12";
    OpcodesBCH2022[OpcodesBCH2022["OP_13"] = 93] = "OP_13";
    OpcodesBCH2022[OpcodesBCH2022["OP_14"] = 94] = "OP_14";
    OpcodesBCH2022[OpcodesBCH2022["OP_15"] = 95] = "OP_15";
    OpcodesBCH2022[OpcodesBCH2022["OP_16"] = 96] = "OP_16";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP"] = 97] = "OP_NOP";
    OpcodesBCH2022[OpcodesBCH2022["OP_VER"] = 98] = "OP_VER";
    OpcodesBCH2022[OpcodesBCH2022["OP_IF"] = 99] = "OP_IF";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOTIF"] = 100] = "OP_NOTIF";
    OpcodesBCH2022[OpcodesBCH2022["OP_VERIF"] = 101] = "OP_VERIF";
    OpcodesBCH2022[OpcodesBCH2022["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
    OpcodesBCH2022[OpcodesBCH2022["OP_ELSE"] = 103] = "OP_ELSE";
    OpcodesBCH2022[OpcodesBCH2022["OP_ENDIF"] = 104] = "OP_ENDIF";
    OpcodesBCH2022[OpcodesBCH2022["OP_VERIFY"] = 105] = "OP_VERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_RETURN"] = 106] = "OP_RETURN";
    OpcodesBCH2022[OpcodesBCH2022["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
    OpcodesBCH2022[OpcodesBCH2022["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
    OpcodesBCH2022[OpcodesBCH2022["OP_2DROP"] = 109] = "OP_2DROP";
    OpcodesBCH2022[OpcodesBCH2022["OP_2DUP"] = 110] = "OP_2DUP";
    OpcodesBCH2022[OpcodesBCH2022["OP_3DUP"] = 111] = "OP_3DUP";
    OpcodesBCH2022[OpcodesBCH2022["OP_2OVER"] = 112] = "OP_2OVER";
    OpcodesBCH2022[OpcodesBCH2022["OP_2ROT"] = 113] = "OP_2ROT";
    OpcodesBCH2022[OpcodesBCH2022["OP_2SWAP"] = 114] = "OP_2SWAP";
    OpcodesBCH2022[OpcodesBCH2022["OP_IFDUP"] = 115] = "OP_IFDUP";
    OpcodesBCH2022[OpcodesBCH2022["OP_DEPTH"] = 116] = "OP_DEPTH";
    OpcodesBCH2022[OpcodesBCH2022["OP_DROP"] = 117] = "OP_DROP";
    OpcodesBCH2022[OpcodesBCH2022["OP_DUP"] = 118] = "OP_DUP";
    OpcodesBCH2022[OpcodesBCH2022["OP_NIP"] = 119] = "OP_NIP";
    OpcodesBCH2022[OpcodesBCH2022["OP_OVER"] = 120] = "OP_OVER";
    OpcodesBCH2022[OpcodesBCH2022["OP_PICK"] = 121] = "OP_PICK";
    OpcodesBCH2022[OpcodesBCH2022["OP_ROLL"] = 122] = "OP_ROLL";
    OpcodesBCH2022[OpcodesBCH2022["OP_ROT"] = 123] = "OP_ROT";
    OpcodesBCH2022[OpcodesBCH2022["OP_SWAP"] = 124] = "OP_SWAP";
    OpcodesBCH2022[OpcodesBCH2022["OP_TUCK"] = 125] = "OP_TUCK";
    OpcodesBCH2022[OpcodesBCH2022["OP_CAT"] = 126] = "OP_CAT";
    OpcodesBCH2022[OpcodesBCH2022["OP_SPLIT"] = 127] = "OP_SPLIT";
    OpcodesBCH2022[OpcodesBCH2022["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
    OpcodesBCH2022[OpcodesBCH2022["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
    OpcodesBCH2022[OpcodesBCH2022["OP_SIZE"] = 130] = "OP_SIZE";
    OpcodesBCH2022[OpcodesBCH2022["OP_INVERT"] = 131] = "OP_INVERT";
    OpcodesBCH2022[OpcodesBCH2022["OP_AND"] = 132] = "OP_AND";
    OpcodesBCH2022[OpcodesBCH2022["OP_OR"] = 133] = "OP_OR";
    OpcodesBCH2022[OpcodesBCH2022["OP_XOR"] = 134] = "OP_XOR";
    OpcodesBCH2022[OpcodesBCH2022["OP_EQUAL"] = 135] = "OP_EQUAL";
    OpcodesBCH2022[OpcodesBCH2022["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED1"] = 137] = "OP_RESERVED1";
    OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED2"] = 138] = "OP_RESERVED2";
    OpcodesBCH2022[OpcodesBCH2022["OP_1ADD"] = 139] = "OP_1ADD";
    OpcodesBCH2022[OpcodesBCH2022["OP_1SUB"] = 140] = "OP_1SUB";
    OpcodesBCH2022[OpcodesBCH2022["OP_2MUL"] = 141] = "OP_2MUL";
    OpcodesBCH2022[OpcodesBCH2022["OP_2DIV"] = 142] = "OP_2DIV";
    OpcodesBCH2022[OpcodesBCH2022["OP_NEGATE"] = 143] = "OP_NEGATE";
    OpcodesBCH2022[OpcodesBCH2022["OP_ABS"] = 144] = "OP_ABS";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOT"] = 145] = "OP_NOT";
    OpcodesBCH2022[OpcodesBCH2022["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
    OpcodesBCH2022[OpcodesBCH2022["OP_ADD"] = 147] = "OP_ADD";
    OpcodesBCH2022[OpcodesBCH2022["OP_SUB"] = 148] = "OP_SUB";
    OpcodesBCH2022[OpcodesBCH2022["OP_MUL"] = 149] = "OP_MUL";
    OpcodesBCH2022[OpcodesBCH2022["OP_DIV"] = 150] = "OP_DIV";
    OpcodesBCH2022[OpcodesBCH2022["OP_MOD"] = 151] = "OP_MOD";
    OpcodesBCH2022[OpcodesBCH2022["OP_LSHIFT"] = 152] = "OP_LSHIFT";
    OpcodesBCH2022[OpcodesBCH2022["OP_RSHIFT"] = 153] = "OP_RSHIFT";
    OpcodesBCH2022[OpcodesBCH2022["OP_BOOLAND"] = 154] = "OP_BOOLAND";
    OpcodesBCH2022[OpcodesBCH2022["OP_BOOLOR"] = 155] = "OP_BOOLOR";
    OpcodesBCH2022[OpcodesBCH2022["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
    OpcodesBCH2022[OpcodesBCH2022["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
    OpcodesBCH2022[OpcodesBCH2022["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
    OpcodesBCH2022[OpcodesBCH2022["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
    OpcodesBCH2022[OpcodesBCH2022["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
    OpcodesBCH2022[OpcodesBCH2022["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
    OpcodesBCH2022[OpcodesBCH2022["OP_MIN"] = 163] = "OP_MIN";
    OpcodesBCH2022[OpcodesBCH2022["OP_MAX"] = 164] = "OP_MAX";
    OpcodesBCH2022[OpcodesBCH2022["OP_WITHIN"] = 165] = "OP_WITHIN";
    OpcodesBCH2022[OpcodesBCH2022["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
    OpcodesBCH2022[OpcodesBCH2022["OP_SHA1"] = 167] = "OP_SHA1";
    OpcodesBCH2022[OpcodesBCH2022["OP_SHA256"] = 168] = "OP_SHA256";
    OpcodesBCH2022[OpcodesBCH2022["OP_HASH160"] = 169] = "OP_HASH160";
    OpcodesBCH2022[OpcodesBCH2022["OP_HASH256"] = 170] = "OP_HASH256";
    OpcodesBCH2022[OpcodesBCH2022["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP1"] = 176] = "OP_NOP1";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP4"] = 179] = "OP_NOP4";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP5"] = 180] = "OP_NOP5";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP6"] = 181] = "OP_NOP6";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP7"] = 182] = "OP_NOP7";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP8"] = 183] = "OP_NOP8";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP9"] = 184] = "OP_NOP9";
    OpcodesBCH2022[OpcodesBCH2022["OP_NOP10"] = 185] = "OP_NOP10";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
    OpcodesBCH2022[OpcodesBCH2022["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
    OpcodesBCH2022[OpcodesBCH2022["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
    /**
     * First codepoint left undefined before nullary introspection operations.
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
    /**
     * Last codepoint left undefined before nullary introspection operations.
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
    OpcodesBCH2022[OpcodesBCH2022["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
    OpcodesBCH2022[OpcodesBCH2022["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
    OpcodesBCH2022[OpcodesBCH2022["OP_TXVERSION"] = 194] = "OP_TXVERSION";
    OpcodesBCH2022[OpcodesBCH2022["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
    OpcodesBCH2022[OpcodesBCH2022["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
    OpcodesBCH2022[OpcodesBCH2022["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
    OpcodesBCH2022[OpcodesBCH2022["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
    OpcodesBCH2022[OpcodesBCH2022["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
    OpcodesBCH2022[OpcodesBCH2022["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
    OpcodesBCH2022[OpcodesBCH2022["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
    OpcodesBCH2022[OpcodesBCH2022["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
    OpcodesBCH2022[OpcodesBCH2022["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
    OpcodesBCH2022[OpcodesBCH2022["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
    OpcodesBCH2022[OpcodesBCH2022["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
    /**
     * Reserved for unary introspection operations.
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED3"] = 206] = "OP_RESERVED3";
    /**
     * Reserved for unary introspection operations.
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED4"] = 207] = "OP_RESERVED4";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
    /**
     * A.K.A. `OP_PREFIX_BEGIN`
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
    /**
     * A.K.A. `OP_PREFIX_END`
     */
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
    OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH2022 || (OpcodesBCH2022 = {}));

var ConsensusXEC;
(function (ConsensusXEC) {
    /**
     * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
     */
    ConsensusXEC[ConsensusXEC["maximumStackItemLength"] = 520] = "maximumStackItemLength";
    ConsensusXEC[ConsensusXEC["maximumVmNumberLength"] = 4] = "maximumVmNumberLength";
    /**
     * A.K.A. `MAX_OPS_PER_SCRIPT`
     */
    ConsensusXEC[ConsensusXEC["maximumOperationCount"] = 201] = "maximumOperationCount";
    /**
     * A.K.A. `MAX_SCRIPT_SIZE`
     */
    ConsensusXEC[ConsensusXEC["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
    /**
     * A.K.A. `MAX_STACK_SIZE`
     */
    ConsensusXEC[ConsensusXEC["maximumStackDepth"] = 1000] = "maximumStackDepth";
    ConsensusXEC[ConsensusXEC["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusXEC || (ConsensusXEC = {}));

const maximumVmNumberByteLength = ConsensusXEC.maximumVmNumberLength;
const opPick4Byte = (state) => useOneVmNumber(state, (nextState, depth) => {
    const item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
    if (item === undefined) {
        return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    return pushToStack(nextState, item.slice());
});
const opRoll4Byte = (state) => useOneVmNumber(state, (nextState, depth) => {
    const index = nextState.stack.length - 1 - Number(depth);
    if (index < 0 || index > nextState.stack.length - 1) {
        return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    // eslint-disable-next-line functional/immutable-data, @typescript-eslint/no-non-null-assertion
    return pushToStack(nextState, nextState.stack.splice(index, 1)[0]);
});
const opSplit4Byte = (state) => useOneVmNumber(state, (nextState, value) => {
    const index = Number(value);
    return useOneStackItem(nextState, (finalState, [item]) => index < 0 || index > item.length
        ? applyError(finalState, AuthenticationErrorCommon.invalidSplitIndex)
        : pushToStack(finalState, item.slice(0, index), item.slice(index)));
}, { maximumVmNumberByteLength });
const opNum2Bin4Byte = (state) => useOneVmNumber(state, (nextState, value) => {
    const targetLength = Number(value);
    return targetLength > ConsensusXEC.maximumStackItemLength
        ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumStackItemLength)
        : useOneVmNumber(nextState, (finalState, [target]) => {
            const minimallyEncoded = bigIntToVmNumber(target);
            return minimallyEncoded.length > targetLength
                ? applyError(finalState, AuthenticationErrorCommon.insufficientLength)
                : minimallyEncoded.length === targetLength
                    ? pushToStack(finalState, minimallyEncoded)
                    : pushToStack(finalState, padMinimallyEncodedVmNumber(minimallyEncoded, targetLength));
        }, {
            maximumVmNumberByteLength: ConsensusXEC.maximumStackItemLength,
            requireMinimalEncoding: false,
        });
});
const opBin2Num4Byte = (state) => useOneVmNumber(state, (nextState, [target]) => {
    const minimallyEncoded = bigIntToVmNumber(target);
    return minimallyEncoded.length > ConsensusXEC.maximumVmNumberLength
        ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumVmNumberLength)
        : pushToStack(nextState, minimallyEncoded);
}, {
    maximumVmNumberByteLength: ConsensusXEC.maximumStackItemLength,
    requireMinimalEncoding: false,
});
const op1Add4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value + 1n)), { maximumVmNumberByteLength });
const op1Sub4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value - 1n)), { maximumVmNumberByteLength });
const opNegate4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(-value)), { maximumVmNumberByteLength });
const opAbs4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToVmNumber(value < 0 ? -value : value)), { maximumVmNumberByteLength });
const opNot4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n)), { maximumVmNumberByteLength });
const op0NotEqual4Byte = (state) => useOneVmNumber(state, (nextState, [value]) => pushToStack(nextState, value === 0n ? bigIntToVmNumber(0n) : bigIntToVmNumber(1n)), { maximumVmNumberByteLength });
const opAdd4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue + secondValue)), { maximumVmNumberByteLength });
const opSub4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue - secondValue)), { maximumVmNumberByteLength });
const opDiv4Byte = (state) => useTwoVmNumbers(state, (nextState, [a, b]) => b === 0n
    ? applyError(nextState, AuthenticationErrorCommon.divisionByZero)
    : pushToStack(nextState, bigIntToVmNumber(a / b)), { maximumVmNumberByteLength });
const opMod4Byte = (state) => useTwoVmNumbers(state, (nextState, [a, b]) => b === 0n
    ? applyError(nextState, AuthenticationErrorCommon.divisionByZero)
    : pushToStack(nextState, bigIntToVmNumber(a % b)), { maximumVmNumberByteLength });
const opBoolAnd4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n && secondValue !== 0n)), { maximumVmNumberByteLength });
const opBoolOr4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== 0n || secondValue !== 0n)), { maximumVmNumberByteLength });
const opNumEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue === secondValue)), { maximumVmNumberByteLength });
const opNumEqualVerify4Byte = combineOperations(opNumEqual4Byte, opVerify);
const opNumNotEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue !== secondValue)), { maximumVmNumberByteLength });
const opLessThan4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue < secondValue)), { maximumVmNumberByteLength });
const opLessThanOrEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue <= secondValue)), { maximumVmNumberByteLength });
const opGreaterThan4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue > secondValue)), { maximumVmNumberByteLength });
const opGreaterThanOrEqual4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToVmNumber(firstValue >= secondValue)), { maximumVmNumberByteLength });
const opMin4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue < secondValue ? firstValue : secondValue)), { maximumVmNumberByteLength });
const opMax4Byte = (state) => useTwoVmNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToVmNumber(firstValue > secondValue ? firstValue : secondValue)), { maximumVmNumberByteLength });
const opWithin4Byte = (state) => useThreeVmNumbers(state, (nextState, [firstValue, secondValue, thirdValue]) => pushToStack(nextState, booleanToVmNumber(secondValue <= firstValue && firstValue < thirdValue)), { maximumVmNumberByteLength });

/**
 * create an instance of the XEC virtual machine instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createInstructionSetXEC = (standard = true) => {
    const instructionSet = createInstructionSetBCH2022(standard);
    return {
        ...instructionSet,
        operations: {
            ...instructionSet.operations,
            ...mapOverOperations([conditionallyEvaluate, incrementOperationCount], {
                [OpcodesBCH2022.OP_PICK]: opPick4Byte,
                [OpcodesBCH2022.OP_ROLL]: opRoll4Byte,
                [OpcodesBCH2022.OP_SPLIT]: opSplit4Byte,
                [OpcodesBCH2022.OP_NUM2BIN]: opNum2Bin4Byte,
                [OpcodesBCH2022.OP_BIN2NUM]: opBin2Num4Byte,
                [OpcodesBCH2022.OP_1ADD]: op1Add4Byte,
                [OpcodesBCH2022.OP_1SUB]: op1Sub4Byte,
                [OpcodesBCH2022.OP_NEGATE]: opNegate4Byte,
                [OpcodesBCH2022.OP_ABS]: opAbs4Byte,
                [OpcodesBCH2022.OP_NOT]: opNot4Byte,
                [OpcodesBCH2022.OP_0NOTEQUAL]: op0NotEqual4Byte,
                [OpcodesBCH2022.OP_ADD]: opAdd4Byte,
                [OpcodesBCH2022.OP_SUB]: opSub4Byte,
                [OpcodesBCH2022.OP_MUL]: disabledOperation,
                [OpcodesBCH2022.OP_DIV]: opDiv4Byte,
                [OpcodesBCH2022.OP_MOD]: opMod4Byte,
                [OpcodesBCH2022.OP_BOOLAND]: opBoolAnd4Byte,
                [OpcodesBCH2022.OP_BOOLOR]: opBoolOr4Byte,
                [OpcodesBCH2022.OP_NUMEQUAL]: opNumEqual4Byte,
                [OpcodesBCH2022.OP_NUMEQUALVERIFY]: opNumEqualVerify4Byte,
                [OpcodesBCH2022.OP_NUMNOTEQUAL]: opNumNotEqual4Byte,
                [OpcodesBCH2022.OP_LESSTHAN]: opLessThan4Byte,
                [OpcodesBCH2022.OP_GREATERTHAN]: opGreaterThan4Byte,
                [OpcodesBCH2022.OP_LESSTHANOREQUAL]: opLessThanOrEqual4Byte,
                [OpcodesBCH2022.OP_GREATERTHANOREQUAL]: opGreaterThanOrEqual4Byte,
                [OpcodesBCH2022.OP_MIN]: opMin4Byte,
                [OpcodesBCH2022.OP_MAX]: opMax4Byte,
                [OpcodesBCH2022.OP_WITHIN]: opWithin4Byte,
            }),
            [OpcodesBCH2022.OP_INPUTINDEX]: undefinedOperation,
            [OpcodesBCH2022.OP_ACTIVEBYTECODE]: undefinedOperation,
            [OpcodesBCH2022.OP_TXVERSION]: undefinedOperation,
            [OpcodesBCH2022.OP_TXINPUTCOUNT]: undefinedOperation,
            [OpcodesBCH2022.OP_TXOUTPUTCOUNT]: undefinedOperation,
            [OpcodesBCH2022.OP_TXLOCKTIME]: undefinedOperation,
            [OpcodesBCH2022.OP_UTXOVALUE]: undefinedOperation,
            [OpcodesBCH2022.OP_UTXOBYTECODE]: undefinedOperation,
            [OpcodesBCH2022.OP_OUTPOINTTXHASH]: undefinedOperation,
            [OpcodesBCH2022.OP_OUTPOINTINDEX]: undefinedOperation,
            [OpcodesBCH2022.OP_INPUTBYTECODE]: undefinedOperation,
            [OpcodesBCH2022.OP_INPUTSEQUENCENUMBER]: undefinedOperation,
            [OpcodesBCH2022.OP_OUTPUTVALUE]: undefinedOperation,
            [OpcodesBCH2022.OP_OUTPUTBYTECODE]: undefinedOperation,
        },
    };
};

var OpcodesXEC;
(function (OpcodesXEC) {
    /**
     * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
     */
    OpcodesXEC[OpcodesXEC["OP_0"] = 0] = "OP_0";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
    OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
    OpcodesXEC[OpcodesXEC["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    OpcodesXEC[OpcodesXEC["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    OpcodesXEC[OpcodesXEC["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
    OpcodesXEC[OpcodesXEC["OP_1NEGATE"] = 79] = "OP_1NEGATE";
    OpcodesXEC[OpcodesXEC["OP_RESERVED"] = 80] = "OP_RESERVED";
    /**
     * A.K.A. `OP_TRUE`
     */
    OpcodesXEC[OpcodesXEC["OP_1"] = 81] = "OP_1";
    OpcodesXEC[OpcodesXEC["OP_2"] = 82] = "OP_2";
    OpcodesXEC[OpcodesXEC["OP_3"] = 83] = "OP_3";
    OpcodesXEC[OpcodesXEC["OP_4"] = 84] = "OP_4";
    OpcodesXEC[OpcodesXEC["OP_5"] = 85] = "OP_5";
    OpcodesXEC[OpcodesXEC["OP_6"] = 86] = "OP_6";
    OpcodesXEC[OpcodesXEC["OP_7"] = 87] = "OP_7";
    OpcodesXEC[OpcodesXEC["OP_8"] = 88] = "OP_8";
    OpcodesXEC[OpcodesXEC["OP_9"] = 89] = "OP_9";
    OpcodesXEC[OpcodesXEC["OP_10"] = 90] = "OP_10";
    OpcodesXEC[OpcodesXEC["OP_11"] = 91] = "OP_11";
    OpcodesXEC[OpcodesXEC["OP_12"] = 92] = "OP_12";
    OpcodesXEC[OpcodesXEC["OP_13"] = 93] = "OP_13";
    OpcodesXEC[OpcodesXEC["OP_14"] = 94] = "OP_14";
    OpcodesXEC[OpcodesXEC["OP_15"] = 95] = "OP_15";
    OpcodesXEC[OpcodesXEC["OP_16"] = 96] = "OP_16";
    OpcodesXEC[OpcodesXEC["OP_NOP"] = 97] = "OP_NOP";
    OpcodesXEC[OpcodesXEC["OP_VER"] = 98] = "OP_VER";
    OpcodesXEC[OpcodesXEC["OP_IF"] = 99] = "OP_IF";
    OpcodesXEC[OpcodesXEC["OP_NOTIF"] = 100] = "OP_NOTIF";
    OpcodesXEC[OpcodesXEC["OP_VERIF"] = 101] = "OP_VERIF";
    OpcodesXEC[OpcodesXEC["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
    OpcodesXEC[OpcodesXEC["OP_ELSE"] = 103] = "OP_ELSE";
    OpcodesXEC[OpcodesXEC["OP_ENDIF"] = 104] = "OP_ENDIF";
    OpcodesXEC[OpcodesXEC["OP_VERIFY"] = 105] = "OP_VERIFY";
    OpcodesXEC[OpcodesXEC["OP_RETURN"] = 106] = "OP_RETURN";
    OpcodesXEC[OpcodesXEC["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
    OpcodesXEC[OpcodesXEC["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
    OpcodesXEC[OpcodesXEC["OP_2DROP"] = 109] = "OP_2DROP";
    OpcodesXEC[OpcodesXEC["OP_2DUP"] = 110] = "OP_2DUP";
    OpcodesXEC[OpcodesXEC["OP_3DUP"] = 111] = "OP_3DUP";
    OpcodesXEC[OpcodesXEC["OP_2OVER"] = 112] = "OP_2OVER";
    OpcodesXEC[OpcodesXEC["OP_2ROT"] = 113] = "OP_2ROT";
    OpcodesXEC[OpcodesXEC["OP_2SWAP"] = 114] = "OP_2SWAP";
    OpcodesXEC[OpcodesXEC["OP_IFDUP"] = 115] = "OP_IFDUP";
    OpcodesXEC[OpcodesXEC["OP_DEPTH"] = 116] = "OP_DEPTH";
    OpcodesXEC[OpcodesXEC["OP_DROP"] = 117] = "OP_DROP";
    OpcodesXEC[OpcodesXEC["OP_DUP"] = 118] = "OP_DUP";
    OpcodesXEC[OpcodesXEC["OP_NIP"] = 119] = "OP_NIP";
    OpcodesXEC[OpcodesXEC["OP_OVER"] = 120] = "OP_OVER";
    OpcodesXEC[OpcodesXEC["OP_PICK"] = 121] = "OP_PICK";
    OpcodesXEC[OpcodesXEC["OP_ROLL"] = 122] = "OP_ROLL";
    OpcodesXEC[OpcodesXEC["OP_ROT"] = 123] = "OP_ROT";
    OpcodesXEC[OpcodesXEC["OP_SWAP"] = 124] = "OP_SWAP";
    OpcodesXEC[OpcodesXEC["OP_TUCK"] = 125] = "OP_TUCK";
    OpcodesXEC[OpcodesXEC["OP_CAT"] = 126] = "OP_CAT";
    OpcodesXEC[OpcodesXEC["OP_SPLIT"] = 127] = "OP_SPLIT";
    OpcodesXEC[OpcodesXEC["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
    OpcodesXEC[OpcodesXEC["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
    OpcodesXEC[OpcodesXEC["OP_SIZE"] = 130] = "OP_SIZE";
    OpcodesXEC[OpcodesXEC["OP_INVERT"] = 131] = "OP_INVERT";
    OpcodesXEC[OpcodesXEC["OP_AND"] = 132] = "OP_AND";
    OpcodesXEC[OpcodesXEC["OP_OR"] = 133] = "OP_OR";
    OpcodesXEC[OpcodesXEC["OP_XOR"] = 134] = "OP_XOR";
    OpcodesXEC[OpcodesXEC["OP_EQUAL"] = 135] = "OP_EQUAL";
    OpcodesXEC[OpcodesXEC["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
    OpcodesXEC[OpcodesXEC["OP_RESERVED1"] = 137] = "OP_RESERVED1";
    OpcodesXEC[OpcodesXEC["OP_RESERVED2"] = 138] = "OP_RESERVED2";
    OpcodesXEC[OpcodesXEC["OP_1ADD"] = 139] = "OP_1ADD";
    OpcodesXEC[OpcodesXEC["OP_1SUB"] = 140] = "OP_1SUB";
    OpcodesXEC[OpcodesXEC["OP_2MUL"] = 141] = "OP_2MUL";
    OpcodesXEC[OpcodesXEC["OP_2DIV"] = 142] = "OP_2DIV";
    OpcodesXEC[OpcodesXEC["OP_NEGATE"] = 143] = "OP_NEGATE";
    OpcodesXEC[OpcodesXEC["OP_ABS"] = 144] = "OP_ABS";
    OpcodesXEC[OpcodesXEC["OP_NOT"] = 145] = "OP_NOT";
    OpcodesXEC[OpcodesXEC["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
    OpcodesXEC[OpcodesXEC["OP_ADD"] = 147] = "OP_ADD";
    OpcodesXEC[OpcodesXEC["OP_SUB"] = 148] = "OP_SUB";
    OpcodesXEC[OpcodesXEC["OP_MUL"] = 149] = "OP_MUL";
    OpcodesXEC[OpcodesXEC["OP_DIV"] = 150] = "OP_DIV";
    OpcodesXEC[OpcodesXEC["OP_MOD"] = 151] = "OP_MOD";
    OpcodesXEC[OpcodesXEC["OP_LSHIFT"] = 152] = "OP_LSHIFT";
    OpcodesXEC[OpcodesXEC["OP_RSHIFT"] = 153] = "OP_RSHIFT";
    OpcodesXEC[OpcodesXEC["OP_BOOLAND"] = 154] = "OP_BOOLAND";
    OpcodesXEC[OpcodesXEC["OP_BOOLOR"] = 155] = "OP_BOOLOR";
    OpcodesXEC[OpcodesXEC["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
    OpcodesXEC[OpcodesXEC["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
    OpcodesXEC[OpcodesXEC["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
    OpcodesXEC[OpcodesXEC["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
    OpcodesXEC[OpcodesXEC["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
    OpcodesXEC[OpcodesXEC["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
    OpcodesXEC[OpcodesXEC["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
    OpcodesXEC[OpcodesXEC["OP_MIN"] = 163] = "OP_MIN";
    OpcodesXEC[OpcodesXEC["OP_MAX"] = 164] = "OP_MAX";
    OpcodesXEC[OpcodesXEC["OP_WITHIN"] = 165] = "OP_WITHIN";
    OpcodesXEC[OpcodesXEC["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
    OpcodesXEC[OpcodesXEC["OP_SHA1"] = 167] = "OP_SHA1";
    OpcodesXEC[OpcodesXEC["OP_SHA256"] = 168] = "OP_SHA256";
    OpcodesXEC[OpcodesXEC["OP_HASH160"] = 169] = "OP_HASH160";
    OpcodesXEC[OpcodesXEC["OP_HASH256"] = 170] = "OP_HASH256";
    OpcodesXEC[OpcodesXEC["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
    OpcodesXEC[OpcodesXEC["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
    OpcodesXEC[OpcodesXEC["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
    OpcodesXEC[OpcodesXEC["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
    OpcodesXEC[OpcodesXEC["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
    OpcodesXEC[OpcodesXEC["OP_NOP1"] = 176] = "OP_NOP1";
    OpcodesXEC[OpcodesXEC["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
    OpcodesXEC[OpcodesXEC["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
    OpcodesXEC[OpcodesXEC["OP_NOP4"] = 179] = "OP_NOP4";
    OpcodesXEC[OpcodesXEC["OP_NOP5"] = 180] = "OP_NOP5";
    OpcodesXEC[OpcodesXEC["OP_NOP6"] = 181] = "OP_NOP6";
    OpcodesXEC[OpcodesXEC["OP_NOP7"] = 182] = "OP_NOP7";
    OpcodesXEC[OpcodesXEC["OP_NOP8"] = 183] = "OP_NOP8";
    OpcodesXEC[OpcodesXEC["OP_NOP9"] = 184] = "OP_NOP9";
    OpcodesXEC[OpcodesXEC["OP_NOP10"] = 185] = "OP_NOP10";
    OpcodesXEC[OpcodesXEC["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
    OpcodesXEC[OpcodesXEC["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
    OpcodesXEC[OpcodesXEC["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
    OpcodesXEC[OpcodesXEC["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesXEC || (OpcodesXEC = {}));

/**
 * Initialize a virtual machine using the XEC instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createVirtualMachineXEC = (standard = true) => createVirtualMachine(createInstructionSetXEC(standard));

const bitcoinSatoshiOpcodes = Object.entries(generateBytecodeMap(OpcodesXEC)).reduce((acc, cur) => ({ ...acc, [cur[0].slice('OP_'.length)]: cur[1] }), {
    PUSHDATA1: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_1), // eslint-disable-line @typescript-eslint/naming-convention
    PUSHDATA2: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_2), // eslint-disable-line @typescript-eslint/naming-convention
    PUSHDATA4: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_4), // eslint-disable-line @typescript-eslint/naming-convention
});
/**
 * Convert a string from the Satoshi implementation's `script_tests.json`
 * text-format to bytecode. The string must be valid – this method attempts to
 * convert all unmatched tokens to `BigInt`s.
 *
 * @privateRemarks
 * This method doesn't use {@link compileScript} because of a slight
 * incompatibility in the languages. In CashAssembly, BigIntLiterals are a
 * primitive type, and must be surrounded by a push statement (e.g. `<100>`) to
 * push a number to the stack. In the `script_tests.json` text-format, numbers
 * are assumed to be pushed. We could implement a transformation after the
 * compiler's parse step, but because this format doesn't require any other
 * features of the compiler, we opt to implement this as a simple method.
 * @param satoshiScript - the script in the Satoshi implementation's
 * `script_tests.json` text format
 */
const assembleBitcoinSatoshiScript = (satoshiScript) => flattenBinArray(satoshiScript
    .split(' ')
    .filter((token) => token !== '')
    .map((token) => token.startsWith('0x')
    ? hexToBin(token.slice('0x'.length))
    : token.startsWith("'")
        ? encodeDataPush(utf8ToBin(token.slice(1, token.length - 1)))
        : bitcoinSatoshiOpcodes[token] ??
            encodeDataPush(bigIntToVmNumber(BigInt(token)))));

var OpcodeDescriptionsBCH2022;
(function (OpcodeDescriptionsBCH2022) {
    OpcodeDescriptionsBCH2022["OP_0"] = "Push the VM Number 0 onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCH2022["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
    OpcodeDescriptionsBCH2022["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_1"] = "Push a 1 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_2"] = "Push a 2 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_3"] = "Push a 3 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_4"] = "Push a 4 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_5"] = "Push a 5 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_6"] = "Push a 6 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_7"] = "Push a 7 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_8"] = "Push a 8 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_9"] = "Push a 9 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_10"] = "Push a 10 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_11"] = "Push a 11 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_12"] = "Push a 12 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_13"] = "Push a 13 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_14"] = "Push a 14 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_15"] = "Push a 15 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_16"] = "Push a 16 (VM Number) onto the stack.";
    OpcodeDescriptionsBCH2022["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
    OpcodeDescriptionsBCH2022["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBCH2022["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBCH2022["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
    OpcodeDescriptionsBCH2022["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
    OpcodeDescriptionsBCH2022["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
    OpcodeDescriptionsBCH2022["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
    OpcodeDescriptionsBCH2022["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
    OpcodeDescriptionsBCH2022["OP_RETURN"] = "Error when executed.";
    OpcodeDescriptionsBCH2022["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
    OpcodeDescriptionsBCH2022["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
    OpcodeDescriptionsBCH2022["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
    OpcodeDescriptionsBCH2022["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
    OpcodeDescriptionsBCH2022["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
    OpcodeDescriptionsBCH2022["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
    OpcodeDescriptionsBCH2022["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
    OpcodeDescriptionsBCH2022["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
    OpcodeDescriptionsBCH2022["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
    OpcodeDescriptionsBCH2022["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
    OpcodeDescriptionsBCH2022["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
    OpcodeDescriptionsBCH2022["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
    OpcodeDescriptionsBCH2022["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
    OpcodeDescriptionsBCH2022["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
    OpcodeDescriptionsBCH2022["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
    OpcodeDescriptionsBCH2022["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
    OpcodeDescriptionsBCH2022["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
    OpcodeDescriptionsBCH2022["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
    OpcodeDescriptionsBCH2022["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
    OpcodeDescriptionsBCH2022["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
    OpcodeDescriptionsBCH2022["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
    OpcodeDescriptionsBCH2022["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
    OpcodeDescriptionsBCH2022["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
    OpcodeDescriptionsBCH2022["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCH2022["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCH2022["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCH2022["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2022["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
    OpcodeDescriptionsBCH2022["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
    OpcodeDescriptionsBCH2022["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
    OpcodeDescriptionsBCH2022["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
    OpcodeDescriptionsBCH2022["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
    OpcodeDescriptionsBCH2022["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
    OpcodeDescriptionsBCH2022["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
    OpcodeDescriptionsBCH2022["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
    OpcodeDescriptionsBCH2022["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
    OpcodeDescriptionsBCH2022["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
    OpcodeDescriptionsBCH2022["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
    OpcodeDescriptionsBCH2022["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
    OpcodeDescriptionsBCH2022["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
    OpcodeDescriptionsBCH2022["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2022["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
    OpcodeDescriptionsBCH2022["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
    OpcodeDescriptionsBCH2022["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
    OpcodeDescriptionsBCH2022["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2022["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2022["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2022["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2022["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
    OpcodeDescriptionsBCH2022["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
    OpcodeDescriptionsBCH2022["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2022["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2022["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
    OpcodeDescriptionsBCH2022["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
    OpcodeDescriptionsBCH2022["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
    OpcodeDescriptionsBCH2022["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCH2022["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCH2022["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
    OpcodeDescriptionsBCH2022["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
    OpcodeDescriptionsBCH2022["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
    OpcodeDescriptionsBCH2022["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash \u2013 the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack in OP_HASH256 byte order.";
    OpcodeDescriptionsBCH2022["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index \u2013 the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
    OpcodeDescriptionsBCH2022["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
    OpcodeDescriptionsBCH2022["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
})(OpcodeDescriptionsBCH2022 || (OpcodeDescriptionsBCH2022 = {}));

var AuthenticationErrorBCH2022;
(function (AuthenticationErrorBCH2022) {
    AuthenticationErrorBCH2022["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length (8 bytes).";
})(AuthenticationErrorBCH2022 || (AuthenticationErrorBCH2022 = {}));

// TODO: replace with scenarios
const createTestAuthenticationProgramBCH = ({ lockingBytecode, valueSatoshis, unlockingBytecode, }) => {
    const testFundingTransaction = {
        inputs: [
            {
                outpointIndex: 0xffffffff,
                outpointTransactionHash: hexToBin('0000000000000000000000000000000000000000000000000000000000000000'),
                sequenceNumber: 0xffffffff,
                unlockingBytecode: Uint8Array.of(0, 0),
            },
        ],
        locktime: 0,
        outputs: [{ lockingBytecode, valueSatoshis }],
        version: 1,
    };
    const testSpendingTransaction = {
        inputs: [
            {
                outpointIndex: 0,
                outpointTransactionHash: hashTransactionP2pOrder(encodeTransactionCommon(testFundingTransaction)),
                sequenceNumber: 0xffffffff,
                unlockingBytecode,
            },
        ],
        locktime: 0,
        outputs: [{ lockingBytecode: Uint8Array.of(), valueSatoshis }],
        version: 1,
    };
    return {
        inputIndex: 0,
        sourceOutputs: testFundingTransaction.outputs,
        transaction: testSpendingTransaction,
    };
};

/**
 * Initialize a virtual machine using the BCH instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createVirtualMachineBCH2022 = (standard = true) => createVirtualMachine(createInstructionSetBCH2022(standard));

var AuthenticationErrorBCHCHIPs;
(function (AuthenticationErrorBCHCHIPs) {
    AuthenticationErrorBCHCHIPs["invalidBoolean"] = "Invalid input: this operation requires a valid boolean (VM Number 0 or VM Number 1).";
    AuthenticationErrorBCHCHIPs["unexpectedUntil"] = "Encountered an OP_UNTIL that is not following a matching OP_BEGIN.";
    AuthenticationErrorBCHCHIPs["excessiveHashing"] = "Program attempted a hashing operation that would exceed the hashing limit (660 hash digest iterations).";
    AuthenticationErrorBCHCHIPs["excessiveLooping"] = "Program attempted an OP_UNTIL operation that would exceed the limit of repeated bytes (10,000 bytes minus active bytecode length).";
})(AuthenticationErrorBCHCHIPs || (AuthenticationErrorBCHCHIPs = {}));

/**
 * Consensus settings for the `BCH_CHIPs` instruction set.
 */
var ConsensusBCHCHIPs;
(function (ConsensusBCHCHIPs) {
    ConsensusBCHCHIPs[ConsensusBCHCHIPs["maximumTransactionVersion"] = 2] = "maximumTransactionVersion";
    ConsensusBCHCHIPs[ConsensusBCHCHIPs["bannedTransactionSize"] = 64] = "bannedTransactionSize";
    ConsensusBCHCHIPs[ConsensusBCHCHIPs["maximumHashDigestIterations"] = 660] = "maximumHashDigestIterations";
})(ConsensusBCHCHIPs || (ConsensusBCHCHIPs = {}));
/**
 * @deprecated use `structuredClone` instead
 */
const cloneAuthenticationProgramStateBCHCHIPs = (state) => ({
    ...(state.error === undefined ? {} : { error: state.error }),
    alternateStack: cloneStack(state.alternateStack),
    controlStack: state.controlStack.slice(),
    hashDigestIterations: state.hashDigestIterations,
    instructions: state.instructions.map(cloneAuthenticationInstruction),
    ip: state.ip,
    lastCodeSeparator: state.lastCodeSeparator,
    program: cloneAuthenticationProgramCommon(state.program),
    repeatedBytes: state.repeatedBytes,
    signedMessages: state.signedMessages.map((item) => ({
        digest: item.digest.slice(),
        ...('serialization' in item
            ? { serialization: item.serialization.slice() }
            : { message: item.message.slice() }),
    })),
    stack: cloneStack(state.stack),
});
const createAuthenticationProgramStateBCHCHIPs = ({ program, instructions, stack, }) => ({
    alternateStack: [],
    controlStack: [],
    hashDigestIterations: 0,
    instructions,
    ip: 0,
    lastCodeSeparator: -1,
    program,
    repeatedBytes: 0,
    signedMessages: [],
    stack,
});

/**
 * Given a message length, compute and return the number of hash digest
 * iterations required. (See `CHIP-2021-05-vm-limits`)
 */
const hashDigestIterations = (messageLength) => 
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
1 + (((messageLength + 8) / 64) | 0);
/**
 * Given a program state, increment the hash digest iteration count for a
 * message of the provided length. If the total would exceed the maximum, append
 * an error.
 *
 * @param state - the program state
 * @param messageLength - the message length
 * @param operation - the operation to execute if no error occurred
 */
const incrementHashDigestIterations = (state, messageLength, operation) => {
    const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(messageLength);
    if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
        return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
    }
    return operation(state);
};
const opRipemd160ChipLimits = ({ ripemd160: ripemd160$1, } = { ripemd160: ripemd160 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, ripemd160$1.hash(value))));
const opSha1ChipLimits = ({ sha1: sha1$1, } = { sha1: sha1 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, sha1$1.hash(value))));
const opSha256ChipLimits = ({ sha256: sha256$1, } = { sha256: sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, sha256$1.hash(value))));
const opHash160ChipLimits = ({ ripemd160: ripemd160$1, sha256: sha256$1, } = { ripemd160: ripemd160, sha256: sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, ripemd160$1.hash(sha256$1.hash(value)))));
const opHash256ChipLimits = ({ sha256: sha256$1, } = { sha256: sha256 }) => (state) => useOneStackItem(state, (nextState, [value]) => incrementHashDigestIterations(nextState, value.length, (finalState) => pushToStack(finalState, hash256(value, sha256$1))));
const opCheckSigChipLimits = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => (s) => 
// eslint-disable-next-line complexity
useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!isValidPublicKeyEncoding(publicKey)) {
        return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
        return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
    }
    const coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha256$1);
    const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(serialization.length);
    if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
        return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
    }
    const digest = hash256(serialization, sha256$1);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.signedMessages.push({ digest, serialization });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1$1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0
        ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure)
        : pushToStack(state, booleanToVmNumber(success));
});
// TODO: implement schnorr multisig https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2019-11-15-schnorrmultisig.md
const opCheckMultiSigChipLimits = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => (s) => useOneVmNumber(s, (state, publicKeysValue) => {
    const potentialPublicKeys = Number(publicKeysValue);
    if (potentialPublicKeys < 0) {
        return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
    }
    if (potentialPublicKeys > 20 /* Multisig.maximumPublicKeys */) {
        return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
    }
    const publicKeys = 
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
    return useOneVmNumber(state, (nextState, approvingKeys) => {
        const requiredApprovingPublicKeys = Number(approvingKeys);
        if (requiredApprovingPublicKeys < 0) {
            return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
        }
        if (requiredApprovingPublicKeys > potentialPublicKeys) {
            return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
        }
        const signatures = requiredApprovingPublicKeys > 0
            ? // eslint-disable-next-line functional/immutable-data
                nextState.stack.splice(-requiredApprovingPublicKeys)
            : [];
        return useOneStackItem(nextState, 
        // eslint-disable-next-line complexity
        (finalState, [protocolBugValue]) => {
            if (protocolBugValue.length !== 0) {
                return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
            }
            const coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
            let approvingPublicKeys = 0; // eslint-disable-line functional/no-let
            let remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
            let remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
            // eslint-disable-next-line functional/no-loop-statements
            while (remainingSignatures > 0 &&
                remainingPublicKeys > 0 &&
                approvingPublicKeys + remainingPublicKeys >=
                    remainingSignatures &&
                approvingPublicKeys !== requiredApprovingPublicKeys) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const publicKey = publicKeys[remainingPublicKeys - 1];
                const bitcoinEncodedSignature = 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                signatures[remainingSignatures - 1];
                if (!isValidPublicKeyEncoding(publicKey)) {
                    return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
                }
                if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
                    return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, `Transaction signature (including signing serialization type): ${binToHex(bitcoinEncodedSignature)}`);
                }
                const { signingSerializationType, signature } = decodeBitcoinSignature(bitcoinEncodedSignature);
                const serialization = generateSigningSerializationBCH(state.program, { coveredBytecode, signingSerializationType }, sha256$1);
                const requiredTotalIterations = state.hashDigestIterations +
                    hashDigestIterations(serialization.length);
                if (requiredTotalIterations >
                    ConsensusBCHCHIPs.maximumHashDigestIterations) {
                    return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
                }
                const digest = hash256(serialization, sha256$1);
                // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
                finalState.signedMessages.push({ digest, serialization });
                if (signature.length === ConsensusCommon.schnorrSignatureLength) {
                    return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
                }
                const signed = secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
                // eslint-disable-next-line functional/no-conditional-statements
                if (signed) {
                    approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statements
                    remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statements
                }
                remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statements
            }
            const success = approvingPublicKeys === requiredApprovingPublicKeys;
            if (!success &&
                !signatures.every((signature) => signature.length === 0)) {
                return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
            }
            return pushToStack(finalState, booleanToVmNumber(success));
        });
    });
});
const opCheckSigVerifyChipLimits = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => combineOperations(opCheckSigChipLimits({ secp256k1: secp256k1$1, sha256: sha256$1 }), opVerify);
const opCheckMultiSigVerifyChipLimits = ({ secp256k1, sha256, }) => combineOperations(opCheckMultiSigChipLimits({ secp256k1, sha256 }), opVerify);
const opCheckDataSigChipLimits = ({ secp256k1, sha256, }) => (state) => 
// eslint-disable-next-line complexity
useThreeStackItems(state, (nextState, [signature, message, publicKey]) => {
    if (!isValidSignatureEncodingBCHRaw(signature)) {
        return applyError(nextState, AuthenticationErrorCommon.invalidSignatureEncoding, `Data signature: ${binToHex(signature)}`);
    }
    if (!isValidPublicKeyEncoding(publicKey)) {
        return applyError(nextState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
    }
    const requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(message.length);
    if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
        return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, `Required cumulative iterations: ${requiredTotalIterations}`);
    }
    const digest = sha256.hash(message);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    nextState.signedMessages.push({ digest, message });
    const useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0
        ? applyError(nextState, AuthenticationErrorCommon.nonNullSignatureFailure)
        : pushToStack(nextState, booleanToVmNumber(success));
});
const opCheckDataSigVerifyChipLimits = ({ secp256k1: secp256k1$1, sha256: sha256$1, } = { secp256k1: secp256k1, sha256: sha256 }) => combineOperations(opCheckDataSigChipLimits({ secp256k1: secp256k1$1, sha256: sha256$1 }), opVerify);

var OpcodeDescriptionsBCHCHIPs;
(function (OpcodeDescriptionsBCHCHIPs) {
    OpcodeDescriptionsBCHCHIPs["OP_0"] = "Push the VM Number 0 onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_1"] = "Push a 1 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_2"] = "Push a 2 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_3"] = "Push a 3 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_4"] = "Push a 4 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_5"] = "Push a 5 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_6"] = "Push a 6 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_7"] = "Push a 7 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_8"] = "Push a 8 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_9"] = "Push a 9 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_10"] = "Push a 10 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_11"] = "Push a 11 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_12"] = "Push a 12 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_13"] = "Push a 13 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_14"] = "Push a 14 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_15"] = "Push a 15 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_16"] = "Push a 16 (VM Number) onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
    OpcodeDescriptionsBCHCHIPs["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBCHCHIPs["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBCHCHIPs["OP_BEGIN"] = "Push the current instruction pointer index to the control stack as an integer (to be read by OP_UNTIL).";
    OpcodeDescriptionsBCHCHIPs["OP_UNTIL"] = "Pop the top item from the control stack (if the control value is not an integer, error). Add the difference between the control value and the current instruction pointer index to the repeated bytes counter, if the sum of the repeated bytes counter and the active bytecode length is greater than the maximum bytecode length, error. Pop the top item from the stack, if the value is a 0 (VM Number), move the instruction pointer to the control value (and re-evaluate the OP_BEGIN).";
    OpcodeDescriptionsBCHCHIPs["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
    OpcodeDescriptionsBCHCHIPs["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
    OpcodeDescriptionsBCHCHIPs["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
    OpcodeDescriptionsBCHCHIPs["OP_RETURN"] = "Error when executed.";
    OpcodeDescriptionsBCHCHIPs["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
    OpcodeDescriptionsBCHCHIPs["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
    OpcodeDescriptionsBCHCHIPs["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
    OpcodeDescriptionsBCHCHIPs["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
    OpcodeDescriptionsBCHCHIPs["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
    OpcodeDescriptionsBCHCHIPs["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
    OpcodeDescriptionsBCHCHIPs["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
    OpcodeDescriptionsBCHCHIPs["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
    OpcodeDescriptionsBCHCHIPs["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
    OpcodeDescriptionsBCHCHIPs["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
    OpcodeDescriptionsBCHCHIPs["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
    OpcodeDescriptionsBCHCHIPs["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
    OpcodeDescriptionsBCHCHIPs["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
    OpcodeDescriptionsBCHCHIPs["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
    OpcodeDescriptionsBCHCHIPs["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
    OpcodeDescriptionsBCHCHIPs["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
    OpcodeDescriptionsBCHCHIPs["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
    OpcodeDescriptionsBCHCHIPs["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
    OpcodeDescriptionsBCHCHIPs["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
    OpcodeDescriptionsBCHCHIPs["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
    OpcodeDescriptionsBCHCHIPs["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
    OpcodeDescriptionsBCHCHIPs["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
    OpcodeDescriptionsBCHCHIPs["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCHCHIPs["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCHCHIPs["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
    OpcodeDescriptionsBCHCHIPs["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBCHCHIPs["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
    OpcodeDescriptionsBCHCHIPs["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
    OpcodeDescriptionsBCHCHIPs["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
    OpcodeDescriptionsBCHCHIPs["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
    OpcodeDescriptionsBCHCHIPs["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
    OpcodeDescriptionsBCHCHIPs["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBCHCHIPs["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
    OpcodeDescriptionsBCHCHIPs["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
    OpcodeDescriptionsBCHCHIPs["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
    OpcodeDescriptionsBCHCHIPs["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCHCHIPs["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBCHCHIPs["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
    OpcodeDescriptionsBCHCHIPs["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
    OpcodeDescriptionsBCHCHIPs["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash \u2013 the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack in OP_HASH256 byte order.";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index \u2013 the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
    OpcodeDescriptionsBCHCHIPs["OP_UTXOTOKENCATEGORY"] = "Pop the top item from the stack as an input index (VM Number). If the Unspent Transaction Output (UTXO) spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the UTXO does not include a non-fungible token with a capability, push the UTXO's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_UTXOTOKENCOMMITMENT"] = "Pop the top item from the stack as an input index (VM Number). Push the token commitment of the Unspent Transaction Output (UTXO) spent by that input to the stack. If the UTXO does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_UTXOTOKENAMOUNT"] = "Pop the top item from the stack as an input index (VM Number). Push the fungible token amount of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number. If the UTXO includes no fungible tokens, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPUTTOKENCATEGORY"] = "Pop the top item from the stack as an output index (VM Number). If the output spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the output does not include a non-fungible token with a capability, push the output's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPUTTOKENCOMMITMENT"] = "Pop the top item from the stack as an output index (VM Number). Push the token commitment of the output at that index to the stack. If the output does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
    OpcodeDescriptionsBCHCHIPs["OP_OUTPUTTOKENAMOUNT"] = "Pop the top item from the stack as an output index (VM Number). Push the fungible token amount of the output at that index to the stack as a VM Number. If the output includes no fungible tokens, push a 0 (VM Number).";
})(OpcodeDescriptionsBCHCHIPs || (OpcodeDescriptionsBCHCHIPs = {}));

const executionIsActive = (state) => state.controlStack.every((item) => item !== false);
/**
 * An implementation of {@link conditionallyEvaluate} that supports
 * `CHIP-2021-05-loops`.
 */
const conditionallyEvaluateChipLoops = (operation) => (state) => executionIsActive(state) ? operation(state) : state;
const undefinedOperationChipLoops = conditionallyEvaluateChipLoops((state) => applyError(state, AuthenticationErrorCommon.unknownOpcode));
const pushOperationChipLoops = (maximumPushSize = ConsensusCommon.maximumStackItemLength) => (state) => {
    const instruction = state.instructions[state.ip];
    return instruction.data.length > maximumPushSize
        ? applyError(state, `${AuthenticationErrorCommon.exceededMaximumStackItemLength} Item length: ${instruction.data.length} bytes.`)
        : executionIsActive(state)
            ? isMinimalDataPush(instruction.opcode, instruction.data)
                ? pushToStack(state, instruction.data)
                : applyError(state, AuthenticationErrorCommon.nonMinimalPush)
            : state;
};
/**
 * Return the provided state with the provided value pushed to its control stack.
 * @param state - the state to update and return
 * @param data - the value to push to the stack
 */
const pushToControlStackChipLoops = (state, value) => {
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.controlStack.push(value);
    return state;
};
const opIfChipLoops = (state) => {
    if (executionIsActive(state)) {
        return useOneStackItem(state, (nextState, [item]) => pushToControlStackChipLoops(nextState, stackItemIsTruthy(item)));
    }
    return pushToControlStackChipLoops(state, false);
};
const opNotIfChipLoops = (state) => {
    if (executionIsActive(state)) {
        return useOneStackItem(state, (nextState, [item]) => pushToControlStackChipLoops(nextState, !stackItemIsTruthy(item)));
    }
    return pushToControlStackChipLoops(state, false);
};
const opEndIfChipLoops = (state) => {
    // eslint-disable-next-line functional/immutable-data
    const element = state.controlStack.pop();
    if (typeof element !== 'boolean') {
        return applyError(state, AuthenticationErrorCommon.unexpectedEndIf);
    }
    return state;
};
const opElseChipLoops = (state) => {
    const top = state.controlStack[state.controlStack.length - 1];
    if (typeof top !== 'boolean') {
        return applyError(state, AuthenticationErrorCommon.unexpectedElse);
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.controlStack[state.controlStack.length - 1] = !top;
    return state;
};
const opBegin = (state) => pushToControlStackChipLoops(state, state.ip);
const opUntil = (state) => {
    // eslint-disable-next-line functional/immutable-data
    const controlValue = state.controlStack.pop();
    if (typeof controlValue !== 'number') {
        return applyError(state, AuthenticationErrorBCHCHIPs.unexpectedUntil);
    }
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
    state.repeatedBytes += encodeAuthenticationInstructions(state.instructions.slice(controlValue, state.ip)).length;
    const activeBytecodeLength = encodeAuthenticationInstructions(state.instructions).length;
    if (state.repeatedBytes + activeBytecodeLength >
        ConsensusCommon.maximumBytecodeLength) {
        return applyError(state, AuthenticationErrorBCHCHIPs.excessiveLooping, `Repeated bytes: ${state.repeatedBytes}; active bytecode length: ${activeBytecodeLength}`);
    }
    return useOneStackItem(state, (nextState, [item]) => {
        if (item.length === 1 && item[0] === 1) {
            return nextState;
        }
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        nextState.ip = controlValue - 1;
        return nextState;
    });
};

/**
 * The `BCH_CHIPs` instruction set.
 *
 * Note: to maximize script compilation compatibility, this instruction set also
 * includes the previous names for new opcodes (e.g. `OP_VERIF` for `OP_BEGIN`).
 */
var OpcodesBCHCHIPs;
(function (OpcodesBCHCHIPs) {
    /**
     * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
     */
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_0"] = 0] = "OP_0";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1NEGATE"] = 79] = "OP_1NEGATE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RESERVED"] = 80] = "OP_RESERVED";
    /**
     * A.K.A. `OP_TRUE`
     */
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1"] = 81] = "OP_1";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2"] = 82] = "OP_2";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_3"] = 83] = "OP_3";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_4"] = 84] = "OP_4";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_5"] = 85] = "OP_5";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_6"] = 86] = "OP_6";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_7"] = 87] = "OP_7";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_8"] = 88] = "OP_8";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_9"] = 89] = "OP_9";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_10"] = 90] = "OP_10";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_11"] = 91] = "OP_11";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_12"] = 92] = "OP_12";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_13"] = 93] = "OP_13";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_14"] = 94] = "OP_14";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_15"] = 95] = "OP_15";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_16"] = 96] = "OP_16";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP"] = 97] = "OP_NOP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VER"] = 98] = "OP_VER";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_IF"] = 99] = "OP_IF";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOTIF"] = 100] = "OP_NOTIF";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VERIF"] = 101] = "OP_VERIF";
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BEGIN"] = 101] = "OP_BEGIN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNTIL"] = 102] = "OP_UNTIL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ELSE"] = 103] = "OP_ELSE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ENDIF"] = 104] = "OP_ENDIF";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VERIFY"] = 105] = "OP_VERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RETURN"] = 106] = "OP_RETURN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2DROP"] = 109] = "OP_2DROP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2DUP"] = 110] = "OP_2DUP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_3DUP"] = 111] = "OP_3DUP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2OVER"] = 112] = "OP_2OVER";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2ROT"] = 113] = "OP_2ROT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2SWAP"] = 114] = "OP_2SWAP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_IFDUP"] = 115] = "OP_IFDUP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DEPTH"] = 116] = "OP_DEPTH";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DROP"] = 117] = "OP_DROP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DUP"] = 118] = "OP_DUP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NIP"] = 119] = "OP_NIP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OVER"] = 120] = "OP_OVER";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PICK"] = 121] = "OP_PICK";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ROLL"] = 122] = "OP_ROLL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ROT"] = 123] = "OP_ROT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SWAP"] = 124] = "OP_SWAP";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TUCK"] = 125] = "OP_TUCK";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CAT"] = 126] = "OP_CAT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SPLIT"] = 127] = "OP_SPLIT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SIZE"] = 130] = "OP_SIZE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INVERT"] = 131] = "OP_INVERT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_AND"] = 132] = "OP_AND";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OR"] = 133] = "OP_OR";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_XOR"] = 134] = "OP_XOR";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_EQUAL"] = 135] = "OP_EQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RESERVED1"] = 137] = "OP_RESERVED1";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RESERVED2"] = 138] = "OP_RESERVED2";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1ADD"] = 139] = "OP_1ADD";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1SUB"] = 140] = "OP_1SUB";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2MUL"] = 141] = "OP_2MUL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2DIV"] = 142] = "OP_2DIV";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NEGATE"] = 143] = "OP_NEGATE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ABS"] = 144] = "OP_ABS";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOT"] = 145] = "OP_NOT";
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_0EQUAL"] = 145] = "OP_0EQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ADD"] = 147] = "OP_ADD";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SUB"] = 148] = "OP_SUB";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MUL"] = 149] = "OP_MUL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DIV"] = 150] = "OP_DIV";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MOD"] = 151] = "OP_MOD";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_LSHIFT"] = 152] = "OP_LSHIFT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RSHIFT"] = 153] = "OP_RSHIFT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BOOLAND"] = 154] = "OP_BOOLAND";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BOOLOR"] = 155] = "OP_BOOLOR";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MIN"] = 163] = "OP_MIN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MAX"] = 164] = "OP_MAX";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_WITHIN"] = 165] = "OP_WITHIN";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SHA1"] = 167] = "OP_SHA1";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SHA256"] = 168] = "OP_SHA256";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_HASH160"] = 169] = "OP_HASH160";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_HASH256"] = 170] = "OP_HASH256";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP1"] = 176] = "OP_NOP1";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP4"] = 179] = "OP_NOP4";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP5"] = 180] = "OP_NOP5";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP6"] = 181] = "OP_NOP6";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP7"] = 182] = "OP_NOP7";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP8"] = 183] = "OP_NOP8";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP9"] = 184] = "OP_NOP9";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP10"] = 185] = "OP_NOP10";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
    /**
     * First codepoint left undefined before nullary introspection operations.
     */
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
    /**
     * Last codepoint left undefined before nullary introspection operations.
     */
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXVERSION"] = 194] = "OP_TXVERSION";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOTOKENCATEGORY"] = 206] = "OP_UTXOTOKENCATEGORY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOTOKENCOMMITMENT"] = 207] = "OP_UTXOTOKENCOMMITMENT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOTOKENAMOUNT"] = 208] = "OP_UTXOTOKENAMOUNT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTTOKENCATEGORY"] = 209] = "OP_OUTPUTTOKENCATEGORY";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTTOKENCOMMITMENT"] = 210] = "OP_OUTPUTTOKENCOMMITMENT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTTOKENAMOUNT"] = 211] = "OP_OUTPUTTOKENAMOUNT";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
    OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCHCHIPs || (OpcodesBCHCHIPs = {}));

/**
 * create an instance of the BCH CHIPs virtual machine instruction set, an
 * informal, speculative instruction set that implements a variety of future
 * Bitcoin Cash Improvement Proposals (CHIPs).
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createInstructionSetBCHCHIPs = (standard = true, { ripemd160: ripemd160$1, secp256k1: secp256k1$1, sha1: sha1$1, sha256: sha256$1, } = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha1: sha1,
    sha256: sha256,
}) => {
    const conditionallyPush = pushOperationChipLoops();
    return {
        clone: cloneAuthenticationProgramStateBCHCHIPs,
        continue: (state) => state.error === undefined && state.ip < state.instructions.length,
        // eslint-disable-next-line complexity
        evaluate: (program, stateEvaluate) => {
            const { unlockingBytecode } = 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            program.transaction.inputs[program.inputIndex];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const { lockingBytecode } = program.sourceOutputs[program.inputIndex];
            const unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
            const lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
            const initialState = createAuthenticationProgramStateBCHCHIPs({
                instructions: unlockingInstructions,
                program,
                stack: [],
            });
            if (unlockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
                return applyError(initialState, `The provided unlocking bytecode (${unlockingBytecode.length} bytes) exceeds the maximum bytecode length (${ConsensusBCH.maximumBytecodeLength} bytes).`);
            }
            if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
                return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
            }
            if (!isPushOnly(unlockingBytecode)) {
                return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
            }
            if (lockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
                return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
            }
            if (authenticationInstructionsAreMalformed(lockingInstructions)) {
                return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
            }
            const unlockingResult = stateEvaluate(initialState);
            if (unlockingResult.error !== undefined) {
                return unlockingResult;
            }
            if (unlockingResult.controlStack.length !== 0) {
                return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
            }
            const lockingResult = stateEvaluate(createAuthenticationProgramStateBCHCHIPs({
                instructions: lockingInstructions,
                program,
                stack: unlockingResult.stack,
            }));
            if (!isPayToScriptHash20(lockingBytecode)) {
                return lockingResult;
            }
            const p2shStack = cloneStack(unlockingResult.stack);
            // eslint-disable-next-line functional/immutable-data
            const p2shScript = p2shStack.pop() ?? Uint8Array.of();
            if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
                return lockingResult;
            }
            const p2shInstructions = decodeAuthenticationInstructions(p2shScript);
            return authenticationInstructionsAreMalformed(p2shInstructions)
                ? {
                    ...lockingResult,
                    error: AuthenticationErrorCommon.malformedP2shBytecode,
                }
                : stateEvaluate(createAuthenticationProgramStateBCHCHIPs({
                    instructions: p2shInstructions,
                    program,
                    stack: p2shStack,
                }));
        },
        every: (state) => {
            if (state.stack.length + state.alternateStack.length >
                ConsensusBCH.maximumStackDepth) {
                return applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth);
            }
            return state;
        },
        operations: {
            [OpcodesBCHCHIPs.OP_0]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_1]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_2]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_3]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_4]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_5]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_6]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_7]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_8]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_9]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_10]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_11]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_12]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_13]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_14]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_15]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_16]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_17]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_18]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_19]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_20]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_21]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_22]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_23]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_24]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_25]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_26]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_27]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_28]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_29]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_30]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_31]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_32]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_33]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_34]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_35]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_36]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_37]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_38]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_39]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_40]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_41]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_42]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_43]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_44]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_45]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_46]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_47]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_48]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_49]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_50]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_51]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_52]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_53]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_54]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_55]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_56]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_57]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_58]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_59]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_60]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_61]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_62]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_63]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_64]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_65]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_66]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_67]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_68]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_69]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_70]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_71]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_72]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_73]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_74]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHBYTES_75]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHDATA_1]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHDATA_2]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_PUSHDATA_4]: conditionallyPush,
            [OpcodesBCHCHIPs.OP_1NEGATE]: conditionallyEvaluateChipLoops(pushNumberOperation(-1)),
            [OpcodesBCHCHIPs.OP_RESERVED]: conditionallyEvaluateChipLoops(reservedOperation),
            [OpcodesBCHCHIPs.OP_1]: conditionallyEvaluateChipLoops(pushNumberOperation(1)),
            /* eslint-disable @typescript-eslint/no-magic-numbers */
            [OpcodesBCHCHIPs.OP_2]: conditionallyEvaluateChipLoops(pushNumberOperation(2)),
            [OpcodesBCHCHIPs.OP_3]: conditionallyEvaluateChipLoops(pushNumberOperation(3)),
            [OpcodesBCHCHIPs.OP_4]: conditionallyEvaluateChipLoops(pushNumberOperation(4)),
            [OpcodesBCHCHIPs.OP_5]: conditionallyEvaluateChipLoops(pushNumberOperation(5)),
            [OpcodesBCHCHIPs.OP_6]: conditionallyEvaluateChipLoops(pushNumberOperation(6)),
            [OpcodesBCHCHIPs.OP_7]: conditionallyEvaluateChipLoops(pushNumberOperation(7)),
            [OpcodesBCHCHIPs.OP_8]: conditionallyEvaluateChipLoops(pushNumberOperation(8)),
            [OpcodesBCHCHIPs.OP_9]: conditionallyEvaluateChipLoops(pushNumberOperation(9)),
            [OpcodesBCHCHIPs.OP_10]: conditionallyEvaluateChipLoops(pushNumberOperation(10)),
            [OpcodesBCHCHIPs.OP_11]: conditionallyEvaluateChipLoops(pushNumberOperation(11)),
            [OpcodesBCHCHIPs.OP_12]: conditionallyEvaluateChipLoops(pushNumberOperation(12)),
            [OpcodesBCHCHIPs.OP_13]: conditionallyEvaluateChipLoops(pushNumberOperation(13)),
            [OpcodesBCHCHIPs.OP_14]: conditionallyEvaluateChipLoops(pushNumberOperation(14)),
            [OpcodesBCHCHIPs.OP_15]: conditionallyEvaluateChipLoops(pushNumberOperation(15)),
            [OpcodesBCHCHIPs.OP_16]: conditionallyEvaluateChipLoops(pushNumberOperation(16)),
            /* eslint-enable @typescript-eslint/no-magic-numbers */
            [OpcodesBCHCHIPs.OP_NOP]: conditionallyEvaluateChipLoops(opNop),
            [OpcodesBCHCHIPs.OP_VER]: conditionallyEvaluateChipLoops(reservedOperation),
            [OpcodesBCHCHIPs.OP_IF]: opIfChipLoops,
            [OpcodesBCHCHIPs.OP_NOTIF]: opNotIfChipLoops,
            [OpcodesBCHCHIPs.OP_BEGIN]: conditionallyEvaluateChipLoops(opBegin),
            [OpcodesBCHCHIPs.OP_UNTIL]: conditionallyEvaluateChipLoops(opUntil),
            [OpcodesBCHCHIPs.OP_ELSE]: opElseChipLoops,
            [OpcodesBCHCHIPs.OP_ENDIF]: opEndIfChipLoops,
            [OpcodesBCHCHIPs.OP_VERIFY]: conditionallyEvaluateChipLoops(opVerify),
            [OpcodesBCHCHIPs.OP_RETURN]: conditionallyEvaluateChipLoops(opReturn),
            [OpcodesBCHCHIPs.OP_TOALTSTACK]: conditionallyEvaluateChipLoops(opToAltStack),
            [OpcodesBCHCHIPs.OP_FROMALTSTACK]: conditionallyEvaluateChipLoops(opFromAltStack),
            [OpcodesBCHCHIPs.OP_2DROP]: conditionallyEvaluateChipLoops(op2Drop),
            [OpcodesBCHCHIPs.OP_2DUP]: conditionallyEvaluateChipLoops(op2Dup),
            [OpcodesBCHCHIPs.OP_3DUP]: conditionallyEvaluateChipLoops(op3Dup),
            [OpcodesBCHCHIPs.OP_2OVER]: conditionallyEvaluateChipLoops(op2Over),
            [OpcodesBCHCHIPs.OP_2ROT]: conditionallyEvaluateChipLoops(op2Rot),
            [OpcodesBCHCHIPs.OP_2SWAP]: conditionallyEvaluateChipLoops(op2Swap),
            [OpcodesBCHCHIPs.OP_IFDUP]: conditionallyEvaluateChipLoops(opIfDup),
            [OpcodesBCHCHIPs.OP_DEPTH]: conditionallyEvaluateChipLoops(opDepth),
            [OpcodesBCHCHIPs.OP_DROP]: conditionallyEvaluateChipLoops(opDrop),
            [OpcodesBCHCHIPs.OP_DUP]: conditionallyEvaluateChipLoops(opDup),
            [OpcodesBCHCHIPs.OP_NIP]: conditionallyEvaluateChipLoops(opNip),
            [OpcodesBCHCHIPs.OP_OVER]: conditionallyEvaluateChipLoops(opOver),
            [OpcodesBCHCHIPs.OP_PICK]: conditionallyEvaluateChipLoops(opPick),
            [OpcodesBCHCHIPs.OP_ROLL]: conditionallyEvaluateChipLoops(opRoll),
            [OpcodesBCHCHIPs.OP_ROT]: conditionallyEvaluateChipLoops(opRot),
            [OpcodesBCHCHIPs.OP_SWAP]: conditionallyEvaluateChipLoops(opSwap),
            [OpcodesBCHCHIPs.OP_TUCK]: conditionallyEvaluateChipLoops(opTuck),
            [OpcodesBCHCHIPs.OP_CAT]: conditionallyEvaluateChipLoops(opCat),
            [OpcodesBCHCHIPs.OP_SPLIT]: conditionallyEvaluateChipLoops(opSplit),
            [OpcodesBCHCHIPs.OP_NUM2BIN]: conditionallyEvaluateChipLoops(opNum2Bin),
            [OpcodesBCHCHIPs.OP_BIN2NUM]: conditionallyEvaluateChipLoops(opBin2Num),
            [OpcodesBCHCHIPs.OP_SIZE]: conditionallyEvaluateChipLoops(opSize),
            [OpcodesBCHCHIPs.OP_INVERT]: disabledOperation,
            [OpcodesBCHCHIPs.OP_AND]: conditionallyEvaluateChipLoops(opAnd),
            [OpcodesBCHCHIPs.OP_OR]: conditionallyEvaluateChipLoops(opOr),
            [OpcodesBCHCHIPs.OP_XOR]: conditionallyEvaluateChipLoops(opXor),
            [OpcodesBCHCHIPs.OP_EQUAL]: conditionallyEvaluateChipLoops(opEqual),
            [OpcodesBCHCHIPs.OP_EQUALVERIFY]: conditionallyEvaluateChipLoops(opEqualVerify),
            [OpcodesBCHCHIPs.OP_RESERVED1]: conditionallyEvaluateChipLoops(reservedOperation),
            [OpcodesBCHCHIPs.OP_RESERVED2]: conditionallyEvaluateChipLoops(reservedOperation),
            [OpcodesBCHCHIPs.OP_1ADD]: conditionallyEvaluateChipLoops(op1Add),
            [OpcodesBCHCHIPs.OP_1SUB]: conditionallyEvaluateChipLoops(op1Sub),
            [OpcodesBCHCHIPs.OP_2MUL]: disabledOperation,
            [OpcodesBCHCHIPs.OP_2DIV]: disabledOperation,
            [OpcodesBCHCHIPs.OP_NEGATE]: conditionallyEvaluateChipLoops(opNegate),
            [OpcodesBCHCHIPs.OP_ABS]: conditionallyEvaluateChipLoops(opAbs),
            [OpcodesBCHCHIPs.OP_NOT]: conditionallyEvaluateChipLoops(opNot),
            [OpcodesBCHCHIPs.OP_0NOTEQUAL]: conditionallyEvaluateChipLoops(op0NotEqual),
            [OpcodesBCHCHIPs.OP_ADD]: conditionallyEvaluateChipLoops(opAdd),
            [OpcodesBCHCHIPs.OP_SUB]: conditionallyEvaluateChipLoops(opSub),
            [OpcodesBCHCHIPs.OP_MUL]: conditionallyEvaluateChipLoops(opMul),
            [OpcodesBCHCHIPs.OP_DIV]: conditionallyEvaluateChipLoops(opDiv),
            [OpcodesBCHCHIPs.OP_MOD]: conditionallyEvaluateChipLoops(opMod),
            [OpcodesBCHCHIPs.OP_LSHIFT]: disabledOperation,
            [OpcodesBCHCHIPs.OP_RSHIFT]: disabledOperation,
            [OpcodesBCHCHIPs.OP_BOOLAND]: conditionallyEvaluateChipLoops(opBoolAnd),
            [OpcodesBCHCHIPs.OP_BOOLOR]: conditionallyEvaluateChipLoops(opBoolOr),
            [OpcodesBCHCHIPs.OP_NUMEQUAL]: conditionallyEvaluateChipLoops(opNumEqual),
            [OpcodesBCHCHIPs.OP_NUMEQUALVERIFY]: conditionallyEvaluateChipLoops(opNumEqualVerify),
            [OpcodesBCHCHIPs.OP_NUMNOTEQUAL]: conditionallyEvaluateChipLoops(opNumNotEqual),
            [OpcodesBCHCHIPs.OP_LESSTHAN]: conditionallyEvaluateChipLoops(opLessThan),
            [OpcodesBCHCHIPs.OP_GREATERTHAN]: conditionallyEvaluateChipLoops(opGreaterThan),
            [OpcodesBCHCHIPs.OP_LESSTHANOREQUAL]: conditionallyEvaluateChipLoops(opLessThanOrEqual),
            [OpcodesBCHCHIPs.OP_GREATERTHANOREQUAL]: conditionallyEvaluateChipLoops(opGreaterThanOrEqual),
            [OpcodesBCHCHIPs.OP_MIN]: conditionallyEvaluateChipLoops(opMin),
            [OpcodesBCHCHIPs.OP_MAX]: conditionallyEvaluateChipLoops(opMax),
            [OpcodesBCHCHIPs.OP_WITHIN]: conditionallyEvaluateChipLoops(opWithin),
            [OpcodesBCHCHIPs.OP_RIPEMD160]: conditionallyEvaluateChipLoops(opRipemd160({ ripemd160: ripemd160$1 })),
            [OpcodesBCHCHIPs.OP_SHA1]: conditionallyEvaluateChipLoops(opSha1({ sha1: sha1$1 })),
            [OpcodesBCHCHIPs.OP_SHA256]: conditionallyEvaluateChipLoops(opSha256({ sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_HASH160]: conditionallyEvaluateChipLoops(opHash160({ ripemd160: ripemd160$1, sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_HASH256]: conditionallyEvaluateChipLoops(opHash256({ sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_CODESEPARATOR]: conditionallyEvaluateChipLoops(opCodeSeparator),
            [OpcodesBCHCHIPs.OP_CHECKSIG]: conditionallyEvaluateChipLoops(opCheckSigChipLimits({ secp256k1: secp256k1$1, sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_CHECKSIGVERIFY]: conditionallyEvaluateChipLoops(opCheckSigVerifyChipLimits({ secp256k1: secp256k1$1, sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_CHECKMULTISIG]: conditionallyEvaluateChipLoops(opCheckMultiSigChipLimits({ secp256k1: secp256k1$1, sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_CHECKMULTISIGVERIFY]: conditionallyEvaluateChipLoops(opCheckMultiSigVerifyChipLimits({ secp256k1: secp256k1$1, sha256: sha256$1 })),
            ...(standard
                ? {
                    [OpcodesBCHCHIPs.OP_NOP1]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluateChipLoops(opCheckLockTimeVerify),
                    [OpcodesBCHCHIPs.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluateChipLoops(opCheckSequenceVerify),
                    [OpcodesBCHCHIPs.OP_NOP4]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_NOP5]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_NOP6]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_NOP7]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_NOP8]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_NOP9]: conditionallyEvaluateChipLoops(opNopDisallowed),
                    [OpcodesBCHCHIPs.OP_NOP10]: conditionallyEvaluateChipLoops(opNopDisallowed),
                }
                : {
                    [OpcodesBCHCHIPs.OP_NOP1]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_CHECKLOCKTIMEVERIFY]: conditionallyEvaluateChipLoops(opCheckLockTimeVerify),
                    [OpcodesBCHCHIPs.OP_CHECKSEQUENCEVERIFY]: conditionallyEvaluateChipLoops(opCheckSequenceVerify),
                    [OpcodesBCHCHIPs.OP_NOP4]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_NOP5]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_NOP6]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_NOP7]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_NOP8]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_NOP9]: conditionallyEvaluateChipLoops(opNop),
                    [OpcodesBCHCHIPs.OP_NOP10]: conditionallyEvaluateChipLoops(opNop),
                }),
            [OpcodesBCHCHIPs.OP_CHECKDATASIG]: conditionallyEvaluateChipLoops(opCheckDataSig({ secp256k1: secp256k1$1, sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_CHECKDATASIGVERIFY]: conditionallyEvaluateChipLoops(opCheckDataSigVerify({ secp256k1: secp256k1$1, sha256: sha256$1 })),
            [OpcodesBCHCHIPs.OP_REVERSEBYTES]: conditionallyEvaluateChipLoops(opReverseBytes),
            [OpcodesBCHCHIPs.OP_INPUTINDEX]: conditionallyEvaluateChipLoops(opInputIndex),
            [OpcodesBCHCHIPs.OP_ACTIVEBYTECODE]: conditionallyEvaluateChipLoops(opActiveBytecode),
            [OpcodesBCHCHIPs.OP_TXVERSION]: conditionallyEvaluateChipLoops(opTxVersion),
            [OpcodesBCHCHIPs.OP_TXINPUTCOUNT]: conditionallyEvaluateChipLoops(opTxInputCount),
            [OpcodesBCHCHIPs.OP_TXOUTPUTCOUNT]: conditionallyEvaluateChipLoops(opTxOutputCount),
            [OpcodesBCHCHIPs.OP_TXLOCKTIME]: conditionallyEvaluateChipLoops(opTxLocktime),
            [OpcodesBCHCHIPs.OP_UTXOVALUE]: conditionallyEvaluateChipLoops(opUtxoValue),
            [OpcodesBCHCHIPs.OP_UTXOBYTECODE]: conditionallyEvaluateChipLoops(opUtxoBytecode),
            [OpcodesBCHCHIPs.OP_OUTPOINTTXHASH]: conditionallyEvaluateChipLoops(opOutpointTxHash),
            [OpcodesBCHCHIPs.OP_OUTPOINTINDEX]: conditionallyEvaluateChipLoops(opOutpointIndex),
            [OpcodesBCHCHIPs.OP_INPUTBYTECODE]: conditionallyEvaluateChipLoops(opInputBytecode),
            [OpcodesBCHCHIPs.OP_INPUTSEQUENCENUMBER]: conditionallyEvaluateChipLoops(opInputSequenceNumber),
            [OpcodesBCHCHIPs.OP_OUTPUTVALUE]: conditionallyEvaluateChipLoops(opOutputValue),
            [OpcodesBCHCHIPs.OP_OUTPUTBYTECODE]: conditionallyEvaluateChipLoops(opOutputBytecode),
            [OpcodesBCHCHIPs.OP_UTXOTOKENCATEGORY]: conditionallyEvaluateChipLoops(opUtxoTokenCategory),
            [OpcodesBCHCHIPs.OP_UTXOTOKENCOMMITMENT]: conditionallyEvaluateChipLoops(opUtxoTokenCommitment),
            [OpcodesBCHCHIPs.OP_UTXOTOKENAMOUNT]: conditionallyEvaluateChipLoops(opUtxoTokenAmount),
            [OpcodesBCHCHIPs.OP_OUTPUTTOKENCATEGORY]: conditionallyEvaluateChipLoops(opOutputTokenCategory),
            [OpcodesBCHCHIPs.OP_OUTPUTTOKENCOMMITMENT]: conditionallyEvaluateChipLoops(opOutputTokenCommitment),
            [OpcodesBCHCHIPs.OP_OUTPUTTOKENAMOUNT]: conditionallyEvaluateChipLoops(opOutputTokenAmount),
        },
        success: (state) => {
            if (state.error !== undefined) {
                return state.error;
            }
            if (state.controlStack.length !== 0) {
                return AuthenticationErrorCommon.nonEmptyControlStack;
            }
            if (state.stack.length !== 1) {
                return AuthenticationErrorCommon.requiresCleanStack;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (!stackItemIsTruthy(state.stack[0])) {
                return AuthenticationErrorCommon.unsuccessfulEvaluation;
            }
            return true;
        },
        undefined: undefinedOperationChipLoops,
        // eslint-disable-next-line complexity
        verify: ({ sourceOutputs, transaction }, evaluate, stateSuccess) => {
            if (transaction.inputs.length === 0) {
                return 'Transactions must have at least one input.';
            }
            if (transaction.outputs.length === 0) {
                return 'Transactions must have at least one output.';
            }
            if (transaction.inputs.length !== sourceOutputs.length) {
                return 'Unable to verify transaction: a single spent output must be provided for each transaction input.';
            }
            const transactionSize = encodeTransactionBCH(transaction).length;
            if (transactionSize < ConsensusBCH.minimumTransactionSize) {
                return `Transaction does not meet minimum size: the transaction is ${transactionSize} bytes, but the minimum transaction size is ${ConsensusBCH.minimumTransactionSize} bytes.`;
            }
            if (transactionSize > ConsensusBCH.maximumTransactionSize) {
                return `Transaction exceeds maximum size: the transaction is ${transactionSize} bytes, but the maximum transaction size is ${ConsensusBCH.maximumTransactionSize} bytes.`;
            }
            if (standard) {
                if (transaction.version < 1 ||
                    transaction.version > ConsensusBCH.maximumStandardVersion) {
                    return `Standard transactions must have a version no less than 1 and no greater than ${ConsensusBCH.maximumStandardVersion}.`;
                }
                if (transactionSize > ConsensusBCH.maximumStandardTransactionSize) {
                    return `Transaction exceeds maximum standard size: this transaction is ${transactionSize} bytes, but the maximum standard transaction size is ${ConsensusBCH.maximumStandardTransactionSize} bytes.`;
                }
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, output] of sourceOutputs.entries()) {
                    if (!isStandardOutputBytecode(output.lockingBytecode)) {
                        return `Standard transactions may only spend standard output types, but source output ${index} is non-standard.`;
                    }
                }
                // eslint-disable-next-line functional/no-let
                let totalArbitraryDataBytes = 0;
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, output] of transaction.outputs.entries()) {
                    if (!isStandardOutputBytecode(output.lockingBytecode)) {
                        return `Standard transactions may only create standard output types, but transaction output ${index} is non-standard.`;
                    }
                    // eslint-disable-next-line functional/no-conditional-statements
                    if (isArbitraryDataOutput(output.lockingBytecode)) {
                        // eslint-disable-next-line functional/no-expression-statements
                        totalArbitraryDataBytes += output.lockingBytecode.length + 1;
                    }
                    /*
                     * TODO: disallow dust outputs
                     * if(IsDustOutput(output)) {
                     *   return ``;
                     * }
                     */
                }
                if (totalArbitraryDataBytes > ConsensusBCH.maximumDataCarrierBytes) {
                    return `Standard transactions may carry no more than ${ConsensusBCH.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${totalArbitraryDataBytes} bytes of arbitrary data.`;
                }
                // eslint-disable-next-line functional/no-loop-statements
                for (const [index, input] of transaction.inputs.entries()) {
                    if (input.unlockingBytecode.length >
                        ConsensusBCH.maximumStandardUnlockingBytecodeLength) {
                        return `Input index ${index} is non-standard: the unlocking bytecode (${input.unlockingBytecode.length} bytes) exceeds the maximum standard unlocking bytecode length (${ConsensusBCH.maximumStandardUnlockingBytecodeLength} bytes).`;
                    }
                    if (!isPushOnly(input.unlockingBytecode)) {
                        return `Input index ${index} is non-standard: unlocking bytecode may contain only push operations.`;
                    }
                }
            }
            // eslint-disable-next-line functional/no-loop-statements
            for (const index of transaction.inputs.keys()) {
                const state = evaluate({
                    inputIndex: index,
                    sourceOutputs,
                    transaction,
                });
                const result = stateSuccess(state);
                if (typeof result === 'string') {
                    return `Error in evaluating input index ${index}: ${result}`;
                }
            }
            return true;
        },
    };
};

/**
 * Initialize a virtual machine using the BCH CHIPs instruction set, an
 * informal, speculative instruction set that implements a variety of future
 * Bitcoin Cash Improvement Proposals (CHIPs).
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
const createVirtualMachineBCHCHIPs = (standard = true) => createVirtualMachine(createInstructionSetBCHCHIPs(standard));

var OpcodeDescriptionsBTC;
(function (OpcodeDescriptionsBTC) {
    OpcodeDescriptionsBTC["OP_0"] = "Push the VM Number 0 onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
    OpcodeDescriptionsBTC["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
    OpcodeDescriptionsBTC["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_1"] = "Push a 1 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_2"] = "Push a 2 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_3"] = "Push a 3 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_4"] = "Push a 4 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_5"] = "Push a 5 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_6"] = "Push a 6 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_7"] = "Push a 7 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_8"] = "Push a 8 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_9"] = "Push a 9 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_10"] = "Push a 10 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_11"] = "Push a 11 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_12"] = "Push a 12 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_13"] = "Push a 13 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_14"] = "Push a 14 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_15"] = "Push a 15 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_16"] = "Push a 16 (VM Number) onto the stack.";
    OpcodeDescriptionsBTC["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
    OpcodeDescriptionsBTC["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBTC["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
    OpcodeDescriptionsBTC["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
    OpcodeDescriptionsBTC["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
    OpcodeDescriptionsBTC["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
    OpcodeDescriptionsBTC["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
    OpcodeDescriptionsBTC["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
    OpcodeDescriptionsBTC["OP_RETURN"] = "Error when executed.";
    OpcodeDescriptionsBTC["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
    OpcodeDescriptionsBTC["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
    OpcodeDescriptionsBTC["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
    OpcodeDescriptionsBTC["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
    OpcodeDescriptionsBTC["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
    OpcodeDescriptionsBTC["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
    OpcodeDescriptionsBTC["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
    OpcodeDescriptionsBTC["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
    OpcodeDescriptionsBTC["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
    OpcodeDescriptionsBTC["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
    OpcodeDescriptionsBTC["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
    OpcodeDescriptionsBTC["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
    OpcodeDescriptionsBTC["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
    OpcodeDescriptionsBTC["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
    OpcodeDescriptionsBTC["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
    OpcodeDescriptionsBTC["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
    OpcodeDescriptionsBTC["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
    OpcodeDescriptionsBTC["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
    OpcodeDescriptionsBTC["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
    OpcodeDescriptionsBTC["OP_CAT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this concatenated two stack items.)";
    OpcodeDescriptionsBTC["OP_SUBSTR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section of a stack item.)";
    OpcodeDescriptionsBTC["OP_LEFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the left of a point in a stack item.)";
    OpcodeDescriptionsBTC["OP_RIGHT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the right of a point in a stack item.)";
    OpcodeDescriptionsBTC["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
    OpcodeDescriptionsBTC["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
    OpcodeDescriptionsBTC["OP_AND"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean AND on each bit in two stack items.)";
    OpcodeDescriptionsBTC["OP_OR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean OR on each bit in two stack items.)";
    OpcodeDescriptionsBTC["OP_XOR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean XOR on each bit in two stack items.)";
    OpcodeDescriptionsBTC["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBTC["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied two VM Numbers.)";
    OpcodeDescriptionsBTC["OP_DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by another.)";
    OpcodeDescriptionsBTC["OP_MOD"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned the remainder after dividing one VM Number by another.)";
    OpcodeDescriptionsBTC["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
    OpcodeDescriptionsBTC["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
    OpcodeDescriptionsBTC["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
    OpcodeDescriptionsBTC["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
    OpcodeDescriptionsBTC["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
    OpcodeDescriptionsBTC["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
    OpcodeDescriptionsBTC["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
    OpcodeDescriptionsBTC["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
    OpcodeDescriptionsBTC["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
    OpcodeDescriptionsBTC["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
    OpcodeDescriptionsBTC["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
    OpcodeDescriptionsBTC["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
    OpcodeDescriptionsBTC["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
    OpcodeDescriptionsBTC["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
    OpcodeDescriptionsBTC["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBTC["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
    OpcodeDescriptionsBTC["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
    OpcodeDescriptionsBTC["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
    OpcodeDescriptionsBTC["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
    OpcodeDescriptionsBTC["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
    OpcodeDescriptionsBTC["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBTC["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
    OpcodeDescriptionsBTC["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
    OpcodeDescriptionsBTC["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
    OpcodeDescriptionsBTC["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
    OpcodeDescriptionsBTC["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
    OpcodeDescriptionsBTC["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
})(OpcodeDescriptionsBTC || (OpcodeDescriptionsBTC = {}));

/* eslint-disable max-lines */
/**
 * Verify that a private key is valid for the Secp256k1 curve. Returns `true`
 * for success, or `false` on failure.
 *
 * Private keys are 256-bit numbers encoded as a 32-byte, big-endian Uint8Array.
 * Nearly every 256-bit number is a valid secp256k1 private key. Specifically,
 * any 256-bit number greater than `0x01` and less than
 * `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141`
 * is a valid private key. This range is part of the definition of the
 * secp256k1 elliptic curve parameters.
 *
 * This method does not require a `Secp256k1` implementation.
 *
 * @param privateKey - The private key to validate.
 */
const validateSecp256k1PrivateKey = (privateKey) => {
    if (privateKey.length !== 32 /* Secp256k1Constants.privateKeyLength */ ||
        privateKey.every((value) => value === 0)) {
        return false;
    }
    /**
     * The largest possible Secp256k1 private key – equal to the order of the
     * Secp256k1 curve minus one.
     */
    // prettier-ignore
    const maximumSecp256k1PrivateKey = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 64]; // eslint-disable-line @typescript-eslint/no-magic-numbers
    const firstDifference = privateKey.findIndex((value, i) => value !== maximumSecp256k1PrivateKey[i]);
    if (firstDifference === -1 ||
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        privateKey[firstDifference] < maximumSecp256k1PrivateKey[firstDifference]) {
        return true;
    }
    return false;
};
/**
 * An error in the derivation of child HD public or private nodes.
 */
var HdNodeDerivationError;
(function (HdNodeDerivationError) {
    HdNodeDerivationError["childIndexExceedsMaximum"] = "HD node derivation error: child index exceeds maximum (4294967295).";
    HdNodeDerivationError["requiresZeroDepthNode"] = "HD node derivation error: absolute derivation requires an HD node with a depth of 0.";
    HdNodeDerivationError["hardenedDerivationRequiresPrivateNode"] = "HD node derivation error: derivation for hardened child indexes (indexes greater than or equal to 2147483648) requires an HD private node.";
    HdNodeDerivationError["invalidAbsoluteDerivationPath"] = "HD node derivation error: invalid absolute derivation path; path must begin with \"m\" or \"M\" and contain only positive child index numbers, separated by forward slashes (\"/\"), with zero or one apostrophe (\"'\") after each child index number.";
    HdNodeDerivationError["invalidRelativeDerivationPath"] = "HD node derivation error: invalid relative derivation path; path must contain only positive child index numbers, separated by forward slashes (\"/\"), with zero or one apostrophe (\"'\") after each child index number.";
    HdNodeDerivationError["invalidDerivedKey"] = "HD node derivation error: an astronomically rare HMAC-SHA512 result produced an invalid Secp256k1 key.";
    HdNodeDerivationError["invalidPrivateDerivationPrefix"] = "HD node derivation error: private derivation paths must begin with \"m\".";
    HdNodeDerivationError["invalidPublicDerivationPrefix"] = "HD node derivation error: public derivation paths must begin with \"M\".";
})(HdNodeDerivationError || (HdNodeDerivationError = {}));
/**
 * An error in the decoding of an HD public or private key.
 */
var HdKeyDecodingError;
(function (HdKeyDecodingError) {
    HdKeyDecodingError["incorrectLength"] = "HD key decoding error: length is incorrect (must encode 82 bytes).";
    HdKeyDecodingError["invalidChecksum"] = "HD key decoding error: checksum is invalid.";
    HdKeyDecodingError["invalidPublicKey"] = "HD key decoding error: the public key for this HD public node is not a valid Secp256k1 public key.";
    HdKeyDecodingError["invalidPrivateKey"] = "HD key decoding error: the key for this HD private node is not a valid Secp256k1 private key.";
    HdKeyDecodingError["missingPrivateKeyPaddingByte"] = "HD key decoding error: version indicates a private key, but the key data is missing a padding byte.";
    HdKeyDecodingError["privateKeyExpected"] = "HD key decoding error: expected an HD private key, but encountered an HD public key.";
    HdKeyDecodingError["publicKeyExpected"] = "HD key decoding error: expected an HD public key, but encountered an HD private key.";
    HdKeyDecodingError["unknownCharacter"] = "HD key decoding error: key includes a non-base58 character.";
    HdKeyDecodingError["unknownVersion"] = "HD key decoding error: key uses an unknown version.";
    HdKeyDecodingError["zeroDepthWithNonZeroChildIndex"] = "HD key decoding error: key encodes a depth of zero with a non-zero child index.";
    HdKeyDecodingError["zeroDepthWithNonZeroParentFingerprint"] = "HD key decoding error: key encodes a depth of zero with a non-zero parent fingerprint.";
})(HdKeyDecodingError || (HdKeyDecodingError = {}));
/**
 * An error in the encoding of an HD public or private key.
 */
var HdKeyEncodingError;
(function (HdKeyEncodingError) {
    HdKeyEncodingError["invalidChainCodeLength"] = "HD key encoding error: invalid chain code length. Chain code must be 32 bytes.";
    HdKeyEncodingError["invalidChildDepth"] = "HD key encoding error: invalid child depth. Child depth must be between 0 and 255 (inclusive).";
    HdKeyEncodingError["invalidChildIndex"] = "HD key encoding error: invalid child index. Child index must be between 0 and 4294967295 (inclusive).";
    HdKeyEncodingError["invalidParentFingerprintLength"] = "HD key encoding error: invalid parent fingerprint length. Parent fingerprint must be 4 bytes.";
    HdKeyEncodingError["invalidPrivateKeyLength"] = "HD key encoding error: invalid private key length. Secp256k1 private keys must be 32 bytes.";
    HdKeyEncodingError["invalidPublicKeyLength"] = "HD key encoding error: invalid public key length. Public key must be 33 bytes (compressed).";
    HdKeyEncodingError["invalidPublicKey"] = "HD key encoding error: the public key for this HD public node is not a valid Secp256k1 public key.";
    HdKeyEncodingError["zeroDepthWithNonZeroChildIndex"] = "HD key encoding error: attempted to encode a zero depth key with a non-zero child index.";
    HdKeyEncodingError["zeroDepthWithNonZeroParentFingerprint"] = "HD key encoding error: attempted to encode a zero depth key with a non-zero parent fingerprint.";
})(HdKeyEncodingError || (HdKeyEncodingError = {}));
const emptyParentFingerprint = Uint8Array.from([0, 0, 0, 0]);
/**
 * The HMAC SHA-512 key used by BIP32, "Bitcoin seed"
 * (`utf8ToBin('Bitcoin seed')`)
 */
const bip32HmacSha512Key = utf8ToBin('Bitcoin seed');
/**
 * Derive an {@link HdPrivateNode} from the provided seed following the BIP32
 * specification. A seed should include between 16 bytes and 64 bytes of
 * entropy (recommended: 32 bytes).
 *
 * @param seed - the entropy from which to derive the {@link HdPrivateNode}
 */
const deriveHdPrivateNodeFromSeed = (seed, { assumeValidity, crypto = { sha512: sha512 }, hmacSha512Key = bip32HmacSha512Key, throwErrors = true, } = {}) => {
    const mac = hmacSha512(hmacSha512Key, seed, crypto.sha512);
    const privateKey = mac.slice(0, 32 /* Bip32Constants.halfHmacSha512Length */);
    const chainCode = mac.slice(32 /* Bip32Constants.halfHmacSha512Length */);
    const depth = 0;
    const childIndex = 0;
    const parentFingerprint = emptyParentFingerprint.slice();
    const valid = assumeValidity ?? validateSecp256k1PrivateKey(privateKey);
    if (throwErrors && !valid)
        // eslint-disable-next-line functional/no-throw-statements
        throw new Error(HdNodeDerivationError.invalidDerivedKey);
    return (valid
        ? { chainCode, childIndex, depth, parentFingerprint, privateKey }
        : {
            chainCode,
            childIndex,
            depth,
            invalidMaterial: privateKey,
            parentFingerprint,
        });
};
/**
 * Derive the public identifier for a given {@link HdPrivateNode}. This is used
 * to uniquely identify HD nodes in software. The first 4 bytes of this
 * identifier are considered its "fingerprint".
 *
 * @param hdPrivateNode - The {@link HdPrivateNode} from which to derive the
 * public identifier.
 */
const deriveHdPrivateNodeIdentifier = (hdPrivateNode, { crypto = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha256: sha256,
}, } = {}) => {
    const publicKey = crypto.secp256k1.derivePublicKeyCompressed(hdPrivateNode.privateKey);
    if (typeof publicKey === 'string')
        return publicKey;
    return crypto.ripemd160.hash(crypto.sha256.hash(publicKey));
};
/**
 * Derive the public identifier for a given {@link HdPublicNodeValid}. This is
 * used to uniquely identify HD nodes in software. The first 4 bytes of this
 * identifier are considered its fingerprint.
 *
 * @param node - The {@link HdPublicNodeValid} from which to derive the
 * public identifier.
 */
const deriveHdPublicNodeIdentifier = (node, { crypto = { ripemd160: ripemd160, sha256: sha256 }, } = {}) => crypto.ripemd160.hash(crypto.sha256.hash(node.publicKey));
/**
 * The 4-byte version indicating the network and type of an {@link HdPrivateKey}
 * or {@link HdPublicKey}.
 */
var HdKeyVersion;
(function (HdKeyVersion) {
    /**
     * Version indicating the HD key is an {@link HdPrivateKey} intended for use
     * on the main network. Base58 encoding at the expected length of an HD key
     * results in a prefix of `xprv`.
     *
     * Hex: `0x0488ade4`
     */
    HdKeyVersion[HdKeyVersion["mainnetPrivateKey"] = 76066276] = "mainnetPrivateKey";
    /**
     * Version indicating the HD key is an {@link HdPrivateKey} intended for use
     * on the main network. Base58 encoding at the expected length of an HD key
     * results in a prefix of `xpub`.
     *
     * Hex: `0x0488b21e`
     */
    HdKeyVersion[HdKeyVersion["mainnetPublicKey"] = 76067358] = "mainnetPublicKey";
    /**
     * Version indicating the HD key is an {@link HdPrivateKey} intended for use
     * on the test network. Base58 encoding at the expected length of an HD key
     * results in a prefix of `tprv`.
     *
     * Hex: `0x04358394`
     */
    HdKeyVersion[HdKeyVersion["testnetPrivateKey"] = 70615956] = "testnetPrivateKey";
    /**
     * Version indicating the HD key is an {@link HdPrivateKey} intended for use
     * on the test network. Base58 encoding at the expected length of an HD key
     * results in a prefix of `tpub`.
     *
     * Hex: `0x043587cf`
     */
    HdKeyVersion[HdKeyVersion["testnetPublicKey"] = 70617039] = "testnetPublicKey";
})(HdKeyVersion || (HdKeyVersion = {}));
const hdKeyVersionIsPublicKey = (version) => version === HdKeyVersion.mainnetPublicKey ||
    version === HdKeyVersion.testnetPublicKey;
const hdKeyVersionIsPrivateKey = (version) => version === HdKeyVersion.mainnetPrivateKey ||
    version === HdKeyVersion.testnetPrivateKey;
/**
 * Decode a string following the HD key format as defined by BIP32, returning a
 * `node` and a `version`. Decoding errors are returned as strings.
 *
 * This is a less strict variant of {@link decodeHdKey}; most applications
 * should instead use {@link decodeHdKey}, or if the type of the key is known,
 * either {@link decodeHdPrivateKey} or {@link decodeHdPublicKey}.
 *
 * @param hdKey - A BIP32 HD private key or HD public key.
 */
// eslint-disable-next-line complexity
const decodeHdKeyUnchecked = (hdKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, } = {}) => {
    const decoded = base58ToBin(hdKey);
    if (typeof decoded === 'string')
        return formatError(HdKeyDecodingError.unknownCharacter, decoded);
    if (decoded.length !== 82 /* Bip32Constants.hdKeyLength */)
        return formatError(HdKeyDecodingError.incorrectLength, `Length: ${decoded.length}.`);
    const payload = decoded.slice(0, 78 /* Bip32Constants.hdKeyChecksumIndex */);
    const checksumBits = decoded.slice(78 /* Bip32Constants.hdKeyChecksumIndex */);
    const checksum = crypto.sha256.hash(crypto.sha256.hash(payload));
    if (!checksumBits.every((value, i) => value === checksum[i])) {
        return formatError(HdKeyDecodingError.invalidChecksum, `Encoded: ${binToHex(checksumBits)}; computed: ${binToHex(checksum.slice(0, 4 /* Bip32Constants.hdKeyChecksumLength */))}.`);
    }
    const depthIndex = 4;
    const fingerprintIndex = 5;
    const childIndexIndex = 9;
    const chainCodeIndex = 13;
    const keyDataIndex = 45;
    const version = new DataView(decoded.buffer, decoded.byteOffset, depthIndex).getUint32(0);
    const depth = decoded[depthIndex];
    const parentFingerprint = decoded.slice(fingerprintIndex, childIndexIndex);
    const childIndex = new DataView(decoded.buffer, decoded.byteOffset + childIndexIndex, decoded.byteOffset + chainCodeIndex).getUint32(0);
    const chainCode = decoded.slice(chainCodeIndex, keyDataIndex);
    const keyData = decoded.slice(keyDataIndex, 78 /* Bip32Constants.hdKeyChecksumIndex */);
    const isPrivateKey = hdKeyVersionIsPrivateKey(version);
    if (isPrivateKey && keyData[0] !== 0x00) {
        return HdKeyDecodingError.missingPrivateKeyPaddingByte;
    }
    if (isPrivateKey) {
        const privateKey = keyData.slice(1);
        const valid = validateSecp256k1PrivateKey(privateKey);
        return {
            node: valid
                ? {
                    chainCode,
                    childIndex,
                    depth,
                    parentFingerprint,
                    privateKey,
                }
                : {
                    chainCode,
                    childIndex,
                    depth,
                    invalidMaterial: privateKey,
                    parentFingerprint,
                },
            version,
        };
    }
    const isPublicKey = hdKeyVersionIsPublicKey(version);
    if (!isPublicKey) {
        return formatError(HdKeyDecodingError.unknownVersion, `Version: ${version}`);
    }
    const publicKey = keyData;
    const valid = crypto.secp256k1.validatePublicKey(publicKey);
    return {
        node: valid
            ? {
                chainCode,
                childIndex,
                depth,
                parentFingerprint,
                publicKey,
            }
            : {
                chainCode,
                childIndex,
                depth,
                invalidMaterial: publicKey,
                parentFingerprint,
            },
        version,
    };
};
/**
 * Decode an HD key as defined by BIP32, returning a `node` and a `network`.
 * Decoding errors are returned as strings.
 *
 * If the type of the key is known, use {@link decodeHdPrivateKey} or
 * {@link decodeHdPublicKey}. For a variant with less strict validation,
 * use {@link decodeHdKeyUnchecked}.
 *
 * @param hdKey - A BIP32 HD private key or HD public key.
 */
// eslint-disable-next-line complexity
const decodeHdKey = (hdKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, } = {}) => {
    const decoded = decodeHdKeyUnchecked(hdKey, { crypto });
    if (typeof decoded === 'string')
        return decoded;
    const { node, version } = decoded;
    if (node.depth === 0) {
        if (node.childIndex !== 0) {
            return formatError(HdKeyDecodingError.zeroDepthWithNonZeroChildIndex, `Child index: ${node.childIndex}.`);
        }
        if (!binsAreEqual(node.parentFingerprint, emptyParentFingerprint)) {
            return formatError(HdKeyDecodingError.zeroDepthWithNonZeroParentFingerprint, `Parent fingerprint: ${node.parentFingerprint.join(',')}.`);
        }
    }
    const isPublicKey = hdKeyVersionIsPublicKey(version);
    if ('invalidMaterial' in node) {
        return isPublicKey
            ? formatError(HdKeyDecodingError.invalidPublicKey, `Invalid public key: ${binToHex(node.invalidMaterial)}.`)
            : formatError(HdKeyDecodingError.invalidPrivateKey);
    }
    const network = version === HdKeyVersion.mainnetPrivateKey ||
        version === HdKeyVersion.mainnetPublicKey
        ? 'mainnet'
        : 'testnet';
    return { network, node };
};
/**
 * Decode an HD private key as defined by BIP32.
 *
 * This method is similar to {@link decodeHdKey} but ensures that the result is
 * a valid HD private node. Decoding error messages are returned as strings.
 *
 * @param hdPrivateKey - A BIP32 HD private key.
 */
const decodeHdPrivateKey = (hdPrivateKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, } = {}) => {
    const decoded = decodeHdKey(hdPrivateKey, { crypto });
    if (typeof decoded === 'string')
        return decoded;
    const { network, node } = decoded;
    if ('publicKey' in node) {
        return HdKeyDecodingError.privateKeyExpected;
    }
    return { network, node };
};
/**
 * Decode an HD public key as defined by BIP32.
 *
 * This method is similar to {@link decodeHdKey} but ensures that the result is
 * a valid HD public node. Decoding error messages are returned as strings.
 *
 * @param hdPublicKey - A BIP32 HD public key.
 */
const decodeHdPublicKey = (hdPublicKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, } = {}) => {
    const decoded = decodeHdKey(hdPublicKey, { crypto });
    if (typeof decoded === 'string')
        return decoded;
    const { network, node } = decoded;
    if ('privateKey' in node) {
        return HdKeyDecodingError.publicKeyExpected;
    }
    return { network, node };
};
/**
 * Decode the provided HD private key and compute its identifier. Error messages
 * are returned as a string.
 */
const hdPrivateKeyToIdentifier = (hdPrivateKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, } = {}) => {
    const privateKeyParams = decodeHdPrivateKey(hdPrivateKey, { crypto });
    if (typeof privateKeyParams === 'string') {
        return privateKeyParams;
    }
    return deriveHdPrivateNodeIdentifier(privateKeyParams.node);
};
/**
 * Decode the provided HD public key and compute its identifier. Error messages
 * are returned as a string.
 */
const hdPublicKeyToIdentifier = (hdPublicKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, } = {}) => {
    const publicKeyParams = decodeHdPublicKey(hdPublicKey, { crypto });
    if (typeof publicKeyParams === 'string') {
        return publicKeyParams;
    }
    return deriveHdPublicNodeIdentifier(publicKeyParams.node);
};
/**
 * Encode the metadata portion of an HD key payload.
 */
// eslint-disable-next-line complexity
const encodeHdKeyPayloadMetadata = ({ version, keyParameters, throwErrors = true, }) => {
    if (keyParameters.node.depth === 0) {
        if (keyParameters.node.childIndex !== 0) {
            return formatError(HdKeyEncodingError.zeroDepthWithNonZeroChildIndex, `Child index: ${keyParameters.node.childIndex}.`, throwErrors);
        }
        if (!binsAreEqual(keyParameters.node.parentFingerprint, emptyParentFingerprint)) {
            return formatError(HdKeyEncodingError.zeroDepthWithNonZeroParentFingerprint, `Parent fingerprint: ${keyParameters.node.parentFingerprint.join(',')}.`, throwErrors);
        }
    }
    if (keyParameters.node.chainCode.length !== 32 /* Bip32Constants.halfHmacSha512Length */) {
        return formatError(HdKeyEncodingError.invalidChainCodeLength, `Chain code length: ${keyParameters.node.chainCode.length}.`, throwErrors);
    }
    if (keyParameters.node.parentFingerprint.length !==
        4 /* Bip32Constants.parentFingerprintLength */) {
        return formatError(HdKeyEncodingError.invalidParentFingerprintLength, `Parent fingerprint length: ${keyParameters.node.parentFingerprint.length}.`, throwErrors);
    }
    if (keyParameters.node.depth < 0 ||
        keyParameters.node.depth > 255 /* Bip32Constants.maximumEncodingDepth */) {
        return formatError(HdKeyEncodingError.invalidChildDepth, `Depth: ${keyParameters.node.depth}.`, throwErrors);
    }
    const depth = Uint8Array.of(keyParameters.node.depth);
    if (keyParameters.node.childIndex < 0 ||
        keyParameters.node.childIndex > 4294967295 /* Bip32Constants.maximumChildIndex */) {
        return formatError(HdKeyEncodingError.invalidChildIndex, `Child index: ${keyParameters.node.childIndex}.`, throwErrors);
    }
    const childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
    const payload = flattenBinArray([
        version,
        depth,
        keyParameters.node.parentFingerprint,
        childIndex,
        keyParameters.node.chainCode,
    ]);
    return payload;
};
/**
 * Encode an HD private key (as defined by BIP32) payload (without the checksum)
 * given a valid {@link HdPrivateNode} and network.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * @param keyParameters - A valid HD private node and the network for which to
 * encode the key.
 */
const encodeHdPrivateKeyPayload = (keyParameters, { throwErrors = true, } = {}) => {
    const version = numberToBinUint32BE(keyParameters.network === 'mainnet'
        ? HdKeyVersion.mainnetPrivateKey
        : HdKeyVersion.testnetPrivateKey);
    if (keyParameters.node.privateKey.length !== 32 /* Bip32Constants.halfHmacSha512Length */) {
        return formatError(HdKeyEncodingError.invalidPrivateKeyLength, `Private key length: ${keyParameters.node.privateKey.length}.`, throwErrors);
    }
    const metadata = encodeHdKeyPayloadMetadata({
        keyParameters,
        throwErrors,
        version,
    });
    if (typeof metadata === 'string') {
        return metadata;
    }
    const isPrivateKey = Uint8Array.of(0x00);
    const payload = flattenBinArray([
        metadata,
        isPrivateKey,
        keyParameters.node.privateKey,
    ]);
    return payload;
};
/**
 * Encode an HD public key (as defined by BIP32) payload (without the checksum)
 * given a valid {@link HdPublicNodeValid} and network.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * @param keyParameters - A valid HD public node and the network for which to
 * encode the key.
 */
const encodeHdPublicKeyPayload = (keyParameters, { throwErrors = true, } = {}) => {
    const version = numberToBinUint32BE(keyParameters.network === 'mainnet'
        ? HdKeyVersion.mainnetPublicKey
        : HdKeyVersion.testnetPublicKey);
    if (keyParameters.node.publicKey.length !== 33 /* Bip32Constants.publicKeyLength */) {
        return formatError(HdKeyEncodingError.invalidPublicKeyLength, `Public key length: ${keyParameters.node.publicKey.length}.`, throwErrors);
    }
    const metadata = encodeHdKeyPayloadMetadata({
        keyParameters,
        throwErrors,
        version,
    });
    if (typeof metadata === 'string') {
        return metadata;
    }
    const payload = flattenBinArray([metadata, keyParameters.node.publicKey]);
    return payload;
};
/**
 * Encode an HD public or private key (as defined by BIP32) payload with
 * a checksum.
 *
 * @param payload - the HD public or private key payload to encode
 */
const encodeHdKeyPayloadWithChecksum = (payload, { crypto = { sha256: sha256 }, } = {}) => {
    const checksumLength = 4;
    const checksum = crypto.sha256
        .hash(crypto.sha256.hash(payload))
        .slice(0, checksumLength);
    return binToBase58(flattenBinArray([payload, checksum]));
};
/**
 * Encode an HD private key (as defined by BIP32) given a valid
 * {@link HdPrivateNode} and network.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * @param keyParameters - A valid HD private node and the network for which to
 * encode the key.
 */
const encodeHdPrivateKey = (keyParameters, { crypto = { sha256: sha256 }, throwErrors = true, } = {}) => {
    const payload = encodeHdPrivateKeyPayload(keyParameters, { throwErrors });
    return typeof payload === 'string'
        ? payload
        : { hdPrivateKey: encodeHdKeyPayloadWithChecksum(payload, { crypto }) };
};
/**
 * Encode an HD public key (as defined by BIP32) given a valid
 * {@link HdPublicNodeValid} and network.
 *
 * Note that this function defaults to throwing encoding errors. To handle
 * errors in a type-safe way, set `throwErrors` to `false`.
 *
 * @param keyParameters - An HD public node and the network for which to encode
 * the key.
 */
const encodeHdPublicKey = (keyParameters, { crypto = { secp256k1: secp256k1, sha256: sha256 }, throwErrors = true, } = {}) => {
    if (!crypto.secp256k1.validatePublicKey(keyParameters.node.publicKey)) {
        return formatError(HdKeyEncodingError.invalidPublicKey, `Invalid public key: "${binToHex(keyParameters.node.publicKey)}".`, throwErrors);
    }
    const payload = encodeHdPublicKeyPayload(keyParameters, { throwErrors });
    return typeof payload === 'string'
        ? payload
        : { hdPublicKey: encodeHdKeyPayloadWithChecksum(payload, { crypto }) };
};
/**
 * Derive the HD public node of an HD private node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See {@link crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode} for
 * details.
 *
 * To derive an HD public key from an encoded HD private key,
 * use {@link deriveHdPublicKey}.
 *
 * @param node - A valid HD private node.
 */
const deriveHdPublicNode = (node, { crypto = { secp256k1: secp256k1 }, } = {}) => ({
    chainCode: node.chainCode,
    childIndex: node.childIndex,
    depth: node.depth,
    parentFingerprint: node.parentFingerprint,
    ...(node.parentIdentifier === undefined
        ? {}
        : { parentIdentifier: node.parentIdentifier }),
    publicKey: crypto.secp256k1.derivePublicKeyCompressed(node.privateKey),
});
/**
 * Derive the HD public key of an HD private key.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See {@link crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode} for
 * details.
 *
 * To derive the HD public node of an already-decoded HD private node,
 * use {@link deriveHdPublicNode}.
 *
 * Note that this function defaults to throwing errors. To handle errors in a
 * type-safe way, set `throwErrors` to `false`.
 *
 * @param hdPrivateKey - A BIP32 HD private key.
 */
const deriveHdPublicKey = (privateKey, { crypto = { secp256k1: secp256k1, sha256: sha256 }, throwErrors = true, } = {}) => {
    const decoded = decodeHdPrivateKey(privateKey, { crypto });
    if (typeof decoded === 'string') {
        return formatError(decoded, undefined, throwErrors);
    }
    const node = deriveHdPublicNode(decoded.node, { crypto });
    return encodeHdPublicKey({ network: decoded.network, node }, { crypto, throwErrors });
};
/**
 * Derive a child HD private node from an HD private node.
 *
 * To derive a child HD public node, use {@link deriveHdPublicNode} on the
 * result of this method. If the child uses a non-hardened index, it's also
 * possible to use {@link deriveHdPublicNodeChild}.
 *
 * Note that this function defaults to throwing errors. To handle errors in a
 * type-safe way, set `throwErrors` to `false`.
 *
 * This function has a less than 1 in 2^127 probability of producing
 * an invalid result (where the resulting private key is not a valid Secp256k1
 * private key, see {@link validateSecp256k1PrivateKey}). While this scenario is
 * unlikely to ever occur without a weakness in HMAC-SHA512, the
 * `returnInvalidNodes` parameter can be set to `true` to return the resulting
 * {@link HdPrivateNodeInvalid} rather than an error (defaults to `false`).
 *
 * @param node - The valid HD private node from which to derive the child node.
 * @param index - The index at which to derive the child node - indexes greater
 * than or equal to the hardened index offset (`0x80000000`/`2147483648`) are
 * derived using the "hardened" derivation algorithm.
 */
// eslint-disable-next-line complexity
const deriveHdPrivateNodeChild = (node, index, { crypto = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha256: sha256,
    sha512: sha512,
}, throwErrors = true, returnInvalidNodes = false, } = {}) => {
    const maximumIndex = 0xffffffff;
    if (index > maximumIndex) {
        return formatError(HdNodeDerivationError.childIndexExceedsMaximum, `Child index: ${index}.`, throwErrors);
    }
    const parentIdentifier = deriveHdPrivateNodeIdentifier(node, { crypto });
    const parentFingerprint = parentIdentifier.slice(0, 4 /* Bip32Constants.parentFingerprintLength */);
    const depth = node.depth + 1;
    const hardenedIndexOffset = 0x80000000;
    const useHardenedAlgorithm = index >= hardenedIndexOffset;
    const keyMaterial = useHardenedAlgorithm
        ? node.privateKey
        : crypto.secp256k1.derivePublicKeyCompressed(node.privateKey);
    const serialization = Uint8Array.from([
        ...(useHardenedAlgorithm ? [0x00] : []),
        ...keyMaterial,
        ...numberToBinUint32BE(index),
    ]);
    const derivation = hmacSha512(node.chainCode, serialization, crypto.sha512);
    const tweakValueLength = 32;
    const tweakValue = derivation.slice(0, tweakValueLength);
    const nextChainCode = derivation.slice(tweakValueLength);
    const nextPrivateKey = crypto.secp256k1.addTweakPrivateKey(node.privateKey, tweakValue);
    if (typeof nextPrivateKey === 'string') {
        const error = formatError(HdNodeDerivationError.invalidDerivedKey, `Invalid child index: ${index}.`, throwErrors);
        if (returnInvalidNodes) {
            return {
                chainCode: nextChainCode,
                childIndex: index,
                depth,
                invalidMaterial: tweakValue,
                parentFingerprint,
                parentIdentifier,
            };
        }
        return error;
    }
    return {
        chainCode: nextChainCode,
        childIndex: index,
        depth,
        parentFingerprint,
        parentIdentifier,
        privateKey: nextPrivateKey,
    };
};
/**
 * Derive a non-hardened, child HD public node from an HD public node.
 *
 * Because hardened derivation also requires knowledge of the parent private
 * node, it's not possible to use an HD public node to derive a hardened child
 * HD public node. (See {@link deriveHdPath} or {@link deriveHdPublicNode}.)
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See {@link crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode}
 * for details.
 *
 * This function has a less than 1 in 2^127 probability of producing
 * an invalid result (where the resulting public key is not a valid Secp256k1
 * public key). While this scenario is unlikely to ever occur without a weakness
 * in HMAC-SHA512, the `returnInvalidNodes` parameter can be set to `true` to
 * return the resulting {@link HdPrivateNodeInvalid} rather than an error
 * (defaults to `false`).
 *
 * @param node - The valid HD public node from which to derive the child
 * public node.
 * @param index - The index at which to derive the child node.
 */
const deriveHdPublicNodeChild = (node, index, { crypto = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha256: sha256,
    sha512: sha512,
}, returnInvalidNodes = false, throwErrors = true, } = {}) => {
    const hardenedIndexOffset = 0x80000000;
    if (index >= hardenedIndexOffset) {
        return formatError(HdNodeDerivationError.hardenedDerivationRequiresPrivateNode, `Requested index: ${index}.`, throwErrors);
    }
    const parentIdentifier = deriveHdPublicNodeIdentifier(node, { crypto });
    const parentFingerprint = parentIdentifier.slice(0, 4 /* Bip32Constants.parentFingerprintLength */);
    const depth = node.depth + 1;
    const serialization = Uint8Array.from([
        ...node.publicKey,
        ...numberToBinUint32BE(index),
    ]);
    const derivation = hmacSha512(node.chainCode, serialization, crypto.sha512);
    const tweakValueLength = 32;
    const tweakValue = derivation.slice(0, tweakValueLength);
    const nextChainCode = derivation.slice(tweakValueLength);
    const nextPublicKey = crypto.secp256k1.addTweakPublicKeyCompressed(node.publicKey, tweakValue);
    if (typeof nextPublicKey === 'string') {
        const error = formatError(HdNodeDerivationError.invalidDerivedKey, `Invalid child index: ${index}.`, throwErrors);
        if (returnInvalidNodes) {
            return {
                chainCode: nextChainCode,
                childIndex: index,
                depth,
                invalidMaterial: tweakValue,
                parentFingerprint,
                parentIdentifier,
            };
        }
        return error;
    }
    return {
        chainCode: nextChainCode,
        childIndex: index,
        depth,
        parentFingerprint,
        parentIdentifier,
        publicKey: nextPublicKey,
    };
};
/**
 * Derive a child HD node from a parent node given a relative derivation path.
 * The resulting node is the same type as the parent node – private nodes return
 * private nodes, public nodes return public nodes. (To prevent implementation
 * errors, this function will not internally derive a public node from any
 * private node; for public derivation, use {@link deriveHdPublicNode} at the
 * desired BIP32 account level and provide the HD public key to this function.)
 *
 * Where possible, consider instead using {@link deriveHdPath} to reduce the
 * likelihood of implementation errors.
 *
 * By default, this function throws an `Error` rather than returning the error
 * as string when the provided path is invalid or cannot be derived from the
 * provided HD node (e.g. the path requests an excessive child index, a hardened
 * path is requested from a public node, or an astronomically rare HMAC-SHA512
 * result produces and invalid node).
 *
 * While the throwing behavior is reasonable for the common case of deriving
 * known, fixed paths (e.g. the BCH account as standardized by SLIP44 at
 * `m/44'/145'/0'`), **it is recommended that `throwErrors` be set to `false`
 * for use cases where dynamic or user-specified paths might be derived**. In
 * these cases, deliberate error handling is recommended, e.g. saving any data
 * and safely shutting down, displaying troubleshooting information to the
 * user, etc.
 *
 * The derivation path uses the notation specified in BIP32; see
 * {@link deriveHdPath} for details.
 *
 * @param node - The HD node from which to begin the derivation – for private
 * derivation, an {@link HdPrivateNodeValid}; for public derivation,
 * an {@link HdPublicNodeValid}.
 * @param path - The relative BIP32 derivation path, e.g. `1'/2` or `3/4/5`.
 */
const deriveHdPathRelative = (node, path, { crypto = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha256: sha256,
    sha512: sha512,
}, throwErrors = true, } = {}) => {
    if (path === '') {
        return node;
    }
    const validRelativeDerivationPath = /^(?:[0-9]+'?)(?:\/[0-9]+'?)*$/u;
    if (!validRelativeDerivationPath.test(path)) {
        return formatError(HdNodeDerivationError.invalidRelativeDerivationPath, `Invalid path: "${path}".`, throwErrors);
    }
    const parsed = path.split('/');
    const isPrivateDerivation = 'privateKey' in node;
    const base = 10;
    const hardenedIndexOffset = 0x80000000;
    const indexes = parsed.map((index) => index.endsWith("'")
        ? parseInt(index.slice(0, -1), base) + hardenedIndexOffset
        : parseInt(index, base));
    return (isPrivateDerivation
        ? indexes.reduce((result, nextIndex) => typeof result === 'string'
            ? result
            : deriveHdPrivateNodeChild(result, nextIndex, {
                crypto,
                throwErrors,
            }), node)
        : indexes.reduce((result, nextIndex) => typeof result === 'string'
            ? result
            : deriveHdPublicNodeChild(result, nextIndex, {
                crypto,
                throwErrors,
            }), node));
};
/**
 * Derive a child HD node from a master node given an absolute derivation path.
 * The resulting node is the same type as the parent node – private nodes return
 * private nodes, public nodes return public nodes. (To prevent implementation
 * errors, this function will not internally derive a public node from any
 * private node; for public derivation, use {@link deriveHdPublicNode} at the
 * desired BIP32 account level and provide the HD public key to this function.)
 *
 * The derivation path uses the notation specified in BIP32: the first character
 * must be either `m` for private derivation or `M` for public derivation,
 * followed by sets of `/` and a number representing the child index used in the
 * derivation at that depth. Hardened derivation is represented by a trailing
 * `'`, and may only appear in private derivation paths (hardened derivation
 * requires knowledge of the private key). Hardened child indexes are
 * represented with the hardened index offset (`2147483648`) subtracted.
 *
 * For example, `m/0/1'/2` uses private derivation (`m`), with child indexes in
 * the following order:
 *
 * `derivePrivate(derivePrivate(derivePrivate(node, 0), 2147483648 + 1), 2)`
 *
 * Likewise, `M/3/4/5` uses public derivation (`M`), with child indexes in the
 * following order:
 *
 * `derivePublic(derivePublic(derivePublic(node, 3), 4), 5)`
 *
 * Because hardened derivation requires a private node, paths that specify
 * public derivation (`M`) using hardened derivation (`'`) will return an error.
 * To derive the public node associated with a child private node that requires
 * hardened derivation, begin with private derivation, then provide the result
 * to {@link deriveHdPublicNode} or {@link deriveHdPathRelative}.
 *
 * By default, this function throws an `Error` rather than returning the error
 * as string when the provided path is invalid or cannot be derived from the
 * provided HD node (e.g. the path requests an excessive child index, a hardened
 * path is requested from a public node, or an astronomically rare HMAC-SHA512
 * result produces and invalid node).
 *
 * While the throwing behavior is reasonable for the common case of deriving
 * known, fixed paths (e.g. the BCH account as standardized by SLIP44 at
 * `m/44'/145'/0'`), **it is recommended that `throwErrors` be set to `false`
 * for use cases where dynamic or user-specified paths might be derived**. In
 * these cases, deliberate error handling is recommended, e.g. saving any data
 * and safely shutting down, displaying troubleshooting information to the
 * user, etc.
 *
 * @param node - The HD node from which to begin the derivation – for paths
 * beginning with `m`, an {@link HdPrivateNodeValid}; for paths beginning with
 * `M`, an {@link HdPublicNodeValid}.
 * @param path - The BIP32 derivation path, e.g. `m/0/1'/2` or `M/3/4/5`.
 */
// eslint-disable-next-line complexity
const deriveHdPath = (node, path, { crypto = {
    ripemd160: ripemd160,
    secp256k1: secp256k1,
    sha256: sha256,
    sha512: sha512,
}, throwErrors = true, } = {}) => {
    if (node.depth !== 0) {
        return formatError(HdNodeDerivationError.requiresZeroDepthNode, `Depth of provided HD node: ${node.depth}.`, throwErrors);
    }
    const validDerivationPath = /^[mM](?:\/[0-9]+'?)*$/u;
    if (!validDerivationPath.test(path)) {
        return formatError(HdNodeDerivationError.invalidAbsoluteDerivationPath, `Invalid path: "${path}".`, throwErrors);
    }
    const parsed = path.split('/');
    const isPrivateDerivation = 'privateKey' in node;
    if (isPrivateDerivation && parsed[0] !== 'm') {
        return formatError(HdNodeDerivationError.invalidPrivateDerivationPrefix, `Invalid path: "${path}".`, throwErrors);
    }
    if (!isPrivateDerivation && parsed[0] !== 'M') {
        return formatError(HdNodeDerivationError.invalidPublicDerivationPrefix, `Invalid path: "${path}".`, throwErrors);
    }
    if (parsed.length === 1) {
        return node;
    }
    const relativePath = parsed.slice(1).join('/');
    return deriveHdPathRelative(node, relativePath, {
        crypto,
        throwErrors,
    });
};
var HdNodeCrackingError;
(function (HdNodeCrackingError) {
    HdNodeCrackingError["cannotCrackHardenedDerivation"] = "HD node cracking error: cannot crack an HD parent node using hardened child node.";
})(HdNodeCrackingError || (HdNodeCrackingError = {}));
/**
 * Derive the HD private node from a HD public node, given any non-hardened
 * child private node.
 *
 * This exploits the "non-hardened" BIP32 derivation algorithm. Because
 * non-hardened derivation only requires knowledge of the "chain code" (rather
 * than requiring knowledge of the parent private key) it's possible to
 * calculate the value by which the parent private key is "tweaked" to arrive at
 * the child private key. Since we have the child private key, we simply
 * subtract this "tweaked" amount to get back to the parent private key.
 *
 * The BIP32 "hardened" derivation algorithm is designed to address this
 * weakness. Using hardened derivation, child private nodes can be shared
 * without risk of leaking the parent private node, but this comes at the cost
 * of public node derivation. Given only a parent public node, it is not
 * possible to derive hardened child public keys, so applications must choose
 * between support for HD public node derivation or support for sharing child
 * private nodes.
 *
 * @param parentPublicNode - the parent HD public node for which to derive a
 * private node.
 * @param childPrivateNode - Any non-hardened child private node of the parent
 * node (only the `privateKey` and the `childIndex` are required).
 */
const crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode = (parentPublicNode, childPrivateNode, { crypto = { sha512: sha512 }, } = {}) => {
    const hardenedIndexOffset = 0x80000000;
    if (childPrivateNode.childIndex >= hardenedIndexOffset) {
        return HdNodeCrackingError.cannotCrackHardenedDerivation;
    }
    const serialization = Uint8Array.from([
        ...parentPublicNode.publicKey,
        ...numberToBinUint32BE(childPrivateNode.childIndex),
    ]);
    const derivation = hmacSha512(parentPublicNode.chainCode, serialization, crypto.sha512);
    const tweakValueLength = 32;
    const tweakValue = binToBigIntUint256BE(derivation.slice(0, tweakValueLength));
    const childPrivateValue = binToBigIntUint256BE(childPrivateNode.privateKey);
    const secp256k1OrderN = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
    const trueMod = (n, m) => ((n % m) + m) % m;
    const parentPrivateValue = trueMod(childPrivateValue - tweakValue, secp256k1OrderN);
    const privateKey = bigIntToBinUint256BEClamped(parentPrivateValue);
    return {
        chainCode: parentPublicNode.chainCode,
        childIndex: parentPublicNode.childIndex,
        depth: parentPublicNode.depth,
        parentFingerprint: parentPublicNode.parentFingerprint,
        ...(parentPublicNode.parentIdentifier === undefined
            ? {}
            : { parentIdentifier: parentPublicNode.parentIdentifier }),
        privateKey,
    };
};

var EntropyGenerationError;
(function (EntropyGenerationError) {
    EntropyGenerationError["duplicateResults"] = "Entropy generation error: the \"getRandomValues\" function provided by this JavaScript environment returned duplicate results across two evaluations; entropy generation was halted for safety.";
    EntropyGenerationError["insufficientEntropy"] = "Entropy generation error: the provided list of events contains insufficient entropy.";
})(EntropyGenerationError || (EntropyGenerationError = {}));
/**
 * Generate a Uint8Array of the specified length containing a
 * cryptographically-random series of bytes. See {@link generateRandomBytes} for
 * a safer alternative.
 *
 * @param length - the length of the Uint8Array to generate
 * @param cryptoInstance - an instance of the `Crypto` object with the
 * `getRandomValues` function (defaults to the `crypto` global property).
 */
const generateRandomBytesUnchecked = (length, cryptoInstance = crypto) => cryptoInstance.getRandomValues(new Uint8Array(length));
/**
 * Generate a Uint8Array of the specified length containing a
 * cryptographically-random series of bytes.
 *
 * For safety, this function first verifies that the provided `generate`
 * function produces unique results across two evaluations; by default, this
 * verifies that the `crypto.getRandomValues` function provided by the
 * JavaScript environment appears to be producing random values.
 *
 * While this validation can't prevent a compromised environment from producing
 * attacker-known entropy, it may help to prevent software defects in unusual
 * environments (e.g. React Native) from impacting end-user security.
 *
 * An `Error` is thrown if this validation fails, otherwise, the `Uint8Array`
 * produced by the first evaluation is returned.
 *
 * @param length - the length of the Uint8Array to generate
 * @param generate - a function used to generate the random bytes, defaults
 * to {@link generateRandomBytesUnchecked}.
 */
const generateRandomBytes = (length, generate = generateRandomBytesUnchecked) => {
    const firstRun = generate(length);
    const secondRun = generate(length);
    if (firstRun === secondRun || binsAreEqual(firstRun, secondRun))
        return formatError(EntropyGenerationError.duplicateResults, `First result: [${String(firstRun)}]; second result: [${String(secondRun)}].`, true);
    return firstRun;
};
/**
 * Securely generate a 32-byte, cryptographically random seed (Uint8Array) for
 * use in Hierarchical Deterministic (HD) Key derivation
 * (see {@link deriveHdPrivateNodeFromSeed}).
 *
 * To generate a single Secp256k1 private key, use {@link generatePrivateKey}.
 */
const generateRandomSeed = () => generateRandomBytes(32 /* KeyUtilConstants.privateKeyLength */);
/**
 * Securely generate a valid Secp256k1 private key.
 *
 * By default, this function uses `crypto.getRandomValues` to produce
 * sufficiently-random key material, but another source of randomness may also
 * be provided.
 *
 * To generate an HD Key, use {@link generateHdPrivateKey}.
 *
 * @param secureRandom - a method that returns a securely-random 32-byte
 * Uint8Array
 */
const generatePrivateKey = (secureRandom = generateRandomSeed) => {
    // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
    let maybeKey;
    // eslint-disable-next-line functional/no-loop-statements
    do {
        // eslint-disable-next-line functional/no-expression-statements
        maybeKey = secureRandom();
    } while (!validateSecp256k1PrivateKey(maybeKey));
    return maybeKey;
};
/**
 * Securely generate a valid {@link HdPrivateNode}, returning both the source
 * seed and the {@link HdPrivateNodeValid}.
 *
 * By default, this function uses `crypto.getRandomValues` to produce
 * sufficiently-random key material, but another source of randomness may also
 * be provided.
 *
 * To generate a single Secp256k1 private key, use {@link generatePrivateKey}.
 */
const generateHdPrivateNode = (secureRandom = generateRandomSeed) => {
    // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
    let seed;
    // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
    let hdPrivateNode;
    // eslint-disable-next-line functional/no-loop-statements
    do {
        // eslint-disable-next-line functional/no-expression-statements
        seed = secureRandom();
        // eslint-disable-next-line functional/no-expression-statements
        hdPrivateNode = deriveHdPrivateNodeFromSeed(seed);
    } while ('invalidMaterial' in hdPrivateNode);
    return {
        hdPrivateNode,
        seed,
    };
};
/*
 * TODO: export const generateLibauthSecretKey = (secureRandom = generateRandomSeed) => {
 *   const { seed } = generateHdPrivateNode(secureRandom);
 *   return encodeLibauthSecretKey({ seed });
 * };
 */
/**
 * Given the number of equally-likely results per event, return the Shannon
 * entropy of the event in bits.
 *
 * @param possibleResults - the number of equally-likely results per event;
 * e.g. for a coin, `2`, for dice, the number of faces (for a standard die, `6`)
 */
const shannonEntropyPerEvent = (possibleResults) => Math.log2(possibleResults);
/**
 * Given the number of equally-likely results per event, return the number of
 * events required to achieve the required bits of Shannon entropy.
 * entropy of the event in bits.
 *
 * For example, to compute the number of standard, 6-sided dice rolls required
 * to generate a private key (with the recommended 128-bit entropy minimum),
 * `minimumEventsPerEntropyBits(6)`.
 *
 * @param possibleResults - the number of equally-likely results per event;
 * e.g. for a coin, `2`, for dice, the number of faces (for a standard die, `6`)
 * @param requiredEntropyBits - the number of bits of entropy required. Defaults
 * to `128`, the recommended value for all private key generation.
 */
const minimumEventsPerEntropyBits = (possibleResults, requiredEntropyBits = 128 /* KeyUtilConstants.privateKeyRequiredEntropyBits */) => Math.ceil(requiredEntropyBits / shannonEntropyPerEvent(possibleResults));
/**
 * Generate deterministic entropy by seeding SHA-256 with a list of random
 * events like coin flips or dice rolls. For coin flips, use `0` ("heads") and
 * `1` ("tails"); for dice, use the visible number.
 *
 * **Warning: this function's validation assumes that the provided events
 * are truly random ("unbiased").** If the events are biased, e.g. by a weighted
 * dice or a human attempting to type random numbers, the entropy of this
 * function's result will be degraded. Using insufficiently random results will
 * compromise the security of systems relying on the result, making it possible
 * for an attacker to, e.g. guess secret keys and steal funds.
 *
 * This method of entropy generation is designed to be easily auditable: the
 * list of results are simply concatenated (without any spaces or separating
 * characters), and the UTF8 encoding of the resulting string of digits is
 * hashed with SHA-256.
 *
 * For example, if a 20-sided dice (D20) is rolled 3 times with results 13, 4,
 * and 10, the UTF8 encoding of `13410` (`0x3133343130`) is hashed with SHA-256,
 * producing a result of
 * `6dd4f2758287be9f38e0e93c71146c76e90f83f0b8c9b49760fc0b594494607b`. This can
 * be verified in most command line environments with the command:
 * `echo -n 13410 | sha256sum`.
 *
 * Note that this function is compatible with Coldcard's deterministic key
 * generation workflow when used with six-sided dice (D6).
 *
 * @param possibleResults - the number of equally-likely results per event;
 * e.g. for a coin, `2`, for dice, the number of faces (for a standard die, `6`)
 * @param events - an array of numbers encoding the random events; for coin
 * flips, use `0` ("heads") and `1` ("tails"); for dice, use the exposed number
 * (e.g. `1` through `6` for 6-sided dice)
 * @param requiredEntropyBits - the number of bits of entropy required. Defaults
 * to `128`, the recommended value for all private key generation.
 * @param crypto - an optional object containing an implementation of sha256
 * to use
 */
const generateDeterministicEntropy = (possibleResults, events, { crypto = { sha256: sha256 }, requiredEntropyBits = 128 /* KeyUtilConstants.privateKeyRequiredEntropyBits */, } = {}) => {
    const minimumEventCount = minimumEventsPerEntropyBits(possibleResults, requiredEntropyBits);
    if (possibleResults === 0 || events.length < minimumEventCount) {
        return formatError(EntropyGenerationError.insufficientEntropy, `With ${possibleResults} possible results per event, a minimum of ${minimumEventCount} events are required to obtain sufficient entropy. Events provided: ${events.length}.`);
    }
    const concatenatedDigits = [...events.join('')].map((digit) => Number(digit) + 48 /* KeyUtilConstants.utf8NumbersOffset */);
    const source = Uint8Array.from(concatenatedDigits);
    return crypto.sha256.hash(source);
};
// TODO: export const generateLibauthSecretKeyFromCoinFlips = () => {}
// TODO: export const generateLibauthSecretKeyFromDiceRolls = () => {}

/* eslint-disable max-lines */ /* cspell: disable */ const raw$9 = `的
一
是
在
不
了
有
和
人
这
中
大
为
上
个
国
我
以
要
他
时
来
用
们
生
到
作
地
于
出
就
分
对
成
会
可
主
发
年
动
同
工
也
能
下
过
子
说
产
种
面
而
方
后
多
定
行
学
法
所
民
得
经
十
三
之
进
着
等
部
度
家
电
力
里
如
水
化
高
自
二
理
起
小
物
现
实
加
量
都
两
体
制
机
当
使
点
从
业
本
去
把
性
好
应
开
它
合
还
因
由
其
些
然
前
外
天
政
四
日
那
社
义
事
平
形
相
全
表
间
样
与
关
各
重
新
线
内
数
正
心
反
你
明
看
原
又
么
利
比
或
但
质
气
第
向
道
命
此
变
条
只
没
结
解
问
意
建
月
公
无
系
军
很
情
者
最
立
代
想
已
通
并
提
直
题
党
程
展
五
果
料
象
员
革
位
入
常
文
总
次
品
式
活
设
及
管
特
件
长
求
老
头
基
资
边
流
路
级
少
图
山
统
接
知
较
将
组
见
计
别
她
手
角
期
根
论
运
农
指
几
九
区
强
放
决
西
被
干
做
必
战
先
回
则
任
取
据
处
队
南
给
色
光
门
即
保
治
北
造
百
规
热
领
七
海
口
东
导
器
压
志
世
金
增
争
济
阶
油
思
术
极
交
受
联
什
认
六
共
权
收
证
改
清
美
再
采
转
更
单
风
切
打
白
教
速
花
带
安
场
身
车
例
真
务
具
万
每
目
至
达
走
积
示
议
声
报
斗
完
类
八
离
华
名
确
才
科
张
信
马
节
话
米
整
空
元
况
今
集
温
传
土
许
步
群
广
石
记
需
段
研
界
拉
林
律
叫
且
究
观
越
织
装
影
算
低
持
音
众
书
布
复
容
儿
须
际
商
非
验
连
断
深
难
近
矿
千
周
委
素
技
备
半
办
青
省
列
习
响
约
支
般
史
感
劳
便
团
往
酸
历
市
克
何
除
消
构
府
称
太
准
精
值
号
率
族
维
划
选
标
写
存
候
毛
亲
快
效
斯
院
查
江
型
眼
王
按
格
养
易
置
派
层
片
始
却
专
状
育
厂
京
识
适
属
圆
包
火
住
调
满
县
局
照
参
红
细
引
听
该
铁
价
严
首
底
液
官
德
随
病
苏
失
尔
死
讲
配
女
黄
推
显
谈
罪
神
艺
呢
席
含
企
望
密
批
营
项
防
举
球
英
氧
势
告
李
台
落
木
帮
轮
破
亚
师
围
注
远
字
材
排
供
河
态
封
另
施
减
树
溶
怎
止
案
言
士
均
武
固
叶
鱼
波
视
仅
费
紧
爱
左
章
早
朝
害
续
轻
服
试
食
充
兵
源
判
护
司
足
某
练
差
致
板
田
降
黑
犯
负
击
范
继
兴
似
余
坚
曲
输
修
故
城
夫
够
送
笔
船
占
右
财
吃
富
春
职
觉
汉
画
功
巴
跟
虽
杂
飞
检
吸
助
升
阳
互
初
创
抗
考
投
坏
策
古
径
换
未
跑
留
钢
曾
端
责
站
简
述
钱
副
尽
帝
射
草
冲
承
独
令
限
阿
宣
环
双
请
超
微
让
控
州
良
轴
找
否
纪
益
依
优
顶
础
载
倒
房
突
坐
粉
敌
略
客
袁
冷
胜
绝
析
块
剂
测
丝
协
诉
念
陈
仍
罗
盐
友
洋
错
苦
夜
刑
移
频
逐
靠
混
母
短
皮
终
聚
汽
村
云
哪
既
距
卫
停
烈
央
察
烧
迅
境
若
印
洲
刻
括
激
孔
搞
甚
室
待
核
校
散
侵
吧
甲
游
久
菜
味
旧
模
湖
货
损
预
阻
毫
普
稳
乙
妈
植
息
扩
银
语
挥
酒
守
拿
序
纸
医
缺
雨
吗
针
刘
啊
急
唱
误
训
愿
审
附
获
茶
鲜
粮
斤
孩
脱
硫
肥
善
龙
演
父
渐
血
欢
械
掌
歌
沙
刚
攻
谓
盾
讨
晚
粒
乱
燃
矛
乎
杀
药
宁
鲁
贵
钟
煤
读
班
伯
香
介
迫
句
丰
培
握
兰
担
弦
蛋
沉
假
穿
执
答
乐
谁
顺
烟
缩
征
脸
喜
松
脚
困
异
免
背
星
福
买
染
井
概
慢
怕
磁
倍
祖
皇
促
静
补
评
翻
肉
践
尼
衣
宽
扬
棉
希
伤
操
垂
秋
宜
氢
套
督
振
架
亮
末
宪
庆
编
牛
触
映
雷
销
诗
座
居
抓
裂
胞
呼
娘
景
威
绿
晶
厚
盟
衡
鸡
孙
延
危
胶
屋
乡
临
陆
顾
掉
呀
灯
岁
措
束
耐
剧
玉
赵
跳
哥
季
课
凯
胡
额
款
绍
卷
齐
伟
蒸
殖
永
宗
苗
川
炉
岩
弱
零
杨
奏
沿
露
杆
探
滑
镇
饭
浓
航
怀
赶
库
夺
伊
灵
税
途
灭
赛
归
召
鼓
播
盘
裁
险
康
唯
录
菌
纯
借
糖
盖
横
符
私
努
堂
域
枪
润
幅
哈
竟
熟
虫
泽
脑
壤
碳
欧
遍
侧
寨
敢
彻
虑
斜
薄
庭
纳
弹
饲
伸
折
麦
湿
暗
荷
瓦
塞
床
筑
恶
户
访
塔
奇
透
梁
刀
旋
迹
卡
氯
遇
份
毒
泥
退
洗
摆
灰
彩
卖
耗
夏
择
忙
铜
献
硬
予
繁
圈
雪
函
亦
抽
篇
阵
阴
丁
尺
追
堆
雄
迎
泛
爸
楼
避
谋
吨
野
猪
旗
累
偏
典
馆
索
秦
脂
潮
爷
豆
忽
托
惊
塑
遗
愈
朱
替
纤
粗
倾
尚
痛
楚
谢
奋
购
磨
君
池
旁
碎
骨
监
捕
弟
暴
割
贯
殊
释
词
亡
壁
顿
宝
午
尘
闻
揭
炮
残
冬
桥
妇
警
综
招
吴
付
浮
遭
徐
您
摇
谷
赞
箱
隔
订
男
吹
园
纷
唐
败
宋
玻
巨
耕
坦
荣
闭
湾
键
凡
驻
锅
救
恩
剥
凝
碱
齿
截
炼
麻
纺
禁
废
盛
版
缓
净
睛
昌
婚
涉
筒
嘴
插
岸
朗
庄
街
藏
姑
贸
腐
奴
啦
惯
乘
伙
恢
匀
纱
扎
辩
耳
彪
臣
亿
璃
抵
脉
秀
萨
俄
网
舞
店
喷
纵
寸
汗
挂
洪
贺
闪
柬
爆
烯
津
稻
墙
软
勇
像
滚
厘
蒙
芳
肯
坡
柱
荡
腿
仪
旅
尾
轧
冰
贡
登
黎
削
钻
勒
逃
障
氨
郭
峰
币
港
伏
轨
亩
毕
擦
莫
刺
浪
秘
援
株
健
售
股
岛
甘
泡
睡
童
铸
汤
阀
休
汇
舍
牧
绕
炸
哲
磷
绩
朋
淡
尖
启
陷
柴
呈
徒
颜
泪
稍
忘
泵
蓝
拖
洞
授
镜
辛
壮
锋
贫
虚
弯
摩
泰
幼
廷
尊
窗
纲
弄
隶
疑
氏
宫
姐
震
瑞
怪
尤
琴
循
描
膜
违
夹
腰
缘
珠
穷
森
枝
竹
沟
催
绳
忆
邦
剩
幸
浆
栏
拥
牙
贮
礼
滤
钠
纹
罢
拍
咱
喊
袖
埃
勤
罚
焦
潜
伍
墨
欲
缝
姓
刊
饱
仿
奖
铝
鬼
丽
跨
默
挖
链
扫
喝
袋
炭
污
幕
诸
弧
励
梅
奶
洁
灾
舟
鉴
苯
讼
抱
毁
懂
寒
智
埔
寄
届
跃
渡
挑
丹
艰
贝
碰
拔
爹
戴
码
梦
芽
熔
赤
渔
哭
敬
颗
奔
铅
仲
虎
稀
妹
乏
珍
申
桌
遵
允
隆
螺
仓
魏
锐
晓
氮
兼
隐
碍
赫
拨
忠
肃
缸
牵
抢
博
巧
壳
兄
杜
讯
诚
碧
祥
柯
页
巡
矩
悲
灌
龄
伦
票
寻
桂
铺
圣
恐
恰
郑
趣
抬
荒
腾
贴
柔
滴
猛
阔
辆
妻
填
撤
储
签
闹
扰
紫
砂
递
戏
吊
陶
伐
喂
疗
瓶
婆
抚
臂
摸
忍
虾
蜡
邻
胸
巩
挤
偶
弃
槽
劲
乳
邓
吉
仁
烂
砖
租
乌
舰
伴
瓜
浅
丙
暂
燥
橡
柳
迷
暖
牌
秧
胆
详
簧
踏
瓷
谱
呆
宾
糊
洛
辉
愤
竞
隙
怒
粘
乃
绪
肩
籍
敏
涂
熙
皆
侦
悬
掘
享
纠
醒
狂
锁
淀
恨
牲
霸
爬
赏
逆
玩
陵
祝
秒
浙
貌
役
彼
悉
鸭
趋
凤
晨
畜
辈
秩
卵
署
梯
炎
滩
棋
驱
筛
峡
冒
啥
寿
译
浸
泉
帽
迟
硅
疆
贷
漏
稿
冠
嫩
胁
芯
牢
叛
蚀
奥
鸣
岭
羊
凭
串
塘
绘
酵
融
盆
锡
庙
筹
冻
辅
摄
袭
筋
拒
僚
旱
钾
鸟
漆
沈
眉
疏
添
棒
穗
硝
韩
逼
扭
侨
凉
挺
碗
栽
炒
杯
患
馏
劝
豪
辽
勃
鸿
旦
吏
拜
狗
埋
辊
掩
饮
搬
骂
辞
勾
扣
估
蒋
绒
雾
丈
朵
姆
拟
宇
辑
陕
雕
偿
蓄
崇
剪
倡
厅
咬
驶
薯
刷
斥
番
赋
奉
佛
浇
漫
曼
扇
钙
桃
扶
仔
返
俗
亏
腔
鞋
棱
覆
框
悄
叔
撞
骗
勘
旺
沸
孤
吐
孟
渠
屈
疾
妙
惜
仰
狠
胀
谐
抛
霉
桑
岗
嘛
衰
盗
渗
脏
赖
涌
甜
曹
阅
肌
哩
厉
烃
纬
毅
昨
伪
症
煮
叹
钉
搭
茎
笼
酷
偷
弓
锥
恒
杰
坑
鼻
翼
纶
叙
狱
逮
罐
络
棚
抑
膨
蔬
寺
骤
穆
冶
枯
册
尸
凸
绅
坯
牺
焰
轰
欣
晋
瘦
御
锭
锦
丧
旬
锻
垄
搜
扑
邀
亭
酯
迈
舒
脆
酶
闲
忧
酚
顽
羽
涨
卸
仗
陪
辟
惩
杭
姚
肚
捉
飘
漂
昆
欺
吾
郎
烷
汁
呵
饰
萧
雅
邮
迁
燕
撒
姻
赴
宴
烦
债
帐
斑
铃
旨
醇
董
饼
雏
姿
拌
傅
腹
妥
揉
贤
拆
歪
葡
胺
丢
浩
徽
昂
垫
挡
览
贪
慰
缴
汪
慌
冯
诺
姜
谊
凶
劣
诬
耀
昏
躺
盈
骑
乔
溪
丛
卢
抹
闷
咨
刮
驾
缆
悟
摘
铒
掷
颇
幻
柄
惠
惨
佳
仇
腊
窝
涤
剑
瞧
堡
泼
葱
罩
霍
捞
胎
苍
滨
俩
捅
湘
砍
霞
邵
萄
疯
淮
遂
熊
粪
烘
宿
档
戈
驳
嫂
裕
徙
箭
捐
肠
撑
晒
辨
殿
莲
摊
搅
酱
屏
疫
哀
蔡
堵
沫
皱
畅
叠
阁
莱
敲
辖
钩
痕
坝
巷
饿
祸
丘
玄
溜
曰
逻
彭
尝
卿
妨
艇
吞
韦
怨
矮
歇`;
const bip39WordListChineseSimplified = raw$9.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$8 = `的
一
是
在
不
了
有
和
人
這
中
大
為
上
個
國
我
以
要
他
時
來
用
們
生
到
作
地
於
出
就
分
對
成
會
可
主
發
年
動
同
工
也
能
下
過
子
說
產
種
面
而
方
後
多
定
行
學
法
所
民
得
經
十
三
之
進
著
等
部
度
家
電
力
裡
如
水
化
高
自
二
理
起
小
物
現
實
加
量
都
兩
體
制
機
當
使
點
從
業
本
去
把
性
好
應
開
它
合
還
因
由
其
些
然
前
外
天
政
四
日
那
社
義
事
平
形
相
全
表
間
樣
與
關
各
重
新
線
內
數
正
心
反
你
明
看
原
又
麼
利
比
或
但
質
氣
第
向
道
命
此
變
條
只
沒
結
解
問
意
建
月
公
無
系
軍
很
情
者
最
立
代
想
已
通
並
提
直
題
黨
程
展
五
果
料
象
員
革
位
入
常
文
總
次
品
式
活
設
及
管
特
件
長
求
老
頭
基
資
邊
流
路
級
少
圖
山
統
接
知
較
將
組
見
計
別
她
手
角
期
根
論
運
農
指
幾
九
區
強
放
決
西
被
幹
做
必
戰
先
回
則
任
取
據
處
隊
南
給
色
光
門
即
保
治
北
造
百
規
熱
領
七
海
口
東
導
器
壓
志
世
金
增
爭
濟
階
油
思
術
極
交
受
聯
什
認
六
共
權
收
證
改
清
美
再
採
轉
更
單
風
切
打
白
教
速
花
帶
安
場
身
車
例
真
務
具
萬
每
目
至
達
走
積
示
議
聲
報
鬥
完
類
八
離
華
名
確
才
科
張
信
馬
節
話
米
整
空
元
況
今
集
溫
傳
土
許
步
群
廣
石
記
需
段
研
界
拉
林
律
叫
且
究
觀
越
織
裝
影
算
低
持
音
眾
書
布
复
容
兒
須
際
商
非
驗
連
斷
深
難
近
礦
千
週
委
素
技
備
半
辦
青
省
列
習
響
約
支
般
史
感
勞
便
團
往
酸
歷
市
克
何
除
消
構
府
稱
太
準
精
值
號
率
族
維
劃
選
標
寫
存
候
毛
親
快
效
斯
院
查
江
型
眼
王
按
格
養
易
置
派
層
片
始
卻
專
狀
育
廠
京
識
適
屬
圓
包
火
住
調
滿
縣
局
照
參
紅
細
引
聽
該
鐵
價
嚴
首
底
液
官
德
隨
病
蘇
失
爾
死
講
配
女
黃
推
顯
談
罪
神
藝
呢
席
含
企
望
密
批
營
項
防
舉
球
英
氧
勢
告
李
台
落
木
幫
輪
破
亞
師
圍
注
遠
字
材
排
供
河
態
封
另
施
減
樹
溶
怎
止
案
言
士
均
武
固
葉
魚
波
視
僅
費
緊
愛
左
章
早
朝
害
續
輕
服
試
食
充
兵
源
判
護
司
足
某
練
差
致
板
田
降
黑
犯
負
擊
范
繼
興
似
餘
堅
曲
輸
修
故
城
夫
夠
送
筆
船
佔
右
財
吃
富
春
職
覺
漢
畫
功
巴
跟
雖
雜
飛
檢
吸
助
昇
陽
互
初
創
抗
考
投
壞
策
古
徑
換
未
跑
留
鋼
曾
端
責
站
簡
述
錢
副
盡
帝
射
草
衝
承
獨
令
限
阿
宣
環
雙
請
超
微
讓
控
州
良
軸
找
否
紀
益
依
優
頂
礎
載
倒
房
突
坐
粉
敵
略
客
袁
冷
勝
絕
析
塊
劑
測
絲
協
訴
念
陳
仍
羅
鹽
友
洋
錯
苦
夜
刑
移
頻
逐
靠
混
母
短
皮
終
聚
汽
村
雲
哪
既
距
衛
停
烈
央
察
燒
迅
境
若
印
洲
刻
括
激
孔
搞
甚
室
待
核
校
散
侵
吧
甲
遊
久
菜
味
舊
模
湖
貨
損
預
阻
毫
普
穩
乙
媽
植
息
擴
銀
語
揮
酒
守
拿
序
紙
醫
缺
雨
嗎
針
劉
啊
急
唱
誤
訓
願
審
附
獲
茶
鮮
糧
斤
孩
脫
硫
肥
善
龍
演
父
漸
血
歡
械
掌
歌
沙
剛
攻
謂
盾
討
晚
粒
亂
燃
矛
乎
殺
藥
寧
魯
貴
鐘
煤
讀
班
伯
香
介
迫
句
豐
培
握
蘭
擔
弦
蛋
沉
假
穿
執
答
樂
誰
順
煙
縮
徵
臉
喜
松
腳
困
異
免
背
星
福
買
染
井
概
慢
怕
磁
倍
祖
皇
促
靜
補
評
翻
肉
踐
尼
衣
寬
揚
棉
希
傷
操
垂
秋
宜
氫
套
督
振
架
亮
末
憲
慶
編
牛
觸
映
雷
銷
詩
座
居
抓
裂
胞
呼
娘
景
威
綠
晶
厚
盟
衡
雞
孫
延
危
膠
屋
鄉
臨
陸
顧
掉
呀
燈
歲
措
束
耐
劇
玉
趙
跳
哥
季
課
凱
胡
額
款
紹
卷
齊
偉
蒸
殖
永
宗
苗
川
爐
岩
弱
零
楊
奏
沿
露
桿
探
滑
鎮
飯
濃
航
懷
趕
庫
奪
伊
靈
稅
途
滅
賽
歸
召
鼓
播
盤
裁
險
康
唯
錄
菌
純
借
糖
蓋
橫
符
私
努
堂
域
槍
潤
幅
哈
竟
熟
蟲
澤
腦
壤
碳
歐
遍
側
寨
敢
徹
慮
斜
薄
庭
納
彈
飼
伸
折
麥
濕
暗
荷
瓦
塞
床
築
惡
戶
訪
塔
奇
透
梁
刀
旋
跡
卡
氯
遇
份
毒
泥
退
洗
擺
灰
彩
賣
耗
夏
擇
忙
銅
獻
硬
予
繁
圈
雪
函
亦
抽
篇
陣
陰
丁
尺
追
堆
雄
迎
泛
爸
樓
避
謀
噸
野
豬
旗
累
偏
典
館
索
秦
脂
潮
爺
豆
忽
托
驚
塑
遺
愈
朱
替
纖
粗
傾
尚
痛
楚
謝
奮
購
磨
君
池
旁
碎
骨
監
捕
弟
暴
割
貫
殊
釋
詞
亡
壁
頓
寶
午
塵
聞
揭
炮
殘
冬
橋
婦
警
綜
招
吳
付
浮
遭
徐
您
搖
谷
贊
箱
隔
訂
男
吹
園
紛
唐
敗
宋
玻
巨
耕
坦
榮
閉
灣
鍵
凡
駐
鍋
救
恩
剝
凝
鹼
齒
截
煉
麻
紡
禁
廢
盛
版
緩
淨
睛
昌
婚
涉
筒
嘴
插
岸
朗
莊
街
藏
姑
貿
腐
奴
啦
慣
乘
夥
恢
勻
紗
扎
辯
耳
彪
臣
億
璃
抵
脈
秀
薩
俄
網
舞
店
噴
縱
寸
汗
掛
洪
賀
閃
柬
爆
烯
津
稻
牆
軟
勇
像
滾
厘
蒙
芳
肯
坡
柱
盪
腿
儀
旅
尾
軋
冰
貢
登
黎
削
鑽
勒
逃
障
氨
郭
峰
幣
港
伏
軌
畝
畢
擦
莫
刺
浪
秘
援
株
健
售
股
島
甘
泡
睡
童
鑄
湯
閥
休
匯
舍
牧
繞
炸
哲
磷
績
朋
淡
尖
啟
陷
柴
呈
徒
顏
淚
稍
忘
泵
藍
拖
洞
授
鏡
辛
壯
鋒
貧
虛
彎
摩
泰
幼
廷
尊
窗
綱
弄
隸
疑
氏
宮
姐
震
瑞
怪
尤
琴
循
描
膜
違
夾
腰
緣
珠
窮
森
枝
竹
溝
催
繩
憶
邦
剩
幸
漿
欄
擁
牙
貯
禮
濾
鈉
紋
罷
拍
咱
喊
袖
埃
勤
罰
焦
潛
伍
墨
欲
縫
姓
刊
飽
仿
獎
鋁
鬼
麗
跨
默
挖
鏈
掃
喝
袋
炭
污
幕
諸
弧
勵
梅
奶
潔
災
舟
鑑
苯
訟
抱
毀
懂
寒
智
埔
寄
屆
躍
渡
挑
丹
艱
貝
碰
拔
爹
戴
碼
夢
芽
熔
赤
漁
哭
敬
顆
奔
鉛
仲
虎
稀
妹
乏
珍
申
桌
遵
允
隆
螺
倉
魏
銳
曉
氮
兼
隱
礙
赫
撥
忠
肅
缸
牽
搶
博
巧
殼
兄
杜
訊
誠
碧
祥
柯
頁
巡
矩
悲
灌
齡
倫
票
尋
桂
鋪
聖
恐
恰
鄭
趣
抬
荒
騰
貼
柔
滴
猛
闊
輛
妻
填
撤
儲
簽
鬧
擾
紫
砂
遞
戲
吊
陶
伐
餵
療
瓶
婆
撫
臂
摸
忍
蝦
蠟
鄰
胸
鞏
擠
偶
棄
槽
勁
乳
鄧
吉
仁
爛
磚
租
烏
艦
伴
瓜
淺
丙
暫
燥
橡
柳
迷
暖
牌
秧
膽
詳
簧
踏
瓷
譜
呆
賓
糊
洛
輝
憤
競
隙
怒
粘
乃
緒
肩
籍
敏
塗
熙
皆
偵
懸
掘
享
糾
醒
狂
鎖
淀
恨
牲
霸
爬
賞
逆
玩
陵
祝
秒
浙
貌
役
彼
悉
鴨
趨
鳳
晨
畜
輩
秩
卵
署
梯
炎
灘
棋
驅
篩
峽
冒
啥
壽
譯
浸
泉
帽
遲
矽
疆
貸
漏
稿
冠
嫩
脅
芯
牢
叛
蝕
奧
鳴
嶺
羊
憑
串
塘
繪
酵
融
盆
錫
廟
籌
凍
輔
攝
襲
筋
拒
僚
旱
鉀
鳥
漆
沈
眉
疏
添
棒
穗
硝
韓
逼
扭
僑
涼
挺
碗
栽
炒
杯
患
餾
勸
豪
遼
勃
鴻
旦
吏
拜
狗
埋
輥
掩
飲
搬
罵
辭
勾
扣
估
蔣
絨
霧
丈
朵
姆
擬
宇
輯
陝
雕
償
蓄
崇
剪
倡
廳
咬
駛
薯
刷
斥
番
賦
奉
佛
澆
漫
曼
扇
鈣
桃
扶
仔
返
俗
虧
腔
鞋
棱
覆
框
悄
叔
撞
騙
勘
旺
沸
孤
吐
孟
渠
屈
疾
妙
惜
仰
狠
脹
諧
拋
黴
桑
崗
嘛
衰
盜
滲
臟
賴
湧
甜
曹
閱
肌
哩
厲
烴
緯
毅
昨
偽
症
煮
嘆
釘
搭
莖
籠
酷
偷
弓
錐
恆
傑
坑
鼻
翼
綸
敘
獄
逮
罐
絡
棚
抑
膨
蔬
寺
驟
穆
冶
枯
冊
屍
凸
紳
坯
犧
焰
轟
欣
晉
瘦
禦
錠
錦
喪
旬
鍛
壟
搜
撲
邀
亭
酯
邁
舒
脆
酶
閒
憂
酚
頑
羽
漲
卸
仗
陪
闢
懲
杭
姚
肚
捉
飄
漂
昆
欺
吾
郎
烷
汁
呵
飾
蕭
雅
郵
遷
燕
撒
姻
赴
宴
煩
債
帳
斑
鈴
旨
醇
董
餅
雛
姿
拌
傅
腹
妥
揉
賢
拆
歪
葡
胺
丟
浩
徽
昂
墊
擋
覽
貪
慰
繳
汪
慌
馮
諾
姜
誼
兇
劣
誣
耀
昏
躺
盈
騎
喬
溪
叢
盧
抹
悶
諮
刮
駕
纜
悟
摘
鉺
擲
頗
幻
柄
惠
慘
佳
仇
臘
窩
滌
劍
瞧
堡
潑
蔥
罩
霍
撈
胎
蒼
濱
倆
捅
湘
砍
霞
邵
萄
瘋
淮
遂
熊
糞
烘
宿
檔
戈
駁
嫂
裕
徙
箭
捐
腸
撐
曬
辨
殿
蓮
攤
攪
醬
屏
疫
哀
蔡
堵
沫
皺
暢
疊
閣
萊
敲
轄
鉤
痕
壩
巷
餓
禍
丘
玄
溜
曰
邏
彭
嘗
卿
妨
艇
吞
韋
怨
矮
歇`;
const bip39WordListChineseTraditional = raw$8.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$7 = `abdikace
abeceda
adresa
agrese
akce
aktovka
alej
alkohol
amputace
ananas
andulka
anekdota
anketa
antika
anulovat
archa
arogance
asfalt
asistent
aspirace
astma
astronom
atlas
atletika
atol
autobus
azyl
babka
bachor
bacil
baculka
badatel
bageta
bagr
bahno
bakterie
balada
baletka
balkon
balonek
balvan
balza
bambus
bankomat
barbar
baret
barman
baroko
barva
baterka
batoh
bavlna
bazalka
bazilika
bazuka
bedna
beran
beseda
bestie
beton
bezinka
bezmoc
beztak
bicykl
bidlo
biftek
bikiny
bilance
biograf
biolog
bitva
bizon
blahobyt
blatouch
blecha
bledule
blesk
blikat
blizna
blokovat
bloudit
blud
bobek
bobr
bodlina
bodnout
bohatost
bojkot
bojovat
bokorys
bolest
borec
borovice
bota
boubel
bouchat
bouda
boule
bourat
boxer
bradavka
brambora
branka
bratr
brepta
briketa
brko
brloh
bronz
broskev
brunetka
brusinka
brzda
brzy
bublina
bubnovat
buchta
buditel
budka
budova
bufet
bujarost
bukvice
buldok
bulva
bunda
bunkr
burza
butik
buvol
buzola
bydlet
bylina
bytovka
bzukot
capart
carevna
cedr
cedule
cejch
cejn
cela
celer
celkem
celnice
cenina
cennost
cenovka
centrum
cenzor
cestopis
cetka
chalupa
chapadlo
charita
chata
chechtat
chemie
chichot
chirurg
chlad
chleba
chlubit
chmel
chmura
chobot
chochol
chodba
cholera
chomout
chopit
choroba
chov
chrapot
chrlit
chrt
chrup
chtivost
chudina
chutnat
chvat
chvilka
chvost
chyba
chystat
chytit
cibule
cigareta
cihelna
cihla
cinkot
cirkus
cisterna
citace
citrus
cizinec
cizost
clona
cokoliv
couvat
ctitel
ctnost
cudnost
cuketa
cukr
cupot
cvaknout
cval
cvik
cvrkot
cyklista
daleko
dareba
datel
datum
dcera
debata
dechovka
decibel
deficit
deflace
dekl
dekret
demokrat
deprese
derby
deska
detektiv
dikobraz
diktovat
dioda
diplom
disk
displej
divadlo
divoch
dlaha
dlouho
dluhopis
dnes
dobro
dobytek
docent
dochutit
dodnes
dohled
dohoda
dohra
dojem
dojnice
doklad
dokola
doktor
dokument
dolar
doleva
dolina
doma
dominant
domluvit
domov
donutit
dopad
dopis
doplnit
doposud
doprovod
dopustit
dorazit
dorost
dort
dosah
doslov
dostatek
dosud
dosyta
dotaz
dotek
dotknout
doufat
doutnat
dovozce
dozadu
doznat
dozorce
drahota
drak
dramatik
dravec
draze
drdol
drobnost
drogerie
drozd
drsnost
drtit
drzost
duben
duchovno
dudek
duha
duhovka
dusit
dusno
dutost
dvojice
dvorec
dynamit
ekolog
ekonomie
elektron
elipsa
email
emise
emoce
empatie
epizoda
epocha
epopej
epos
esej
esence
eskorta
eskymo
etiketa
euforie
evoluce
exekuce
exkurze
expedice
exploze
export
extrakt
facka
fajfka
fakulta
fanatik
fantazie
farmacie
favorit
fazole
federace
fejeton
fenka
fialka
figurant
filozof
filtr
finance
finta
fixace
fjord
flanel
flirt
flotila
fond
fosfor
fotbal
fotka
foton
frakce
freska
fronta
fukar
funkce
fyzika
galeje
garant
genetika
geolog
gilotina
glazura
glejt
golem
golfista
gotika
graf
gramofon
granule
grep
gril
grog
groteska
guma
hadice
hadr
hala
halenka
hanba
hanopis
harfa
harpuna
havran
hebkost
hejkal
hejno
hejtman
hektar
helma
hematom
herec
herna
heslo
hezky
historik
hladovka
hlasivky
hlava
hledat
hlen
hlodavec
hloh
hloupost
hltat
hlubina
hluchota
hmat
hmota
hmyz
hnis
hnojivo
hnout
hoblina
hoboj
hoch
hodiny
hodlat
hodnota
hodovat
hojnost
hokej
holinka
holka
holub
homole
honitba
honorace
horal
horda
horizont
horko
horlivec
hormon
hornina
horoskop
horstvo
hospoda
hostina
hotovost
houba
houf
houpat
houska
hovor
hradba
hranice
hravost
hrazda
hrbolek
hrdina
hrdlo
hrdost
hrnek
hrobka
hromada
hrot
hrouda
hrozen
hrstka
hrubost
hryzat
hubenost
hubnout
hudba
hukot
humr
husita
hustota
hvozd
hybnost
hydrant
hygiena
hymna
hysterik
idylka
ihned
ikona
iluze
imunita
infekce
inflace
inkaso
inovace
inspekce
internet
invalida
investor
inzerce
ironie
jablko
jachta
jahoda
jakmile
jakost
jalovec
jantar
jarmark
jaro
jasan
jasno
jatka
javor
jazyk
jedinec
jedle
jednatel
jehlan
jekot
jelen
jelito
jemnost
jenom
jepice
jeseter
jevit
jezdec
jezero
jinak
jindy
jinoch
jiskra
jistota
jitrnice
jizva
jmenovat
jogurt
jurta
kabaret
kabel
kabinet
kachna
kadet
kadidlo
kahan
kajak
kajuta
kakao
kaktus
kalamita
kalhoty
kalibr
kalnost
kamera
kamkoliv
kamna
kanibal
kanoe
kantor
kapalina
kapela
kapitola
kapka
kaple
kapota
kapr
kapusta
kapybara
karamel
karotka
karton
kasa
katalog
katedra
kauce
kauza
kavalec
kazajka
kazeta
kazivost
kdekoliv
kdesi
kedluben
kemp
keramika
kino
klacek
kladivo
klam
klapot
klasika
klaun
klec
klenba
klepat
klesnout
klid
klima
klisna
klobouk
klokan
klopa
kloub
klubovna
klusat
kluzkost
kmen
kmitat
kmotr
kniha
knot
koalice
koberec
kobka
kobliha
kobyla
kocour
kohout
kojenec
kokos
koktejl
kolaps
koleda
kolize
kolo
komando
kometa
komik
komnata
komora
kompas
komunita
konat
koncept
kondice
konec
konfese
kongres
konina
konkurs
kontakt
konzerva
kopanec
kopie
kopnout
koprovka
korbel
korektor
kormidlo
koroptev
korpus
koruna
koryto
korzet
kosatec
kostka
kotel
kotleta
kotoul
koukat
koupelna
kousek
kouzlo
kovboj
koza
kozoroh
krabice
krach
krajina
kralovat
krasopis
kravata
kredit
krejcar
kresba
kreveta
kriket
kritik
krize
krkavec
krmelec
krmivo
krocan
krok
kronika
kropit
kroupa
krovka
krtek
kruhadlo
krupice
krutost
krvinka
krychle
krypta
krystal
kryt
kudlanka
kufr
kujnost
kukla
kulajda
kulich
kulka
kulomet
kultura
kuna
kupodivu
kurt
kurzor
kutil
kvalita
kvasinka
kvestor
kynolog
kyselina
kytara
kytice
kytka
kytovec
kyvadlo
labrador
lachtan
ladnost
laik
lakomec
lamela
lampa
lanovka
lasice
laso
lastura
latinka
lavina
lebka
leckdy
leden
lednice
ledovka
ledvina
legenda
legie
legrace
lehce
lehkost
lehnout
lektvar
lenochod
lentilka
lepenka
lepidlo
letadlo
letec
letmo
letokruh
levhart
levitace
levobok
libra
lichotka
lidojed
lidskost
lihovina
lijavec
lilek
limetka
linie
linka
linoleum
listopad
litina
litovat
lobista
lodivod
logika
logoped
lokalita
loket
lomcovat
lopata
lopuch
lord
losos
lotr
loudal
louh
louka
louskat
lovec
lstivost
lucerna
lucifer
lump
lusk
lustrace
lvice
lyra
lyrika
lysina
madam
madlo
magistr
mahagon
majetek
majitel
majorita
makak
makovice
makrela
malba
malina
malovat
malvice
maminka
mandle
manko
marnost
masakr
maskot
masopust
matice
matrika
maturita
mazanec
mazivo
mazlit
mazurka
mdloba
mechanik
meditace
medovina
melasa
meloun
mentolka
metla
metoda
metr
mezera
migrace
mihnout
mihule
mikina
mikrofon
milenec
milimetr
milost
mimika
mincovna
minibar
minomet
minulost
miska
mistr
mixovat
mladost
mlha
mlhovina
mlok
mlsat
mluvit
mnich
mnohem
mobil
mocnost
modelka
modlitba
mohyla
mokro
molekula
momentka
monarcha
monokl
monstrum
montovat
monzun
mosaz
moskyt
most
motivace
motorka
motyka
moucha
moudrost
mozaika
mozek
mozol
mramor
mravenec
mrkev
mrtvola
mrzet
mrzutost
mstitel
mudrc
muflon
mulat
mumie
munice
muset
mutace
muzeum
muzikant
myslivec
mzda
nabourat
nachytat
nadace
nadbytek
nadhoz
nadobro
nadpis
nahlas
nahnat
nahodile
nahradit
naivita
najednou
najisto
najmout
naklonit
nakonec
nakrmit
nalevo
namazat
namluvit
nanometr
naoko
naopak
naostro
napadat
napevno
naplnit
napnout
naposled
naprosto
narodit
naruby
narychlo
nasadit
nasekat
naslepo
nastat
natolik
navenek
navrch
navzdory
nazvat
nebe
nechat
necky
nedaleko
nedbat
neduh
negace
nehet
nehoda
nejen
nejprve
neklid
nelibost
nemilost
nemoc
neochota
neonka
nepokoj
nerost
nerv
nesmysl
nesoulad
netvor
neuron
nevina
nezvykle
nicota
nijak
nikam
nikdy
nikl
nikterak
nitro
nocleh
nohavice
nominace
nora
norek
nositel
nosnost
nouze
noviny
novota
nozdra
nuda
nudle
nuget
nutit
nutnost
nutrie
nymfa
obal
obarvit
obava
obdiv
obec
obehnat
obejmout
obezita
obhajoba
obilnice
objasnit
objekt
obklopit
oblast
oblek
obliba
obloha
obluda
obnos
obohatit
obojek
obout
obrazec
obrna
obruba
obrys
obsah
obsluha
obstarat
obuv
obvaz
obvinit
obvod
obvykle
obyvatel
obzor
ocas
ocel
ocenit
ochladit
ochota
ochrana
ocitnout
odboj
odbyt
odchod
odcizit
odebrat
odeslat
odevzdat
odezva
odhadce
odhodit
odjet
odjinud
odkaz
odkoupit
odliv
odluka
odmlka
odolnost
odpad
odpis
odplout
odpor
odpustit
odpykat
odrazka
odsoudit
odstup
odsun
odtok
odtud
odvaha
odveta
odvolat
odvracet
odznak
ofina
ofsajd
ohlas
ohnisko
ohrada
ohrozit
ohryzek
okap
okenice
oklika
okno
okouzlit
okovy
okrasa
okres
okrsek
okruh
okupant
okurka
okusit
olejnina
olizovat
omak
omeleta
omezit
omladina
omlouvat
omluva
omyl
onehdy
opakovat
opasek
operace
opice
opilost
opisovat
opora
opozice
opravdu
oproti
orbital
orchestr
orgie
orlice
orloj
ortel
osada
oschnout
osika
osivo
oslava
oslepit
oslnit
oslovit
osnova
osoba
osolit
ospalec
osten
ostraha
ostuda
ostych
osvojit
oteplit
otisk
otop
otrhat
otrlost
otrok
otruby
otvor
ovanout
ovar
oves
ovlivnit
ovoce
oxid
ozdoba
pachatel
pacient
padouch
pahorek
pakt
palanda
palec
palivo
paluba
pamflet
pamlsek
panenka
panika
panna
panovat
panstvo
pantofle
paprika
parketa
parodie
parta
paruka
paryba
paseka
pasivita
pastelka
patent
patrona
pavouk
pazneht
pazourek
pecka
pedagog
pejsek
peklo
peloton
penalta
pendrek
penze
periskop
pero
pestrost
petarda
petice
petrolej
pevnina
pexeso
pianista
piha
pijavice
pikle
piknik
pilina
pilnost
pilulka
pinzeta
pipeta
pisatel
pistole
pitevna
pivnice
pivovar
placenta
plakat
plamen
planeta
plastika
platit
plavidlo
plaz
plech
plemeno
plenta
ples
pletivo
plevel
plivat
plnit
plno
plocha
plodina
plomba
plout
pluk
plyn
pobavit
pobyt
pochod
pocit
poctivec
podat
podcenit
podepsat
podhled
podivit
podklad
podmanit
podnik
podoba
podpora
podraz
podstata
podvod
podzim
poezie
pohanka
pohnutka
pohovor
pohroma
pohyb
pointa
pojistka
pojmout
pokazit
pokles
pokoj
pokrok
pokuta
pokyn
poledne
polibek
polknout
poloha
polynom
pomalu
pominout
pomlka
pomoc
pomsta
pomyslet
ponechat
ponorka
ponurost
popadat
popel
popisek
poplach
poprosit
popsat
popud
poradce
porce
porod
porucha
poryv
posadit
posed
posila
poskok
poslanec
posoudit
pospolu
postava
posudek
posyp
potah
potkan
potlesk
potomek
potrava
potupa
potvora
poukaz
pouto
pouzdro
povaha
povidla
povlak
povoz
povrch
povstat
povyk
povzdech
pozdrav
pozemek
poznatek
pozor
pozvat
pracovat
prahory
praktika
prales
praotec
praporek
prase
pravda
princip
prkno
probudit
procento
prodej
profese
prohra
projekt
prolomit
promile
pronikat
propad
prorok
prosba
proton
proutek
provaz
prskavka
prsten
prudkost
prut
prvek
prvohory
psanec
psovod
pstruh
ptactvo
puberta
puch
pudl
pukavec
puklina
pukrle
pult
pumpa
punc
pupen
pusa
pusinka
pustina
putovat
putyka
pyramida
pysk
pytel
racek
rachot
radiace
radnice
radon
raft
ragby
raketa
rakovina
rameno
rampouch
rande
rarach
rarita
rasovna
rastr
ratolest
razance
razidlo
reagovat
reakce
recept
redaktor
referent
reflex
rejnok
reklama
rekord
rekrut
rektor
reputace
revize
revma
revolver
rezerva
riskovat
riziko
robotika
rodokmen
rohovka
rokle
rokoko
romaneto
ropovod
ropucha
rorejs
rosol
rostlina
rotmistr
rotoped
rotunda
roubenka
roucho
roup
roura
rovina
rovnice
rozbor
rozchod
rozdat
rozeznat
rozhodce
rozinka
rozjezd
rozkaz
rozloha
rozmar
rozpad
rozruch
rozsah
roztok
rozum
rozvod
rubrika
ruchadlo
rukavice
rukopis
ryba
rybolov
rychlost
rydlo
rypadlo
rytina
ryzost
sadista
sahat
sako
samec
samizdat
samota
sanitka
sardinka
sasanka
satelit
sazba
sazenice
sbor
schovat
sebranka
secese
sedadlo
sediment
sedlo
sehnat
sejmout
sekera
sekta
sekunda
sekvoje
semeno
seno
servis
sesadit
seshora
seskok
seslat
sestra
sesuv
sesypat
setba
setina
setkat
setnout
setrvat
sever
seznam
shoda
shrnout
sifon
silnice
sirka
sirotek
sirup
situace
skafandr
skalisko
skanzen
skaut
skeptik
skica
skladba
sklenice
sklo
skluz
skoba
skokan
skoro
skripta
skrz
skupina
skvost
skvrna
slabika
sladidlo
slanina
slast
slavnost
sledovat
slepec
sleva
slezina
slib
slina
sliznice
slon
sloupek
slovo
sluch
sluha
slunce
slupka
slza
smaragd
smetana
smilstvo
smlouva
smog
smrad
smrk
smrtka
smutek
smysl
snad
snaha
snob
sobota
socha
sodovka
sokol
sopka
sotva
souboj
soucit
soudce
souhlas
soulad
soumrak
souprava
soused
soutok
souviset
spalovna
spasitel
spis
splav
spodek
spojenec
spolu
sponzor
spornost
spousta
sprcha
spustit
sranda
sraz
srdce
srna
srnec
srovnat
srpen
srst
srub
stanice
starosta
statika
stavba
stehno
stezka
stodola
stolek
stopa
storno
stoupat
strach
stres
strhnout
strom
struna
studna
stupnice
stvol
styk
subjekt
subtropy
suchar
sudost
sukno
sundat
sunout
surikata
surovina
svah
svalstvo
svetr
svatba
svazek
svisle
svitek
svoboda
svodidlo
svorka
svrab
sykavka
sykot
synek
synovec
sypat
sypkost
syrovost
sysel
sytost
tabletka
tabule
tahoun
tajemno
tajfun
tajga
tajit
tajnost
taktika
tamhle
tampon
tancovat
tanec
tanker
tapeta
tavenina
tazatel
technika
tehdy
tekutina
telefon
temnota
tendence
tenista
tenor
teplota
tepna
teprve
terapie
termoska
textil
ticho
tiskopis
titulek
tkadlec
tkanina
tlapka
tleskat
tlukot
tlupa
tmel
toaleta
topinka
topol
torzo
touha
toulec
tradice
traktor
tramp
trasa
traverza
trefit
trest
trezor
trhavina
trhlina
trochu
trojice
troska
trouba
trpce
trpitel
trpkost
trubec
truchlit
truhlice
trus
trvat
tudy
tuhnout
tuhost
tundra
turista
turnaj
tuzemsko
tvaroh
tvorba
tvrdost
tvrz
tygr
tykev
ubohost
uboze
ubrat
ubrousek
ubrus
ubytovna
ucho
uctivost
udivit
uhradit
ujednat
ujistit
ujmout
ukazatel
uklidnit
uklonit
ukotvit
ukrojit
ulice
ulita
ulovit
umyvadlo
unavit
uniforma
uniknout
upadnout
uplatnit
uplynout
upoutat
upravit
uran
urazit
usednout
usilovat
usmrtit
usnadnit
usnout
usoudit
ustlat
ustrnout
utahovat
utkat
utlumit
utonout
utopenec
utrousit
uvalit
uvolnit
uvozovka
uzdravit
uzel
uzenina
uzlina
uznat
vagon
valcha
valoun
vana
vandal
vanilka
varan
varhany
varovat
vcelku
vchod
vdova
vedro
vegetace
vejce
velbloud
veletrh
velitel
velmoc
velryba
venkov
veranda
verze
veselka
veskrze
vesnice
vespodu
vesta
veterina
veverka
vibrace
vichr
videohra
vidina
vidle
vila
vinice
viset
vitalita
vize
vizitka
vjezd
vklad
vkus
vlajka
vlak
vlasec
vlevo
vlhkost
vliv
vlnovka
vloupat
vnucovat
vnuk
voda
vodivost
vodoznak
vodstvo
vojensky
vojna
vojsko
volant
volba
volit
volno
voskovka
vozidlo
vozovna
vpravo
vrabec
vracet
vrah
vrata
vrba
vrcholek
vrhat
vrstva
vrtule
vsadit
vstoupit
vstup
vtip
vybavit
vybrat
vychovat
vydat
vydra
vyfotit
vyhledat
vyhnout
vyhodit
vyhradit
vyhubit
vyjasnit
vyjet
vyjmout
vyklopit
vykonat
vylekat
vymazat
vymezit
vymizet
vymyslet
vynechat
vynikat
vynutit
vypadat
vyplatit
vypravit
vypustit
vyrazit
vyrovnat
vyrvat
vyslovit
vysoko
vystavit
vysunout
vysypat
vytasit
vytesat
vytratit
vyvinout
vyvolat
vyvrhel
vyzdobit
vyznat
vzadu
vzbudit
vzchopit
vzdor
vzduch
vzdychat
vzestup
vzhledem
vzkaz
vzlykat
vznik
vzorek
vzpoura
vztah
vztek
xylofon
zabrat
zabydlet
zachovat
zadarmo
zadusit
zafoukat
zahltit
zahodit
zahrada
zahynout
zajatec
zajet
zajistit
zaklepat
zakoupit
zalepit
zamezit
zamotat
zamyslet
zanechat
zanikat
zaplatit
zapojit
zapsat
zarazit
zastavit
zasunout
zatajit
zatemnit
zatknout
zaujmout
zavalit
zavelet
zavinit
zavolat
zavrtat
zazvonit
zbavit
zbrusu
zbudovat
zbytek
zdaleka
zdarma
zdatnost
zdivo
zdobit
zdroj
zdvih
zdymadlo
zelenina
zeman
zemina
zeptat
zezadu
zezdola
zhatit
zhltnout
zhluboka
zhotovit
zhruba
zima
zimnice
zjemnit
zklamat
zkoumat
zkratka
zkumavka
zlato
zlehka
zloba
zlom
zlost
zlozvyk
zmapovat
zmar
zmatek
zmije
zmizet
zmocnit
zmodrat
zmrzlina
zmutovat
znak
znalost
znamenat
znovu
zobrazit
zotavit
zoubek
zoufale
zplodit
zpomalit
zprava
zprostit
zprudka
zprvu
zrada
zranit
zrcadlo
zrnitost
zrno
zrovna
zrychlit
zrzavost
zticha
ztratit
zubovina
zubr
zvednout
zvenku
zvesela
zvon
zvrat
zvukovod
zvyk`;
const bip39WordListCzech = raw$7.split('\n');

/* eslint-disable max-lines */ const raw$6 = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`;
const bip39WordListEnglish = raw$6.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$5 = `abaisser
abandon
abdiquer
abeille
abolir
aborder
aboutir
aboyer
abrasif
abreuver
abriter
abroger
abrupt
absence
absolu
absurde
abusif
abyssal
académie
acajou
acarien
accabler
accepter
acclamer
accolade
accroche
accuser
acerbe
achat
acheter
aciduler
acier
acompte
acquérir
acronyme
acteur
actif
actuel
adepte
adéquat
adhésif
adjectif
adjuger
admettre
admirer
adopter
adorer
adoucir
adresse
adroit
adulte
adverbe
aérer
aéronef
affaire
affecter
affiche
affreux
affubler
agacer
agencer
agile
agiter
agrafer
agréable
agrume
aider
aiguille
ailier
aimable
aisance
ajouter
ajuster
alarmer
alchimie
alerte
algèbre
algue
aliéner
aliment
alléger
alliage
allouer
allumer
alourdir
alpaga
altesse
alvéole
amateur
ambigu
ambre
aménager
amertume
amidon
amiral
amorcer
amour
amovible
amphibie
ampleur
amusant
analyse
anaphore
anarchie
anatomie
ancien
anéantir
angle
angoisse
anguleux
animal
annexer
annonce
annuel
anodin
anomalie
anonyme
anormal
antenne
antidote
anxieux
apaiser
apéritif
aplanir
apologie
appareil
appeler
apporter
appuyer
aquarium
aqueduc
arbitre
arbuste
ardeur
ardoise
argent
arlequin
armature
armement
armoire
armure
arpenter
arracher
arriver
arroser
arsenic
artériel
article
aspect
asphalte
aspirer
assaut
asservir
assiette
associer
assurer
asticot
astre
astuce
atelier
atome
atrium
atroce
attaque
attentif
attirer
attraper
aubaine
auberge
audace
audible
augurer
aurore
automne
autruche
avaler
avancer
avarice
avenir
averse
aveugle
aviateur
avide
avion
aviser
avoine
avouer
avril
axial
axiome
badge
bafouer
bagage
baguette
baignade
balancer
balcon
baleine
balisage
bambin
bancaire
bandage
banlieue
bannière
banquier
barbier
baril
baron
barque
barrage
bassin
bastion
bataille
bateau
batterie
baudrier
bavarder
belette
bélier
belote
bénéfice
berceau
berger
berline
bermuda
besace
besogne
bétail
beurre
biberon
bicycle
bidule
bijou
bilan
bilingue
billard
binaire
biologie
biopsie
biotype
biscuit
bison
bistouri
bitume
bizarre
blafard
blague
blanchir
blessant
blinder
blond
bloquer
blouson
bobard
bobine
boire
boiser
bolide
bonbon
bondir
bonheur
bonifier
bonus
bordure
borne
botte
boucle
boueux
bougie
boulon
bouquin
bourse
boussole
boutique
boxeur
branche
brasier
brave
brebis
brèche
breuvage
bricoler
brigade
brillant
brioche
brique
brochure
broder
bronzer
brousse
broyeur
brume
brusque
brutal
bruyant
buffle
buisson
bulletin
bureau
burin
bustier
butiner
butoir
buvable
buvette
cabanon
cabine
cachette
cadeau
cadre
caféine
caillou
caisson
calculer
calepin
calibre
calmer
calomnie
calvaire
camarade
caméra
camion
campagne
canal
caneton
canon
cantine
canular
capable
caporal
caprice
capsule
capter
capuche
carabine
carbone
caresser
caribou
carnage
carotte
carreau
carton
cascade
casier
casque
cassure
causer
caution
cavalier
caverne
caviar
cédille
ceinture
céleste
cellule
cendrier
censurer
central
cercle
cérébral
cerise
cerner
cerveau
cesser
chagrin
chaise
chaleur
chambre
chance
chapitre
charbon
chasseur
chaton
chausson
chavirer
chemise
chenille
chéquier
chercher
cheval
chien
chiffre
chignon
chimère
chiot
chlorure
chocolat
choisir
chose
chouette
chrome
chute
cigare
cigogne
cimenter
cinéma
cintrer
circuler
cirer
cirque
citerne
citoyen
citron
civil
clairon
clameur
claquer
classe
clavier
client
cligner
climat
clivage
cloche
clonage
cloporte
cobalt
cobra
cocasse
cocotier
coder
codifier
coffre
cogner
cohésion
coiffer
coincer
colère
colibri
colline
colmater
colonel
combat
comédie
commande
compact
concert
conduire
confier
congeler
connoter
consonne
contact
convexe
copain
copie
corail
corbeau
cordage
corniche
corpus
correct
cortège
cosmique
costume
coton
coude
coupure
courage
couteau
couvrir
coyote
crabe
crainte
cravate
crayon
créature
créditer
crémeux
creuser
crevette
cribler
crier
cristal
critère
croire
croquer
crotale
crucial
cruel
crypter
cubique
cueillir
cuillère
cuisine
cuivre
culminer
cultiver
cumuler
cupide
curatif
curseur
cyanure
cycle
cylindre
cynique
daigner
damier
danger
danseur
dauphin
débattre
débiter
déborder
débrider
débutant
décaler
décembre
déchirer
décider
déclarer
décorer
décrire
décupler
dédale
déductif
déesse
défensif
défiler
défrayer
dégager
dégivrer
déglutir
dégrafer
déjeuner
délice
déloger
demander
demeurer
démolir
dénicher
dénouer
dentelle
dénuder
départ
dépenser
déphaser
déplacer
déposer
déranger
dérober
désastre
descente
désert
désigner
désobéir
dessiner
destrier
détacher
détester
détourer
détresse
devancer
devenir
deviner
devoir
diable
dialogue
diamant
dicter
différer
digérer
digital
digne
diluer
dimanche
diminuer
dioxyde
directif
diriger
discuter
disposer
dissiper
distance
divertir
diviser
docile
docteur
dogme
doigt
domaine
domicile
dompter
donateur
donjon
donner
dopamine
dortoir
dorure
dosage
doseur
dossier
dotation
douanier
double
douceur
douter
doyen
dragon
draper
dresser
dribbler
droiture
duperie
duplexe
durable
durcir
dynastie
éblouir
écarter
écharpe
échelle
éclairer
éclipse
éclore
écluse
école
économie
écorce
écouter
écraser
écrémer
écrivain
écrou
écume
écureuil
édifier
éduquer
effacer
effectif
effigie
effort
effrayer
effusion
égaliser
égarer
éjecter
élaborer
élargir
électron
élégant
éléphant
élève
éligible
élitisme
éloge
élucider
éluder
emballer
embellir
embryon
émeraude
émission
emmener
émotion
émouvoir
empereur
employer
emporter
emprise
émulsion
encadrer
enchère
enclave
encoche
endiguer
endosser
endroit
enduire
énergie
enfance
enfermer
enfouir
engager
engin
englober
énigme
enjamber
enjeu
enlever
ennemi
ennuyeux
enrichir
enrobage
enseigne
entasser
entendre
entier
entourer
entraver
énumérer
envahir
enviable
envoyer
enzyme
éolien
épaissir
épargne
épatant
épaule
épicerie
épidémie
épier
épilogue
épine
épisode
épitaphe
époque
épreuve
éprouver
épuisant
équerre
équipe
ériger
érosion
erreur
éruption
escalier
espadon
espèce
espiègle
espoir
esprit
esquiver
essayer
essence
essieu
essorer
estime
estomac
estrade
étagère
étaler
étanche
étatique
éteindre
étendoir
éternel
éthanol
éthique
ethnie
étirer
étoffer
étoile
étonnant
étourdir
étrange
étroit
étude
euphorie
évaluer
évasion
éventail
évidence
éviter
évolutif
évoquer
exact
exagérer
exaucer
exceller
excitant
exclusif
excuse
exécuter
exemple
exercer
exhaler
exhorter
exigence
exiler
exister
exotique
expédier
explorer
exposer
exprimer
exquis
extensif
extraire
exulter
fable
fabuleux
facette
facile
facture
faiblir
falaise
fameux
famille
farceur
farfelu
farine
farouche
fasciner
fatal
fatigue
faucon
fautif
faveur
favori
fébrile
féconder
fédérer
félin
femme
fémur
fendoir
féodal
fermer
féroce
ferveur
festival
feuille
feutre
février
fiasco
ficeler
fictif
fidèle
figure
filature
filetage
filière
filleul
filmer
filou
filtrer
financer
finir
fiole
firme
fissure
fixer
flairer
flamme
flasque
flatteur
fléau
flèche
fleur
flexion
flocon
flore
fluctuer
fluide
fluvial
folie
fonderie
fongible
fontaine
forcer
forgeron
formuler
fortune
fossile
foudre
fougère
fouiller
foulure
fourmi
fragile
fraise
franchir
frapper
frayeur
frégate
freiner
frelon
frémir
frénésie
frère
friable
friction
frisson
frivole
froid
fromage
frontal
frotter
fruit
fugitif
fuite
fureur
furieux
furtif
fusion
futur
gagner
galaxie
galerie
gambader
garantir
gardien
garnir
garrigue
gazelle
gazon
géant
gélatine
gélule
gendarme
général
génie
genou
gentil
géologie
géomètre
géranium
germe
gestuel
geyser
gibier
gicler
girafe
givre
glace
glaive
glisser
globe
gloire
glorieux
golfeur
gomme
gonfler
gorge
gorille
goudron
gouffre
goulot
goupille
gourmand
goutte
graduel
graffiti
graine
grand
grappin
gratuit
gravir
grenat
griffure
griller
grimper
grogner
gronder
grotte
groupe
gruger
grutier
gruyère
guépard
guerrier
guide
guimauve
guitare
gustatif
gymnaste
gyrostat
habitude
hachoir
halte
hameau
hangar
hanneton
haricot
harmonie
harpon
hasard
hélium
hématome
herbe
hérisson
hermine
héron
hésiter
heureux
hiberner
hibou
hilarant
histoire
hiver
homard
hommage
homogène
honneur
honorer
honteux
horde
horizon
horloge
hormone
horrible
houleux
housse
hublot
huileux
humain
humble
humide
humour
hurler
hydromel
hygiène
hymne
hypnose
idylle
ignorer
iguane
illicite
illusion
image
imbiber
imiter
immense
immobile
immuable
impact
impérial
implorer
imposer
imprimer
imputer
incarner
incendie
incident
incliner
incolore
indexer
indice
inductif
inédit
ineptie
inexact
infini
infliger
informer
infusion
ingérer
inhaler
inhiber
injecter
injure
innocent
inoculer
inonder
inscrire
insecte
insigne
insolite
inspirer
instinct
insulter
intact
intense
intime
intrigue
intuitif
inutile
invasion
inventer
inviter
invoquer
ironique
irradier
irréel
irriter
isoler
ivoire
ivresse
jaguar
jaillir
jambe
janvier
jardin
jauger
jaune
javelot
jetable
jeton
jeudi
jeunesse
joindre
joncher
jongler
joueur
jouissif
journal
jovial
joyau
joyeux
jubiler
jugement
junior
jupon
juriste
justice
juteux
juvénile
kayak
kimono
kiosque
label
labial
labourer
lacérer
lactose
lagune
laine
laisser
laitier
lambeau
lamelle
lampe
lanceur
langage
lanterne
lapin
largeur
larme
laurier
lavabo
lavoir
lecture
légal
léger
légume
lessive
lettre
levier
lexique
lézard
liasse
libérer
libre
licence
licorne
liège
lièvre
ligature
ligoter
ligue
limer
limite
limonade
limpide
linéaire
lingot
lionceau
liquide
lisière
lister
lithium
litige
littoral
livreur
logique
lointain
loisir
lombric
loterie
louer
lourd
loutre
louve
loyal
lubie
lucide
lucratif
lueur
lugubre
luisant
lumière
lunaire
lundi
luron
lutter
luxueux
machine
magasin
magenta
magique
maigre
maillon
maintien
mairie
maison
majorer
malaxer
maléfice
malheur
malice
mallette
mammouth
mandater
maniable
manquant
manteau
manuel
marathon
marbre
marchand
mardi
maritime
marqueur
marron
marteler
mascotte
massif
matériel
matière
matraque
maudire
maussade
mauve
maximal
méchant
méconnu
médaille
médecin
méditer
méduse
meilleur
mélange
mélodie
membre
mémoire
menacer
mener
menhir
mensonge
mentor
mercredi
mérite
merle
messager
mesure
métal
météore
méthode
métier
meuble
miauler
microbe
miette
mignon
migrer
milieu
million
mimique
mince
minéral
minimal
minorer
minute
miracle
miroiter
missile
mixte
mobile
moderne
moelleux
mondial
moniteur
monnaie
monotone
monstre
montagne
monument
moqueur
morceau
morsure
mortier
moteur
motif
mouche
moufle
moulin
mousson
mouton
mouvant
multiple
munition
muraille
murène
murmure
muscle
muséum
musicien
mutation
muter
mutuel
myriade
myrtille
mystère
mythique
nageur
nappe
narquois
narrer
natation
nation
nature
naufrage
nautique
navire
nébuleux
nectar
néfaste
négation
négliger
négocier
neige
nerveux
nettoyer
neurone
neutron
neveu
niche
nickel
nitrate
niveau
noble
nocif
nocturne
noirceur
noisette
nomade
nombreux
nommer
normatif
notable
notifier
notoire
nourrir
nouveau
novateur
novembre
novice
nuage
nuancer
nuire
nuisible
numéro
nuptial
nuque
nutritif
obéir
objectif
obliger
obscur
observer
obstacle
obtenir
obturer
occasion
occuper
océan
octobre
octroyer
octupler
oculaire
odeur
odorant
offenser
officier
offrir
ogive
oiseau
oisillon
olfactif
olivier
ombrage
omettre
onctueux
onduler
onéreux
onirique
opale
opaque
opérer
opinion
opportun
opprimer
opter
optique
orageux
orange
orbite
ordonner
oreille
organe
orgueil
orifice
ornement
orque
ortie
osciller
osmose
ossature
otarie
ouragan
ourson
outil
outrager
ouvrage
ovation
oxyde
oxygène
ozone
paisible
palace
palmarès
palourde
palper
panache
panda
pangolin
paniquer
panneau
panorama
pantalon
papaye
papier
papoter
papyrus
paradoxe
parcelle
paresse
parfumer
parler
parole
parrain
parsemer
partager
parure
parvenir
passion
pastèque
paternel
patience
patron
pavillon
pavoiser
payer
paysage
peigne
peintre
pelage
pélican
pelle
pelouse
peluche
pendule
pénétrer
pénible
pensif
pénurie
pépite
péplum
perdrix
perforer
période
permuter
perplexe
persil
perte
peser
pétale
petit
pétrir
peuple
pharaon
phobie
phoque
photon
phrase
physique
piano
pictural
pièce
pierre
pieuvre
pilote
pinceau
pipette
piquer
pirogue
piscine
piston
pivoter
pixel
pizza
placard
plafond
plaisir
planer
plaque
plastron
plateau
pleurer
plexus
pliage
plomb
plonger
pluie
plumage
pochette
poésie
poète
pointe
poirier
poisson
poivre
polaire
policier
pollen
polygone
pommade
pompier
ponctuel
pondérer
poney
portique
position
posséder
posture
potager
poteau
potion
pouce
poulain
poumon
pourpre
poussin
pouvoir
prairie
pratique
précieux
prédire
préfixe
prélude
prénom
présence
prétexte
prévoir
primitif
prince
prison
priver
problème
procéder
prodige
profond
progrès
proie
projeter
prologue
promener
propre
prospère
protéger
prouesse
proverbe
prudence
pruneau
psychose
public
puceron
puiser
pulpe
pulsar
punaise
punitif
pupitre
purifier
puzzle
pyramide
quasar
querelle
question
quiétude
quitter
quotient
racine
raconter
radieux
ragondin
raideur
raisin
ralentir
rallonge
ramasser
rapide
rasage
ratisser
ravager
ravin
rayonner
réactif
réagir
réaliser
réanimer
recevoir
réciter
réclamer
récolter
recruter
reculer
recycler
rédiger
redouter
refaire
réflexe
réformer
refrain
refuge
régalien
région
réglage
régulier
réitérer
rejeter
rejouer
relatif
relever
relief
remarque
remède
remise
remonter
remplir
remuer
renard
renfort
renifler
renoncer
rentrer
renvoi
replier
reporter
reprise
reptile
requin
réserve
résineux
résoudre
respect
rester
résultat
rétablir
retenir
réticule
retomber
retracer
réunion
réussir
revanche
revivre
révolte
révulsif
richesse
rideau
rieur
rigide
rigoler
rincer
riposter
risible
risque
rituel
rival
rivière
rocheux
romance
rompre
ronce
rondin
roseau
rosier
rotatif
rotor
rotule
rouge
rouille
rouleau
routine
royaume
ruban
rubis
ruche
ruelle
rugueux
ruiner
ruisseau
ruser
rustique
rythme
sabler
saboter
sabre
sacoche
safari
sagesse
saisir
salade
salive
salon
saluer
samedi
sanction
sanglier
sarcasme
sardine
saturer
saugrenu
saumon
sauter
sauvage
savant
savonner
scalpel
scandale
scélérat
scénario
sceptre
schéma
science
scinder
score
scrutin
sculpter
séance
sécable
sécher
secouer
sécréter
sédatif
séduire
seigneur
séjour
sélectif
semaine
sembler
semence
séminal
sénateur
sensible
sentence
séparer
séquence
serein
sergent
sérieux
serrure
sérum
service
sésame
sévir
sevrage
sextuple
sidéral
siècle
siéger
siffler
sigle
signal
silence
silicium
simple
sincère
sinistre
siphon
sirop
sismique
situer
skier
social
socle
sodium
soigneux
soldat
soleil
solitude
soluble
sombre
sommeil
somnoler
sonde
songeur
sonnette
sonore
sorcier
sortir
sosie
sottise
soucieux
soudure
souffle
soulever
soupape
source
soutirer
souvenir
spacieux
spatial
spécial
sphère
spiral
stable
station
sternum
stimulus
stipuler
strict
studieux
stupeur
styliste
sublime
substrat
subtil
subvenir
succès
sucre
suffixe
suggérer
suiveur
sulfate
superbe
supplier
surface
suricate
surmener
surprise
sursaut
survie
suspect
syllabe
symbole
symétrie
synapse
syntaxe
système
tabac
tablier
tactile
tailler
talent
talisman
talonner
tambour
tamiser
tangible
tapis
taquiner
tarder
tarif
tartine
tasse
tatami
tatouage
taupe
taureau
taxer
témoin
temporel
tenaille
tendre
teneur
tenir
tension
terminer
terne
terrible
tétine
texte
thème
théorie
thérapie
thorax
tibia
tiède
timide
tirelire
tiroir
tissu
titane
titre
tituber
toboggan
tolérant
tomate
tonique
tonneau
toponyme
torche
tordre
tornade
torpille
torrent
torse
tortue
totem
toucher
tournage
tousser
toxine
traction
trafic
tragique
trahir
train
trancher
travail
trèfle
tremper
trésor
treuil
triage
tribunal
tricoter
trilogie
triomphe
tripler
triturer
trivial
trombone
tronc
tropical
troupeau
tuile
tulipe
tumulte
tunnel
turbine
tuteur
tutoyer
tuyau
tympan
typhon
typique
tyran
ubuesque
ultime
ultrason
unanime
unifier
union
unique
unitaire
univers
uranium
urbain
urticant
usage
usine
usuel
usure
utile
utopie
vacarme
vaccin
vagabond
vague
vaillant
vaincre
vaisseau
valable
valise
vallon
valve
vampire
vanille
vapeur
varier
vaseux
vassal
vaste
vecteur
vedette
végétal
véhicule
veinard
véloce
vendredi
vénérer
venger
venimeux
ventouse
verdure
vérin
vernir
verrou
verser
vertu
veston
vétéran
vétuste
vexant
vexer
viaduc
viande
victoire
vidange
vidéo
vignette
vigueur
vilain
village
vinaigre
violon
vipère
virement
virtuose
virus
visage
viseur
vision
visqueux
visuel
vital
vitesse
viticole
vitrine
vivace
vivipare
vocation
voguer
voile
voisin
voiture
volaille
volcan
voltiger
volume
vorace
vortex
voter
vouloir
voyage
voyelle
wagon
xénon
yacht
zèbre
zénith
zeste
zoologie`;
const bip39WordListFrench = raw$5.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$4 = `abaco
abbaglio
abbinato
abete
abisso
abolire
abrasivo
abrogato
accadere
accenno
accusato
acetone
achille
acido
acqua
acre
acrilico
acrobata
acuto
adagio
addebito
addome
adeguato
aderire
adipe
adottare
adulare
affabile
affetto
affisso
affranto
aforisma
afoso
africano
agave
agente
agevole
aggancio
agire
agitare
agonismo
agricolo
agrumeto
aguzzo
alabarda
alato
albatro
alberato
albo
albume
alce
alcolico
alettone
alfa
algebra
aliante
alibi
alimento
allagato
allegro
allievo
allodola
allusivo
almeno
alogeno
alpaca
alpestre
altalena
alterno
alticcio
altrove
alunno
alveolo
alzare
amalgama
amanita
amarena
ambito
ambrato
ameba
america
ametista
amico
ammasso
ammenda
ammirare
ammonito
amore
ampio
ampliare
amuleto
anacardo
anagrafe
analista
anarchia
anatra
anca
ancella
ancora
andare
andrea
anello
angelo
angolare
angusto
anima
annegare
annidato
anno
annuncio
anonimo
anticipo
anzi
apatico
apertura
apode
apparire
appetito
appoggio
approdo
appunto
aprile
arabica
arachide
aragosta
araldica
arancio
aratura
arazzo
arbitro
archivio
ardito
arenile
argento
argine
arguto
aria
armonia
arnese
arredato
arringa
arrosto
arsenico
arso
artefice
arzillo
asciutto
ascolto
asepsi
asettico
asfalto
asino
asola
aspirato
aspro
assaggio
asse
assoluto
assurdo
asta
astenuto
astice
astratto
atavico
ateismo
atomico
atono
attesa
attivare
attorno
attrito
attuale
ausilio
austria
autista
autonomo
autunno
avanzato
avere
avvenire
avviso
avvolgere
azione
azoto
azzimo
azzurro
babele
baccano
bacino
baco
badessa
badilata
bagnato
baita
balcone
baldo
balena
ballata
balzano
bambino
bandire
baraonda
barbaro
barca
baritono
barlume
barocco
basilico
basso
batosta
battuto
baule
bava
bavosa
becco
beffa
belgio
belva
benda
benevole
benigno
benzina
bere
berlina
beta
bibita
bici
bidone
bifido
biga
bilancia
bimbo
binocolo
biologo
bipede
bipolare
birbante
birra
biscotto
bisesto
bisnonno
bisonte
bisturi
bizzarro
blando
blatta
bollito
bonifico
bordo
bosco
botanico
bottino
bozzolo
braccio
bradipo
brama
branca
bravura
bretella
brevetto
brezza
briglia
brillante
brindare
broccolo
brodo
bronzina
brullo
bruno
bubbone
buca
budino
buffone
buio
bulbo
buono
burlone
burrasca
bussola
busta
cadetto
caduco
calamaro
calcolo
calesse
calibro
calmo
caloria
cambusa
camerata
camicia
cammino
camola
campale
canapa
candela
cane
canino
canotto
cantina
capace
capello
capitolo
capogiro
cappero
capra
capsula
carapace
carcassa
cardo
carisma
carovana
carretto
cartolina
casaccio
cascata
caserma
caso
cassone
castello
casuale
catasta
catena
catrame
cauto
cavillo
cedibile
cedrata
cefalo
celebre
cellulare
cena
cenone
centesimo
ceramica
cercare
certo
cerume
cervello
cesoia
cespo
ceto
chela
chiaro
chicca
chiedere
chimera
china
chirurgo
chitarra
ciao
ciclismo
cifrare
cigno
cilindro
ciottolo
circa
cirrosi
citrico
cittadino
ciuffo
civetta
civile
classico
clinica
cloro
cocco
codardo
codice
coerente
cognome
collare
colmato
colore
colposo
coltivato
colza
coma
cometa
commando
comodo
computer
comune
conciso
condurre
conferma
congelare
coniuge
connesso
conoscere
consumo
continuo
convegno
coperto
copione
coppia
copricapo
corazza
cordata
coricato
cornice
corolla
corpo
corredo
corsia
cortese
cosmico
costante
cottura
covato
cratere
cravatta
creato
credere
cremoso
crescita
creta
criceto
crinale
crisi
critico
croce
cronaca
crostata
cruciale
crusca
cucire
cuculo
cugino
cullato
cupola
curatore
cursore
curvo
cuscino
custode
dado
daino
dalmata
damerino
daniela
dannoso
danzare
datato
davanti
davvero
debutto
decennio
deciso
declino
decollo
decreto
dedicato
definito
deforme
degno
delegare
delfino
delirio
delta
demenza
denotato
dentro
deposito
derapata
derivare
deroga
descritto
deserto
desiderio
desumere
detersivo
devoto
diametro
dicembre
diedro
difeso
diffuso
digerire
digitale
diluvio
dinamico
dinnanzi
dipinto
diploma
dipolo
diradare
dire
dirotto
dirupo
disagio
discreto
disfare
disgelo
disposto
distanza
disumano
dito
divano
divelto
dividere
divorato
doblone
docente
doganale
dogma
dolce
domato
domenica
dominare
dondolo
dono
dormire
dote
dottore
dovuto
dozzina
drago
druido
dubbio
dubitare
ducale
duna
duomo
duplice
duraturo
ebano
eccesso
ecco
eclissi
economia
edera
edicola
edile
editoria
educare
egemonia
egli
egoismo
egregio
elaborato
elargire
elegante
elencato
eletto
elevare
elfico
elica
elmo
elsa
eluso
emanato
emblema
emesso
emiro
emotivo
emozione
empirico
emulo
endemico
enduro
energia
enfasi
enoteca
entrare
enzima
epatite
epilogo
episodio
epocale
eppure
equatore
erario
erba
erboso
erede
eremita
erigere
ermetico
eroe
erosivo
errante
esagono
esame
esanime
esaudire
esca
esempio
esercito
esibito
esigente
esistere
esito
esofago
esortato
esoso
espanso
espresso
essenza
esso
esteso
estimare
estonia
estroso
esultare
etilico
etnico
etrusco
etto
euclideo
europa
evaso
evidenza
evitato
evoluto
evviva
fabbrica
faccenda
fachiro
falco
famiglia
fanale
fanfara
fango
fantasma
fare
farfalla
farinoso
farmaco
fascia
fastoso
fasullo
faticare
fato
favoloso
febbre
fecola
fede
fegato
felpa
feltro
femmina
fendere
fenomeno
fermento
ferro
fertile
fessura
festivo
fetta
feudo
fiaba
fiducia
fifa
figurato
filo
finanza
finestra
finire
fiore
fiscale
fisico
fiume
flacone
flamenco
flebo
flemma
florido
fluente
fluoro
fobico
focaccia
focoso
foderato
foglio
folata
folclore
folgore
fondente
fonetico
fonia
fontana
forbito
forchetta
foresta
formica
fornaio
foro
fortezza
forzare
fosfato
fosso
fracasso
frana
frassino
fratello
freccetta
frenata
fresco
frigo
frollino
fronde
frugale
frutta
fucilata
fucsia
fuggente
fulmine
fulvo
fumante
fumetto
fumoso
fune
funzione
fuoco
furbo
furgone
furore
fuso
futile
gabbiano
gaffe
galateo
gallina
galoppo
gambero
gamma
garanzia
garbo
garofano
garzone
gasdotto
gasolio
gastrico
gatto
gaudio
gazebo
gazzella
geco
gelatina
gelso
gemello
gemmato
gene
genitore
gennaio
genotipo
gergo
ghepardo
ghiaccio
ghisa
giallo
gilda
ginepro
giocare
gioiello
giorno
giove
girato
girone
gittata
giudizio
giurato
giusto
globulo
glutine
gnomo
gobba
golf
gomito
gommone
gonfio
gonna
governo
gracile
grado
grafico
grammo
grande
grattare
gravoso
grazia
greca
gregge
grifone
grigio
grinza
grotta
gruppo
guadagno
guaio
guanto
guardare
gufo
guidare
ibernato
icona
identico
idillio
idolo
idra
idrico
idrogeno
igiene
ignaro
ignorato
ilare
illeso
illogico
illudere
imballo
imbevuto
imbocco
imbuto
immane
immerso
immolato
impacco
impeto
impiego
importo
impronta
inalare
inarcare
inattivo
incanto
incendio
inchino
incisivo
incluso
incontro
incrocio
incubo
indagine
india
indole
inedito
infatti
infilare
inflitto
ingaggio
ingegno
inglese
ingordo
ingrosso
innesco
inodore
inoltrare
inondato
insano
insetto
insieme
insonnia
insulina
intasato
intero
intonaco
intuito
inumidire
invalido
invece
invito
iperbole
ipnotico
ipotesi
ippica
iride
irlanda
ironico
irrigato
irrorare
isolato
isotopo
isterico
istituto
istrice
italia
iterare
labbro
labirinto
lacca
lacerato
lacrima
lacuna
laddove
lago
lampo
lancetta
lanterna
lardoso
larga
laringe
lastra
latenza
latino
lattuga
lavagna
lavoro
legale
leggero
lembo
lentezza
lenza
leone
lepre
lesivo
lessato
lesto
letterale
leva
levigato
libero
lido
lievito
lilla
limatura
limitare
limpido
lineare
lingua
liquido
lira
lirica
lisca
lite
litigio
livrea
locanda
lode
logica
lombare
londra
longevo
loquace
lorenzo
loto
lotteria
luce
lucidato
lumaca
luminoso
lungo
lupo
luppolo
lusinga
lusso
lutto
macabro
macchina
macero
macinato
madama
magico
maglia
magnete
magro
maiolica
malafede
malgrado
malinteso
malsano
malto
malumore
mana
mancia
mandorla
mangiare
manifesto
mannaro
manovra
mansarda
mantide
manubrio
mappa
maratona
marcire
maretta
marmo
marsupio
maschera
massaia
mastino
materasso
matricola
mattone
maturo
mazurca
meandro
meccanico
mecenate
medesimo
meditare
mega
melassa
melis
melodia
meninge
meno
mensola
mercurio
merenda
merlo
meschino
mese
messere
mestolo
metallo
metodo
mettere
miagolare
mica
micelio
michele
microbo
midollo
miele
migliore
milano
milite
mimosa
minerale
mini
minore
mirino
mirtillo
miscela
missiva
misto
misurare
mitezza
mitigare
mitra
mittente
mnemonico
modello
modifica
modulo
mogano
mogio
mole
molosso
monastero
monco
mondina
monetario
monile
monotono
monsone
montato
monviso
mora
mordere
morsicato
mostro
motivato
motosega
motto
movenza
movimento
mozzo
mucca
mucosa
muffa
mughetto
mugnaio
mulatto
mulinello
multiplo
mummia
munto
muovere
murale
musa
muscolo
musica
mutevole
muto
nababbo
nafta
nanometro
narciso
narice
narrato
nascere
nastrare
naturale
nautica
naviglio
nebulosa
necrosi
negativo
negozio
nemmeno
neofita
neretto
nervo
nessuno
nettuno
neutrale
neve
nevrotico
nicchia
ninfa
nitido
nobile
nocivo
nodo
nome
nomina
nordico
normale
norvegese
nostrano
notare
notizia
notturno
novella
nucleo
nulla
numero
nuovo
nutrire
nuvola
nuziale
oasi
obbedire
obbligo
obelisco
oblio
obolo
obsoleto
occasione
occhio
occidente
occorrere
occultare
ocra
oculato
odierno
odorare
offerta
offrire
offuscato
oggetto
oggi
ognuno
olandese
olfatto
oliato
oliva
ologramma
oltre
omaggio
ombelico
ombra
omega
omissione
ondoso
onere
onice
onnivoro
onorevole
onta
operato
opinione
opposto
oracolo
orafo
ordine
orecchino
orefice
orfano
organico
origine
orizzonte
orma
ormeggio
ornativo
orologio
orrendo
orribile
ortensia
ortica
orzata
orzo
osare
oscurare
osmosi
ospedale
ospite
ossa
ossidare
ostacolo
oste
otite
otre
ottagono
ottimo
ottobre
ovale
ovest
ovino
oviparo
ovocito
ovunque
ovviare
ozio
pacchetto
pace
pacifico
padella
padrone
paese
paga
pagina
palazzina
palesare
pallido
palo
palude
pandoro
pannello
paolo
paonazzo
paprica
parabola
parcella
parere
pargolo
pari
parlato
parola
partire
parvenza
parziale
passivo
pasticca
patacca
patologia
pattume
pavone
peccato
pedalare
pedonale
peggio
peloso
penare
pendice
penisola
pennuto
penombra
pensare
pentola
pepe
pepita
perbene
percorso
perdonato
perforare
pergamena
periodo
permesso
perno
perplesso
persuaso
pertugio
pervaso
pesatore
pesista
peso
pestifero
petalo
pettine
petulante
pezzo
piacere
pianta
piattino
piccino
picozza
piega
pietra
piffero
pigiama
pigolio
pigro
pila
pilifero
pillola
pilota
pimpante
pineta
pinna
pinolo
pioggia
piombo
piramide
piretico
pirite
pirolisi
pitone
pizzico
placebo
planare
plasma
platano
plenario
pochezza
poderoso
podismo
poesia
poggiare
polenta
poligono
pollice
polmonite
polpetta
polso
poltrona
polvere
pomice
pomodoro
ponte
popoloso
porfido
poroso
porpora
porre
portata
posa
positivo
possesso
postulato
potassio
potere
pranzo
prassi
pratica
precluso
predica
prefisso
pregiato
prelievo
premere
prenotare
preparato
presenza
pretesto
prevalso
prima
principe
privato
problema
procura
produrre
profumo
progetto
prolunga
promessa
pronome
proposta
proroga
proteso
prova
prudente
prugna
prurito
psiche
pubblico
pudica
pugilato
pugno
pulce
pulito
pulsante
puntare
pupazzo
pupilla
puro
quadro
qualcosa
quasi
querela
quota
raccolto
raddoppio
radicale
radunato
raffica
ragazzo
ragione
ragno
ramarro
ramingo
ramo
randagio
rantolare
rapato
rapina
rappreso
rasatura
raschiato
rasente
rassegna
rastrello
rata
ravveduto
reale
recepire
recinto
recluta
recondito
recupero
reddito
redimere
regalato
registro
regola
regresso
relazione
remare
remoto
renna
replica
reprimere
reputare
resa
residente
responso
restauro
rete
retina
retorica
rettifica
revocato
riassunto
ribadire
ribelle
ribrezzo
ricarica
ricco
ricevere
riciclato
ricordo
ricreduto
ridicolo
ridurre
rifasare
riflesso
riforma
rifugio
rigare
rigettato
righello
rilassato
rilevato
rimanere
rimbalzo
rimedio
rimorchio
rinascita
rincaro
rinforzo
rinnovo
rinomato
rinsavito
rintocco
rinuncia
rinvenire
riparato
ripetuto
ripieno
riportare
ripresa
ripulire
risata
rischio
riserva
risibile
riso
rispetto
ristoro
risultato
risvolto
ritardo
ritegno
ritmico
ritrovo
riunione
riva
riverso
rivincita
rivolto
rizoma
roba
robotico
robusto
roccia
roco
rodaggio
rodere
roditore
rogito
rollio
romantico
rompere
ronzio
rosolare
rospo
rotante
rotondo
rotula
rovescio
rubizzo
rubrica
ruga
rullino
rumine
rumoroso
ruolo
rupe
russare
rustico
sabato
sabbiare
sabotato
sagoma
salasso
saldatura
salgemma
salivare
salmone
salone
saltare
saluto
salvo
sapere
sapido
saporito
saraceno
sarcasmo
sarto
sassoso
satellite
satira
satollo
saturno
savana
savio
saziato
sbadiglio
sbalzo
sbancato
sbarra
sbattere
sbavare
sbendare
sbirciare
sbloccato
sbocciato
sbrinare
sbruffone
sbuffare
scabroso
scadenza
scala
scambiare
scandalo
scapola
scarso
scatenare
scavato
scelto
scenico
scettro
scheda
schiena
sciarpa
scienza
scindere
scippo
sciroppo
scivolo
sclerare
scodella
scolpito
scomparto
sconforto
scoprire
scorta
scossone
scozzese
scriba
scrollare
scrutinio
scuderia
scultore
scuola
scuro
scusare
sdebitare
sdoganare
seccatura
secondo
sedano
seggiola
segnalato
segregato
seguito
selciato
selettivo
sella
selvaggio
semaforo
sembrare
seme
seminato
sempre
senso
sentire
sepolto
sequenza
serata
serbato
sereno
serio
serpente
serraglio
servire
sestina
setola
settimana
sfacelo
sfaldare
sfamato
sfarzoso
sfaticato
sfera
sfida
sfilato
sfinge
sfocato
sfoderare
sfogo
sfoltire
sforzato
sfratto
sfruttato
sfuggito
sfumare
sfuso
sgabello
sgarbato
sgonfiare
sgorbio
sgrassato
sguardo
sibilo
siccome
sierra
sigla
signore
silenzio
sillaba
simbolo
simpatico
simulato
sinfonia
singolo
sinistro
sino
sintesi
sinusoide
sipario
sisma
sistole
situato
slitta
slogatura
sloveno
smarrito
smemorato
smentito
smeraldo
smilzo
smontare
smottato
smussato
snellire
snervato
snodo
sobbalzo
sobrio
soccorso
sociale
sodale
soffitto
sogno
soldato
solenne
solido
sollazzo
solo
solubile
solvente
somatico
somma
sonda
sonetto
sonnifero
sopire
soppeso
sopra
sorgere
sorpasso
sorriso
sorso
sorteggio
sorvolato
sospiro
sosta
sottile
spada
spalla
spargere
spatola
spavento
spazzola
specie
spedire
spegnere
spelatura
speranza
spessore
spettrale
spezzato
spia
spigoloso
spillato
spinoso
spirale
splendido
sportivo
sposo
spranga
sprecare
spronato
spruzzo
spuntino
squillo
sradicare
srotolato
stabile
stacco
staffa
stagnare
stampato
stantio
starnuto
stasera
statuto
stelo
steppa
sterzo
stiletto
stima
stirpe
stivale
stizzoso
stonato
storico
strappo
stregato
stridulo
strozzare
strutto
stuccare
stufo
stupendo
subentro
succoso
sudore
suggerito
sugo
sultano
suonare
superbo
supporto
surgelato
surrogato
sussurro
sutura
svagare
svedese
sveglio
svelare
svenuto
svezia
sviluppo
svista
svizzera
svolta
svuotare
tabacco
tabulato
tacciare
taciturno
tale
talismano
tampone
tannino
tara
tardivo
targato
tariffa
tarpare
tartaruga
tasto
tattico
taverna
tavolata
tazza
teca
tecnico
telefono
temerario
tempo
temuto
tendone
tenero
tensione
tentacolo
teorema
terme
terrazzo
terzetto
tesi
tesserato
testato
tetro
tettoia
tifare
tigella
timbro
tinto
tipico
tipografo
tiraggio
tiro
titanio
titolo
titubante
tizio
tizzone
toccare
tollerare
tolto
tombola
tomo
tonfo
tonsilla
topazio
topologia
toppa
torba
tornare
torrone
tortora
toscano
tossire
tostatura
totano
trabocco
trachea
trafila
tragedia
tralcio
tramonto
transito
trapano
trarre
trasloco
trattato
trave
treccia
tremolio
trespolo
tributo
tricheco
trifoglio
trillo
trincea
trio
tristezza
triturato
trivella
tromba
trono
troppo
trottola
trovare
truccato
tubatura
tuffato
tulipano
tumulto
tunisia
turbare
turchino
tuta
tutela
ubicato
uccello
uccisore
udire
uditivo
uffa
ufficio
uguale
ulisse
ultimato
umano
umile
umorismo
uncinetto
ungere
ungherese
unicorno
unificato
unisono
unitario
unte
uovo
upupa
uragano
urgenza
urlo
usanza
usato
uscito
usignolo
usuraio
utensile
utilizzo
utopia
vacante
vaccinato
vagabondo
vagliato
valanga
valgo
valico
valletta
valoroso
valutare
valvola
vampata
vangare
vanitoso
vano
vantaggio
vanvera
vapore
varano
varcato
variante
vasca
vedetta
vedova
veduto
vegetale
veicolo
velcro
velina
velluto
veloce
venato
vendemmia
vento
verace
verbale
vergogna
verifica
vero
verruca
verticale
vescica
vessillo
vestale
veterano
vetrina
vetusto
viandante
vibrante
vicenda
vichingo
vicinanza
vidimare
vigilia
vigneto
vigore
vile
villano
vimini
vincitore
viola
vipera
virgola
virologo
virulento
viscoso
visione
vispo
vissuto
visura
vita
vitello
vittima
vivanda
vivido
viziare
voce
voga
volatile
volere
volpe
voragine
vulcano
zampogna
zanna
zappato
zattera
zavorra
zefiro
zelante
zelo
zenzero
zerbino
zibetto
zinco
zircone
zitto
zolla
zotico
zucchero
zufolo
zulu
zuppa`;
const bip39WordListItalian = raw$4.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$3 = `あいこくしん
あいさつ
あいだ
あおぞら
あかちゃん
あきる
あけがた
あける
あこがれる
あさい
あさひ
あしあと
あじわう
あずかる
あずき
あそぶ
あたえる
あたためる
あたりまえ
あたる
あつい
あつかう
あっしゅく
あつまり
あつめる
あてな
あてはまる
あひる
あぶら
あぶる
あふれる
あまい
あまど
あまやかす
あまり
あみもの
あめりか
あやまる
あゆむ
あらいぐま
あらし
あらすじ
あらためる
あらゆる
あらわす
ありがとう
あわせる
あわてる
あんい
あんがい
あんこ
あんぜん
あんてい
あんない
あんまり
いいだす
いおん
いがい
いがく
いきおい
いきなり
いきもの
いきる
いくじ
いくぶん
いけばな
いけん
いこう
いこく
いこつ
いさましい
いさん
いしき
いじゅう
いじょう
いじわる
いずみ
いずれ
いせい
いせえび
いせかい
いせき
いぜん
いそうろう
いそがしい
いだい
いだく
いたずら
いたみ
いたりあ
いちおう
いちじ
いちど
いちば
いちぶ
いちりゅう
いつか
いっしゅん
いっせい
いっそう
いったん
いっち
いってい
いっぽう
いてざ
いてん
いどう
いとこ
いない
いなか
いねむり
いのち
いのる
いはつ
いばる
いはん
いびき
いひん
いふく
いへん
いほう
いみん
いもうと
いもたれ
いもり
いやがる
いやす
いよかん
いよく
いらい
いらすと
いりぐち
いりょう
いれい
いれもの
いれる
いろえんぴつ
いわい
いわう
いわかん
いわば
いわゆる
いんげんまめ
いんさつ
いんしょう
いんよう
うえき
うえる
うおざ
うがい
うかぶ
うかべる
うきわ
うくらいな
うくれれ
うけたまわる
うけつけ
うけとる
うけもつ
うける
うごかす
うごく
うこん
うさぎ
うしなう
うしろがみ
うすい
うすぎ
うすぐらい
うすめる
うせつ
うちあわせ
うちがわ
うちき
うちゅう
うっかり
うつくしい
うったえる
うつる
うどん
うなぎ
うなじ
うなずく
うなる
うねる
うのう
うぶげ
うぶごえ
うまれる
うめる
うもう
うやまう
うよく
うらがえす
うらぐち
うらない
うりあげ
うりきれ
うるさい
うれしい
うれゆき
うれる
うろこ
うわき
うわさ
うんこう
うんちん
うんてん
うんどう
えいえん
えいが
えいきょう
えいご
えいせい
えいぶん
えいよう
えいわ
えおり
えがお
えがく
えきたい
えくせる
えしゃく
えすて
えつらん
えのぐ
えほうまき
えほん
えまき
えもじ
えもの
えらい
えらぶ
えりあ
えんえん
えんかい
えんぎ
えんげき
えんしゅう
えんぜつ
えんそく
えんちょう
えんとつ
おいかける
おいこす
おいしい
おいつく
おうえん
おうさま
おうじ
おうせつ
おうたい
おうふく
おうべい
おうよう
おえる
おおい
おおう
おおどおり
おおや
おおよそ
おかえり
おかず
おがむ
おかわり
おぎなう
おきる
おくさま
おくじょう
おくりがな
おくる
おくれる
おこす
おこなう
おこる
おさえる
おさない
おさめる
おしいれ
おしえる
おじぎ
おじさん
おしゃれ
おそらく
おそわる
おたがい
おたく
おだやか
おちつく
おっと
おつり
おでかけ
おとしもの
おとなしい
おどり
おどろかす
おばさん
おまいり
おめでとう
おもいで
おもう
おもたい
おもちゃ
おやつ
おやゆび
およぼす
おらんだ
おろす
おんがく
おんけい
おんしゃ
おんせん
おんだん
おんちゅう
おんどけい
かあつ
かいが
がいき
がいけん
がいこう
かいさつ
かいしゃ
かいすいよく
かいぜん
かいぞうど
かいつう
かいてん
かいとう
かいふく
がいへき
かいほう
かいよう
がいらい
かいわ
かえる
かおり
かかえる
かがく
かがし
かがみ
かくご
かくとく
かざる
がぞう
かたい
かたち
がちょう
がっきゅう
がっこう
がっさん
がっしょう
かなざわし
かのう
がはく
かぶか
かほう
かほご
かまう
かまぼこ
かめれおん
かゆい
かようび
からい
かるい
かろう
かわく
かわら
がんか
かんけい
かんこう
かんしゃ
かんそう
かんたん
かんち
がんばる
きあい
きあつ
きいろ
ぎいん
きうい
きうん
きえる
きおう
きおく
きおち
きおん
きかい
きかく
きかんしゃ
ききて
きくばり
きくらげ
きけんせい
きこう
きこえる
きこく
きさい
きさく
きさま
きさらぎ
ぎじかがく
ぎしき
ぎじたいけん
ぎじにってい
ぎじゅつしゃ
きすう
きせい
きせき
きせつ
きそう
きぞく
きぞん
きたえる
きちょう
きつえん
ぎっちり
きつつき
きつね
きてい
きどう
きどく
きない
きなが
きなこ
きぬごし
きねん
きのう
きのした
きはく
きびしい
きひん
きふく
きぶん
きぼう
きほん
きまる
きみつ
きむずかしい
きめる
きもだめし
きもち
きもの
きゃく
きやく
ぎゅうにく
きよう
きょうりゅう
きらい
きらく
きりん
きれい
きれつ
きろく
ぎろん
きわめる
ぎんいろ
きんかくじ
きんじょ
きんようび
ぐあい
くいず
くうかん
くうき
くうぐん
くうこう
ぐうせい
くうそう
ぐうたら
くうふく
くうぼ
くかん
くきょう
くげん
ぐこう
くさい
くさき
くさばな
くさる
くしゃみ
くしょう
くすのき
くすりゆび
くせげ
くせん
ぐたいてき
くださる
くたびれる
くちこみ
くちさき
くつした
ぐっすり
くつろぐ
くとうてん
くどく
くなん
くねくね
くのう
くふう
くみあわせ
くみたてる
くめる
くやくしょ
くらす
くらべる
くるま
くれる
くろう
くわしい
ぐんかん
ぐんしょく
ぐんたい
ぐんて
けあな
けいかく
けいけん
けいこ
けいさつ
げいじゅつ
けいたい
げいのうじん
けいれき
けいろ
けおとす
けおりもの
げきか
げきげん
げきだん
げきちん
げきとつ
げきは
げきやく
げこう
げこくじょう
げざい
けさき
げざん
けしき
けしごむ
けしょう
げすと
けたば
けちゃっぷ
けちらす
けつあつ
けつい
けつえき
けっこん
けつじょ
けっせき
けってい
けつまつ
げつようび
げつれい
けつろん
げどく
けとばす
けとる
けなげ
けなす
けなみ
けぬき
げねつ
けねん
けはい
げひん
けぶかい
げぼく
けまり
けみかる
けむし
けむり
けもの
けらい
けろけろ
けわしい
けんい
けんえつ
けんお
けんか
げんき
けんげん
けんこう
けんさく
けんしゅう
けんすう
げんそう
けんちく
けんてい
けんとう
けんない
けんにん
げんぶつ
けんま
けんみん
けんめい
けんらん
けんり
こあくま
こいぬ
こいびと
ごうい
こうえん
こうおん
こうかん
ごうきゅう
ごうけい
こうこう
こうさい
こうじ
こうすい
ごうせい
こうそく
こうたい
こうちゃ
こうつう
こうてい
こうどう
こうない
こうはい
ごうほう
ごうまん
こうもく
こうりつ
こえる
こおり
ごかい
ごがつ
ごかん
こくご
こくさい
こくとう
こくない
こくはく
こぐま
こけい
こける
ここのか
こころ
こさめ
こしつ
こすう
こせい
こせき
こぜん
こそだて
こたい
こたえる
こたつ
こちょう
こっか
こつこつ
こつばん
こつぶ
こてい
こてん
ことがら
ことし
ことば
ことり
こなごな
こねこね
このまま
このみ
このよ
ごはん
こひつじ
こふう
こふん
こぼれる
ごまあぶら
こまかい
ごますり
こまつな
こまる
こむぎこ
こもじ
こもち
こもの
こもん
こやく
こやま
こゆう
こゆび
こよい
こよう
こりる
これくしょん
ころっけ
こわもて
こわれる
こんいん
こんかい
こんき
こんしゅう
こんすい
こんだて
こんとん
こんなん
こんびに
こんぽん
こんまけ
こんや
こんれい
こんわく
ざいえき
さいかい
さいきん
ざいげん
ざいこ
さいしょ
さいせい
ざいたく
ざいちゅう
さいてき
ざいりょう
さうな
さかいし
さがす
さかな
さかみち
さがる
さぎょう
さくし
さくひん
さくら
さこく
さこつ
さずかる
ざせき
さたん
さつえい
ざつおん
ざっか
ざつがく
さっきょく
ざっし
さつじん
ざっそう
さつたば
さつまいも
さてい
さといも
さとう
さとおや
さとし
さとる
さのう
さばく
さびしい
さべつ
さほう
さほど
さます
さみしい
さみだれ
さむけ
さめる
さやえんどう
さゆう
さよう
さよく
さらだ
ざるそば
さわやか
さわる
さんいん
さんか
さんきゃく
さんこう
さんさい
ざんしょ
さんすう
さんせい
さんそ
さんち
さんま
さんみ
さんらん
しあい
しあげ
しあさって
しあわせ
しいく
しいん
しうち
しえい
しおけ
しかい
しかく
じかん
しごと
しすう
じだい
したうけ
したぎ
したて
したみ
しちょう
しちりん
しっかり
しつじ
しつもん
してい
してき
してつ
じてん
じどう
しなぎれ
しなもの
しなん
しねま
しねん
しのぐ
しのぶ
しはい
しばかり
しはつ
しはらい
しはん
しひょう
しふく
じぶん
しへい
しほう
しほん
しまう
しまる
しみん
しむける
じむしょ
しめい
しめる
しもん
しゃいん
しゃうん
しゃおん
じゃがいも
しやくしょ
しゃくほう
しゃけん
しゃこ
しゃざい
しゃしん
しゃせん
しゃそう
しゃたい
しゃちょう
しゃっきん
じゃま
しゃりん
しゃれい
じゆう
じゅうしょ
しゅくはく
じゅしん
しゅっせき
しゅみ
しゅらば
じゅんばん
しょうかい
しょくたく
しょっけん
しょどう
しょもつ
しらせる
しらべる
しんか
しんこう
じんじゃ
しんせいじ
しんちく
しんりん
すあげ
すあし
すあな
ずあん
すいえい
すいか
すいとう
ずいぶん
すいようび
すうがく
すうじつ
すうせん
すおどり
すきま
すくう
すくない
すける
すごい
すこし
ずさん
すずしい
すすむ
すすめる
すっかり
ずっしり
ずっと
すてき
すてる
すねる
すのこ
すはだ
すばらしい
ずひょう
ずぶぬれ
すぶり
すふれ
すべて
すべる
ずほう
すぼん
すまい
すめし
すもう
すやき
すらすら
するめ
すれちがう
すろっと
すわる
すんぜん
すんぽう
せあぶら
せいかつ
せいげん
せいじ
せいよう
せおう
せかいかん
せきにん
せきむ
せきゆ
せきらんうん
せけん
せこう
せすじ
せたい
せたけ
せっかく
せっきゃく
ぜっく
せっけん
せっこつ
せっさたくま
せつぞく
せつだん
せつでん
せっぱん
せつび
せつぶん
せつめい
せつりつ
せなか
せのび
せはば
せびろ
せぼね
せまい
せまる
せめる
せもたれ
せりふ
ぜんあく
せんい
せんえい
せんか
せんきょ
せんく
せんげん
ぜんご
せんさい
せんしゅ
せんすい
せんせい
せんぞ
せんたく
せんちょう
せんてい
せんとう
せんぬき
せんねん
せんぱい
ぜんぶ
ぜんぽう
せんむ
せんめんじょ
せんもん
せんやく
せんゆう
せんよう
ぜんら
ぜんりゃく
せんれい
せんろ
そあく
そいとげる
そいね
そうがんきょう
そうき
そうご
そうしん
そうだん
そうなん
そうび
そうめん
そうり
そえもの
そえん
そがい
そげき
そこう
そこそこ
そざい
そしな
そせい
そせん
そそぐ
そだてる
そつう
そつえん
そっかん
そつぎょう
そっけつ
そっこう
そっせん
そっと
そとがわ
そとづら
そなえる
そなた
そふぼ
そぼく
そぼろ
そまつ
そまる
そむく
そむりえ
そめる
そもそも
そよかぜ
そらまめ
そろう
そんかい
そんけい
そんざい
そんしつ
そんぞく
そんちょう
ぞんび
ぞんぶん
そんみん
たあい
たいいん
たいうん
たいえき
たいおう
だいがく
たいき
たいぐう
たいけん
たいこ
たいざい
だいじょうぶ
だいすき
たいせつ
たいそう
だいたい
たいちょう
たいてい
だいどころ
たいない
たいねつ
たいのう
たいはん
だいひょう
たいふう
たいへん
たいほ
たいまつばな
たいみんぐ
たいむ
たいめん
たいやき
たいよう
たいら
たいりょく
たいる
たいわん
たうえ
たえる
たおす
たおる
たおれる
たかい
たかね
たきび
たくさん
たこく
たこやき
たさい
たしざん
だじゃれ
たすける
たずさわる
たそがれ
たたかう
たたく
ただしい
たたみ
たちばな
だっかい
だっきゃく
だっこ
だっしゅつ
だったい
たてる
たとえる
たなばた
たにん
たぬき
たのしみ
たはつ
たぶん
たべる
たぼう
たまご
たまる
だむる
ためいき
ためす
ためる
たもつ
たやすい
たよる
たらす
たりきほんがん
たりょう
たりる
たると
たれる
たれんと
たろっと
たわむれる
だんあつ
たんい
たんおん
たんか
たんき
たんけん
たんご
たんさん
たんじょうび
だんせい
たんそく
たんたい
だんち
たんてい
たんとう
だんな
たんにん
だんねつ
たんのう
たんぴん
だんぼう
たんまつ
たんめい
だんれつ
だんろ
だんわ
ちあい
ちあん
ちいき
ちいさい
ちえん
ちかい
ちから
ちきゅう
ちきん
ちけいず
ちけん
ちこく
ちさい
ちしき
ちしりょう
ちせい
ちそう
ちたい
ちたん
ちちおや
ちつじょ
ちてき
ちてん
ちぬき
ちぬり
ちのう
ちひょう
ちへいせん
ちほう
ちまた
ちみつ
ちみどろ
ちめいど
ちゃんこなべ
ちゅうい
ちゆりょく
ちょうし
ちょさくけん
ちらし
ちらみ
ちりがみ
ちりょう
ちるど
ちわわ
ちんたい
ちんもく
ついか
ついたち
つうか
つうじょう
つうはん
つうわ
つかう
つかれる
つくね
つくる
つけね
つける
つごう
つたえる
つづく
つつじ
つつむ
つとめる
つながる
つなみ
つねづね
つのる
つぶす
つまらない
つまる
つみき
つめたい
つもり
つもる
つよい
つるぼ
つるみく
つわもの
つわり
てあし
てあて
てあみ
ていおん
ていか
ていき
ていけい
ていこく
ていさつ
ていし
ていせい
ていたい
ていど
ていねい
ていひょう
ていへん
ていぼう
てうち
ておくれ
てきとう
てくび
でこぼこ
てさぎょう
てさげ
てすり
てそう
てちがい
てちょう
てつがく
てつづき
でっぱ
てつぼう
てつや
でぬかえ
てぬき
てぬぐい
てのひら
てはい
てぶくろ
てふだ
てほどき
てほん
てまえ
てまきずし
てみじか
てみやげ
てらす
てれび
てわけ
てわたし
でんあつ
てんいん
てんかい
てんき
てんぐ
てんけん
てんごく
てんさい
てんし
てんすう
でんち
てんてき
てんとう
てんない
てんぷら
てんぼうだい
てんめつ
てんらんかい
でんりょく
でんわ
どあい
といれ
どうかん
とうきゅう
どうぐ
とうし
とうむぎ
とおい
とおか
とおく
とおす
とおる
とかい
とかす
ときおり
ときどき
とくい
とくしゅう
とくてん
とくに
とくべつ
とけい
とける
とこや
とさか
としょかん
とそう
とたん
とちゅう
とっきゅう
とっくん
とつぜん
とつにゅう
とどける
ととのえる
とない
となえる
となり
とのさま
とばす
どぶがわ
とほう
とまる
とめる
ともだち
ともる
どようび
とらえる
とんかつ
どんぶり
ないかく
ないこう
ないしょ
ないす
ないせん
ないそう
なおす
ながい
なくす
なげる
なこうど
なさけ
なたでここ
なっとう
なつやすみ
ななおし
なにごと
なにもの
なにわ
なのか
なふだ
なまいき
なまえ
なまみ
なみだ
なめらか
なめる
なやむ
ならう
ならび
ならぶ
なれる
なわとび
なわばり
にあう
にいがた
にうけ
におい
にかい
にがて
にきび
にくしみ
にくまん
にげる
にさんかたんそ
にしき
にせもの
にちじょう
にちようび
にっか
にっき
にっけい
にっこう
にっさん
にっしょく
にっすう
にっせき
にってい
になう
にほん
にまめ
にもつ
にやり
にゅういん
にりんしゃ
にわとり
にんい
にんか
にんき
にんげん
にんしき
にんずう
にんそう
にんたい
にんち
にんてい
にんにく
にんぷ
にんまり
にんむ
にんめい
にんよう
ぬいくぎ
ぬかす
ぬぐいとる
ぬぐう
ぬくもり
ぬすむ
ぬまえび
ぬめり
ぬらす
ぬんちゃく
ねあげ
ねいき
ねいる
ねいろ
ねぐせ
ねくたい
ねくら
ねこぜ
ねこむ
ねさげ
ねすごす
ねそべる
ねだん
ねつい
ねっしん
ねつぞう
ねったいぎょ
ねぶそく
ねふだ
ねぼう
ねほりはほり
ねまき
ねまわし
ねみみ
ねむい
ねむたい
ねもと
ねらう
ねわざ
ねんいり
ねんおし
ねんかん
ねんきん
ねんぐ
ねんざ
ねんし
ねんちゃく
ねんど
ねんぴ
ねんぶつ
ねんまつ
ねんりょう
ねんれい
のいず
のおづま
のがす
のきなみ
のこぎり
のこす
のこる
のせる
のぞく
のぞむ
のたまう
のちほど
のっく
のばす
のはら
のべる
のぼる
のみもの
のやま
のらいぬ
のらねこ
のりもの
のりゆき
のれん
のんき
ばあい
はあく
ばあさん
ばいか
ばいく
はいけん
はいご
はいしん
はいすい
はいせん
はいそう
はいち
ばいばい
はいれつ
はえる
はおる
はかい
ばかり
はかる
はくしゅ
はけん
はこぶ
はさみ
はさん
はしご
ばしょ
はしる
はせる
ぱそこん
はそん
はたん
はちみつ
はつおん
はっかく
はづき
はっきり
はっくつ
はっけん
はっこう
はっさん
はっしん
はったつ
はっちゅう
はってん
はっぴょう
はっぽう
はなす
はなび
はにかむ
はぶらし
はみがき
はむかう
はめつ
はやい
はやし
はらう
はろうぃん
はわい
はんい
はんえい
はんおん
はんかく
はんきょう
ばんぐみ
はんこ
はんしゃ
はんすう
はんだん
ぱんち
ぱんつ
はんてい
はんとし
はんのう
はんぱ
はんぶん
はんぺん
はんぼうき
はんめい
はんらん
はんろん
ひいき
ひうん
ひえる
ひかく
ひかり
ひかる
ひかん
ひくい
ひけつ
ひこうき
ひこく
ひさい
ひさしぶり
ひさん
びじゅつかん
ひしょ
ひそか
ひそむ
ひたむき
ひだり
ひたる
ひつぎ
ひっこし
ひっし
ひつじゅひん
ひっす
ひつぜん
ぴったり
ぴっちり
ひつよう
ひてい
ひとごみ
ひなまつり
ひなん
ひねる
ひはん
ひびく
ひひょう
ひほう
ひまわり
ひまん
ひみつ
ひめい
ひめじし
ひやけ
ひやす
ひよう
びょうき
ひらがな
ひらく
ひりつ
ひりょう
ひるま
ひるやすみ
ひれい
ひろい
ひろう
ひろき
ひろゆき
ひんかく
ひんけつ
ひんこん
ひんしゅ
ひんそう
ぴんち
ひんぱん
びんぼう
ふあん
ふいうち
ふうけい
ふうせん
ぷうたろう
ふうとう
ふうふ
ふえる
ふおん
ふかい
ふきん
ふくざつ
ふくぶくろ
ふこう
ふさい
ふしぎ
ふじみ
ふすま
ふせい
ふせぐ
ふそく
ぶたにく
ふたん
ふちょう
ふつう
ふつか
ふっかつ
ふっき
ふっこく
ぶどう
ふとる
ふとん
ふのう
ふはい
ふひょう
ふへん
ふまん
ふみん
ふめつ
ふめん
ふよう
ふりこ
ふりる
ふるい
ふんいき
ぶんがく
ぶんぐ
ふんしつ
ぶんせき
ふんそう
ぶんぽう
へいあん
へいおん
へいがい
へいき
へいげん
へいこう
へいさ
へいしゃ
へいせつ
へいそ
へいたく
へいてん
へいねつ
へいわ
へきが
へこむ
べにいろ
べにしょうが
へらす
へんかん
べんきょう
べんごし
へんさい
へんたい
べんり
ほあん
ほいく
ぼうぎょ
ほうこく
ほうそう
ほうほう
ほうもん
ほうりつ
ほえる
ほおん
ほかん
ほきょう
ぼきん
ほくろ
ほけつ
ほけん
ほこう
ほこる
ほしい
ほしつ
ほしゅ
ほしょう
ほせい
ほそい
ほそく
ほたて
ほたる
ぽちぶくろ
ほっきょく
ほっさ
ほったん
ほとんど
ほめる
ほんい
ほんき
ほんけ
ほんしつ
ほんやく
まいにち
まかい
まかせる
まがる
まける
まこと
まさつ
まじめ
ますく
まぜる
まつり
まとめ
まなぶ
まぬけ
まねく
まほう
まもる
まゆげ
まよう
まろやか
まわす
まわり
まわる
まんが
まんきつ
まんぞく
まんなか
みいら
みうち
みえる
みがく
みかた
みかん
みけん
みこん
みじかい
みすい
みすえる
みせる
みっか
みつかる
みつける
みてい
みとめる
みなと
みなみかさい
みねらる
みのう
みのがす
みほん
みもと
みやげ
みらい
みりょく
みわく
みんか
みんぞく
むいか
むえき
むえん
むかい
むかう
むかえ
むかし
むぎちゃ
むける
むげん
むさぼる
むしあつい
むしば
むじゅん
むしろ
むすう
むすこ
むすぶ
むすめ
むせる
むせん
むちゅう
むなしい
むのう
むやみ
むよう
むらさき
むりょう
むろん
めいあん
めいうん
めいえん
めいかく
めいきょく
めいさい
めいし
めいそう
めいぶつ
めいれい
めいわく
めぐまれる
めざす
めした
めずらしい
めだつ
めまい
めやす
めんきょ
めんせき
めんどう
もうしあげる
もうどうけん
もえる
もくし
もくてき
もくようび
もちろん
もどる
もらう
もんく
もんだい
やおや
やける
やさい
やさしい
やすい
やすたろう
やすみ
やせる
やそう
やたい
やちん
やっと
やっぱり
やぶる
やめる
ややこしい
やよい
やわらかい
ゆうき
ゆうびんきょく
ゆうべ
ゆうめい
ゆけつ
ゆしゅつ
ゆせん
ゆそう
ゆたか
ゆちゃく
ゆでる
ゆにゅう
ゆびわ
ゆらい
ゆれる
ようい
ようか
ようきゅう
ようじ
ようす
ようちえん
よかぜ
よかん
よきん
よくせい
よくぼう
よけい
よごれる
よさん
よしゅう
よそう
よそく
よっか
よてい
よどがわく
よねつ
よやく
よゆう
よろこぶ
よろしい
らいう
らくがき
らくご
らくさつ
らくだ
らしんばん
らせん
らぞく
らたい
らっか
られつ
りえき
りかい
りきさく
りきせつ
りくぐん
りくつ
りけん
りこう
りせい
りそう
りそく
りてん
りねん
りゆう
りゅうがく
りよう
りょうり
りょかん
りょくちゃ
りょこう
りりく
りれき
りろん
りんご
るいけい
るいさい
るいじ
るいせき
るすばん
るりがわら
れいかん
れいぎ
れいせい
れいぞうこ
れいとう
れいぼう
れきし
れきだい
れんあい
れんけい
れんこん
れんさい
れんしゅう
れんぞく
れんらく
ろうか
ろうご
ろうじん
ろうそく
ろくが
ろこつ
ろじうら
ろしゅつ
ろせん
ろてん
ろめん
ろれつ
ろんぎ
ろんぱ
ろんぶん
ろんり
わかす
わかめ
わかやま
わかれる
わしつ
わじまし
わすれもの
わらう
われる`;
const bip39WordListJapanese = raw$3.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$2 = `가격
가끔
가난
가능
가득
가르침
가뭄
가방
가상
가슴
가운데
가을
가이드
가입
가장
가정
가족
가죽
각오
각자
간격
간부
간섭
간장
간접
간판
갈등
갈비
갈색
갈증
감각
감기
감소
감수성
감자
감정
갑자기
강남
강당
강도
강력히
강변
강북
강사
강수량
강아지
강원도
강의
강제
강조
같이
개구리
개나리
개방
개별
개선
개성
개인
객관적
거실
거액
거울
거짓
거품
걱정
건강
건물
건설
건조
건축
걸음
검사
검토
게시판
게임
겨울
견해
결과
결국
결론
결석
결승
결심
결정
결혼
경계
경고
경기
경력
경복궁
경비
경상도
경영
경우
경쟁
경제
경주
경찰
경치
경향
경험
계곡
계단
계란
계산
계속
계약
계절
계층
계획
고객
고구려
고궁
고급
고등학생
고무신
고민
고양이
고장
고전
고집
고춧가루
고통
고향
곡식
골목
골짜기
골프
공간
공개
공격
공군
공급
공기
공동
공무원
공부
공사
공식
공업
공연
공원
공장
공짜
공책
공통
공포
공항
공휴일
과목
과일
과장
과정
과학
관객
관계
관광
관념
관람
관련
관리
관습
관심
관점
관찰
광경
광고
광장
광주
괴로움
굉장히
교과서
교문
교복
교실
교양
교육
교장
교직
교통
교환
교훈
구경
구름
구멍
구별
구분
구석
구성
구속
구역
구입
구청
구체적
국가
국기
국내
국립
국물
국민
국수
국어
국왕
국적
국제
국회
군대
군사
군인
궁극적
권리
권위
권투
귀국
귀신
규정
규칙
균형
그날
그냥
그늘
그러나
그룹
그릇
그림
그제서야
그토록
극복
극히
근거
근교
근래
근로
근무
근본
근원
근육
근처
글씨
글자
금강산
금고
금년
금메달
금액
금연
금요일
금지
긍정적
기간
기관
기념
기능
기독교
기둥
기록
기름
기법
기본
기분
기쁨
기숙사
기술
기억
기업
기온
기운
기원
기적
기준
기침
기혼
기획
긴급
긴장
길이
김밥
김치
김포공항
깍두기
깜빡
깨달음
깨소금
껍질
꼭대기
꽃잎
나들이
나란히
나머지
나물
나침반
나흘
낙엽
난방
날개
날씨
날짜
남녀
남대문
남매
남산
남자
남편
남학생
낭비
낱말
내년
내용
내일
냄비
냄새
냇물
냉동
냉면
냉방
냉장고
넥타이
넷째
노동
노란색
노력
노인
녹음
녹차
녹화
논리
논문
논쟁
놀이
농구
농담
농민
농부
농업
농장
농촌
높이
눈동자
눈물
눈썹
뉴욕
느낌
늑대
능동적
능력
다방
다양성
다음
다이어트
다행
단계
단골
단독
단맛
단순
단어
단위
단점
단체
단추
단편
단풍
달걀
달러
달력
달리
닭고기
담당
담배
담요
담임
답변
답장
당근
당분간
당연히
당장
대규모
대낮
대단히
대답
대도시
대략
대량
대륙
대문
대부분
대신
대응
대장
대전
대접
대중
대책
대출
대충
대통령
대학
대한민국
대합실
대형
덩어리
데이트
도대체
도덕
도둑
도망
도서관
도심
도움
도입
도자기
도저히
도전
도중
도착
독감
독립
독서
독일
독창적
동화책
뒷모습
뒷산
딸아이
마누라
마늘
마당
마라톤
마련
마무리
마사지
마약
마요네즈
마을
마음
마이크
마중
마지막
마찬가지
마찰
마흔
막걸리
막내
막상
만남
만두
만세
만약
만일
만점
만족
만화
많이
말기
말씀
말투
맘대로
망원경
매년
매달
매력
매번
매스컴
매일
매장
맥주
먹이
먼저
먼지
멀리
메일
며느리
며칠
면담
멸치
명단
명령
명예
명의
명절
명칭
명함
모금
모니터
모델
모든
모범
모습
모양
모임
모조리
모집
모퉁이
목걸이
목록
목사
목소리
목숨
목적
목표
몰래
몸매
몸무게
몸살
몸속
몸짓
몸통
몹시
무관심
무궁화
무더위
무덤
무릎
무슨
무엇
무역
무용
무조건
무지개
무척
문구
문득
문법
문서
문제
문학
문화
물가
물건
물결
물고기
물론
물리학
물음
물질
물체
미국
미디어
미사일
미술
미역
미용실
미움
미인
미팅
미혼
민간
민족
민주
믿음
밀가루
밀리미터
밑바닥
바가지
바구니
바나나
바늘
바닥
바닷가
바람
바이러스
바탕
박물관
박사
박수
반대
반드시
반말
반발
반성
반응
반장
반죽
반지
반찬
받침
발가락
발걸음
발견
발달
발레
발목
발바닥
발생
발음
발자국
발전
발톱
발표
밤하늘
밥그릇
밥맛
밥상
밥솥
방금
방면
방문
방바닥
방법
방송
방식
방안
방울
방지
방학
방해
방향
배경
배꼽
배달
배드민턴
백두산
백색
백성
백인
백제
백화점
버릇
버섯
버튼
번개
번역
번지
번호
벌금
벌레
벌써
범위
범인
범죄
법률
법원
법적
법칙
베이징
벨트
변경
변동
변명
변신
변호사
변화
별도
별명
별일
병실
병아리
병원
보관
보너스
보라색
보람
보름
보상
보안
보자기
보장
보전
보존
보통
보편적
보험
복도
복사
복숭아
복습
볶음
본격적
본래
본부
본사
본성
본인
본질
볼펜
봉사
봉지
봉투
부근
부끄러움
부담
부동산
부문
부분
부산
부상
부엌
부인
부작용
부장
부정
부족
부지런히
부친
부탁
부품
부회장
북부
북한
분노
분량
분리
분명
분석
분야
분위기
분필
분홍색
불고기
불과
불교
불꽃
불만
불법
불빛
불안
불이익
불행
브랜드
비극
비난
비닐
비둘기
비디오
비로소
비만
비명
비밀
비바람
비빔밥
비상
비용
비율
비중
비타민
비판
빌딩
빗물
빗방울
빗줄기
빛깔
빨간색
빨래
빨리
사건
사계절
사나이
사냥
사람
사랑
사립
사모님
사물
사방
사상
사생활
사설
사슴
사실
사업
사용
사월
사장
사전
사진
사촌
사춘기
사탕
사투리
사흘
산길
산부인과
산업
산책
살림
살인
살짝
삼계탕
삼국
삼십
삼월
삼촌
상관
상금
상대
상류
상반기
상상
상식
상업
상인
상자
상점
상처
상추
상태
상표
상품
상황
새벽
색깔
색연필
생각
생명
생물
생방송
생산
생선
생신
생일
생활
서랍
서른
서명
서민
서비스
서양
서울
서적
서점
서쪽
서클
석사
석유
선거
선물
선배
선생
선수
선원
선장
선전
선택
선풍기
설거지
설날
설렁탕
설명
설문
설사
설악산
설치
설탕
섭씨
성공
성당
성명
성별
성인
성장
성적
성질
성함
세금
세미나
세상
세월
세종대왕
세탁
센터
센티미터
셋째
소규모
소극적
소금
소나기
소년
소득
소망
소문
소설
소속
소아과
소용
소원
소음
소중히
소지품
소질
소풍
소형
속담
속도
속옷
손가락
손길
손녀
손님
손등
손목
손뼉
손실
손질
손톱
손해
솔직히
솜씨
송아지
송이
송편
쇠고기
쇼핑
수건
수년
수단
수돗물
수동적
수면
수명
수박
수상
수석
수술
수시로
수업
수염
수영
수입
수준
수집
수출
수컷
수필
수학
수험생
수화기
숙녀
숙소
숙제
순간
순서
순수
순식간
순위
숟가락
술병
술집
숫자
스님
스물
스스로
스승
스웨터
스위치
스케이트
스튜디오
스트레스
스포츠
슬쩍
슬픔
습관
습기
승객
승리
승부
승용차
승진
시각
시간
시골
시금치
시나리오
시댁
시리즈
시멘트
시민
시부모
시선
시설
시스템
시아버지
시어머니
시월
시인
시일
시작
시장
시절
시점
시중
시즌
시집
시청
시합
시험
식구
식기
식당
식량
식료품
식물
식빵
식사
식생활
식초
식탁
식품
신고
신규
신념
신문
신발
신비
신사
신세
신용
신제품
신청
신체
신화
실감
실내
실력
실례
실망
실수
실습
실시
실장
실정
실질적
실천
실체
실컷
실태
실패
실험
실현
심리
심부름
심사
심장
심정
심판
쌍둥이
씨름
씨앗
아가씨
아나운서
아드님
아들
아쉬움
아스팔트
아시아
아울러
아저씨
아줌마
아직
아침
아파트
아프리카
아픔
아홉
아흔
악기
악몽
악수
안개
안경
안과
안내
안녕
안동
안방
안부
안주
알루미늄
알코올
암시
암컷
압력
앞날
앞문
애인
애정
액수
앨범
야간
야단
야옹
약간
약국
약속
약수
약점
약품
약혼녀
양념
양력
양말
양배추
양주
양파
어둠
어려움
어른
어젯밤
어쨌든
어쩌다가
어쩐지
언니
언덕
언론
언어
얼굴
얼른
얼음
얼핏
엄마
업무
업종
업체
엉덩이
엉망
엉터리
엊그제
에너지
에어컨
엔진
여건
여고생
여관
여군
여권
여대생
여덟
여동생
여든
여론
여름
여섯
여성
여왕
여인
여전히
여직원
여학생
여행
역사
역시
역할
연결
연구
연극
연기
연락
연설
연세
연속
연습
연애
연예인
연인
연장
연주
연출
연필
연합
연휴
열기
열매
열쇠
열심히
열정
열차
열흘
염려
엽서
영국
영남
영상
영양
영역
영웅
영원히
영하
영향
영혼
영화
옆구리
옆방
옆집
예감
예금
예방
예산
예상
예선
예술
예습
예식장
예약
예전
예절
예정
예컨대
옛날
오늘
오락
오랫동안
오렌지
오로지
오른발
오븐
오십
오염
오월
오전
오직
오징어
오페라
오피스텔
오히려
옥상
옥수수
온갖
온라인
온몸
온종일
온통
올가을
올림픽
올해
옷차림
와이셔츠
와인
완성
완전
왕비
왕자
왜냐하면
왠지
외갓집
외국
외로움
외삼촌
외출
외침
외할머니
왼발
왼손
왼쪽
요금
요일
요즘
요청
용기
용서
용어
우산
우선
우승
우연히
우정
우체국
우편
운동
운명
운반
운전
운행
울산
울음
움직임
웃어른
웃음
워낙
원고
원래
원서
원숭이
원인
원장
원피스
월급
월드컵
월세
월요일
웨이터
위반
위법
위성
위원
위험
위협
윗사람
유난히
유럽
유명
유물
유산
유적
유치원
유학
유행
유형
육군
육상
육십
육체
은행
음력
음료
음반
음성
음식
음악
음주
의견
의논
의문
의복
의식
의심
의외로
의욕
의원
의학
이것
이곳
이념
이놈
이달
이대로
이동
이렇게
이력서
이론적
이름
이민
이발소
이별
이불
이빨
이상
이성
이슬
이야기
이용
이웃
이월
이윽고
이익
이전
이중
이튿날
이틀
이혼
인간
인격
인공
인구
인근
인기
인도
인류
인물
인생
인쇄
인연
인원
인재
인종
인천
인체
인터넷
인하
인형
일곱
일기
일단
일대
일등
일반
일본
일부
일상
일생
일손
일요일
일월
일정
일종
일주일
일찍
일체
일치
일행
일회용
임금
임무
입대
입력
입맛
입사
입술
입시
입원
입장
입학
자가용
자격
자극
자동
자랑
자부심
자식
자신
자연
자원
자율
자전거
자정
자존심
자판
작가
작년
작성
작업
작용
작은딸
작품
잔디
잔뜩
잔치
잘못
잠깐
잠수함
잠시
잠옷
잠자리
잡지
장관
장군
장기간
장래
장례
장르
장마
장면
장모
장미
장비
장사
장소
장식
장애인
장인
장점
장차
장학금
재능
재빨리
재산
재생
재작년
재정
재채기
재판
재학
재활용
저것
저고리
저곳
저녁
저런
저렇게
저번
저울
저절로
저축
적극
적당히
적성
적용
적응
전개
전공
전기
전달
전라도
전망
전문
전반
전부
전세
전시
전용
전자
전쟁
전주
전철
전체
전통
전혀
전후
절대
절망
절반
절약
절차
점검
점수
점심
점원
점점
점차
접근
접시
접촉
젓가락
정거장
정도
정류장
정리
정말
정면
정문
정반대
정보
정부
정비
정상
정성
정오
정원
정장
정지
정치
정확히
제공
제과점
제대로
제목
제발
제법
제삿날
제안
제일
제작
제주도
제출
제품
제한
조각
조건
조금
조깅
조명
조미료
조상
조선
조용히
조절
조정
조직
존댓말
존재
졸업
졸음
종교
종로
종류
종소리
종업원
종종
종합
좌석
죄인
주관적
주름
주말
주머니
주먹
주문
주민
주방
주변
주식
주인
주일
주장
주전자
주택
준비
줄거리
줄기
줄무늬
중간
중계방송
중국
중년
중단
중독
중반
중부
중세
중소기업
중순
중앙
중요
중학교
즉석
즉시
즐거움
증가
증거
증권
증상
증세
지각
지갑
지경
지극히
지금
지급
지능
지름길
지리산
지방
지붕
지식
지역
지우개
지원
지적
지점
지진
지출
직선
직업
직원
직장
진급
진동
진로
진료
진리
진짜
진찰
진출
진통
진행
질문
질병
질서
짐작
집단
집안
집중
짜증
찌꺼기
차남
차라리
차량
차림
차별
차선
차츰
착각
찬물
찬성
참가
참기름
참새
참석
참여
참외
참조
찻잔
창가
창고
창구
창문
창밖
창작
창조
채널
채점
책가방
책방
책상
책임
챔피언
처벌
처음
천국
천둥
천장
천재
천천히
철도
철저히
철학
첫날
첫째
청년
청바지
청소
청춘
체계
체력
체온
체육
체중
체험
초등학생
초반
초밥
초상화
초순
초여름
초원
초저녁
초점
초청
초콜릿
촛불
총각
총리
총장
촬영
최근
최상
최선
최신
최악
최종
추석
추억
추진
추천
추측
축구
축소
축제
축하
출근
출발
출산
출신
출연
출입
출장
출판
충격
충고
충돌
충분히
충청도
취업
취직
취향
치약
친구
친척
칠십
칠월
칠판
침대
침묵
침실
칫솔
칭찬
카메라
카운터
칼국수
캐릭터
캠퍼스
캠페인
커튼
컨디션
컬러
컴퓨터
코끼리
코미디
콘서트
콜라
콤플렉스
콩나물
쾌감
쿠데타
크림
큰길
큰딸
큰소리
큰아들
큰어머니
큰일
큰절
클래식
클럽
킬로
타입
타자기
탁구
탁자
탄생
태권도
태양
태풍
택시
탤런트
터널
터미널
테니스
테스트
테이블
텔레비전
토론
토마토
토요일
통계
통과
통로
통신
통역
통일
통장
통제
통증
통합
통화
퇴근
퇴원
퇴직금
튀김
트럭
특급
특별
특성
특수
특징
특히
튼튼히
티셔츠
파란색
파일
파출소
판결
판단
판매
판사
팔십
팔월
팝송
패션
팩스
팩시밀리
팬티
퍼센트
페인트
편견
편의
편지
편히
평가
평균
평생
평소
평양
평일
평화
포스터
포인트
포장
포함
표면
표정
표준
표현
품목
품질
풍경
풍속
풍습
프랑스
프린터
플라스틱
피곤
피망
피아노
필름
필수
필요
필자
필통
핑계
하느님
하늘
하드웨어
하룻밤
하반기
하숙집
하순
하여튼
하지만
하천
하품
하필
학과
학교
학급
학기
학년
학력
학번
학부모
학비
학생
학술
학습
학용품
학원
학위
학자
학점
한계
한글
한꺼번에
한낮
한눈
한동안
한때
한라산
한마디
한문
한번
한복
한식
한여름
한쪽
할머니
할아버지
할인
함께
함부로
합격
합리적
항공
항구
항상
항의
해결
해군
해답
해당
해물
해석
해설
해수욕장
해안
핵심
핸드백
햄버거
햇볕
햇살
행동
행복
행사
행운
행위
향기
향상
향수
허락
허용
헬기
현관
현금
현대
현상
현실
현장
현재
현지
혈액
협력
형부
형사
형수
형식
형제
형태
형편
혜택
호기심
호남
호랑이
호박
호텔
호흡
혹시
홀로
홈페이지
홍보
홍수
홍차
화면
화분
화살
화요일
화장
화학
확보
확인
확장
확정
환갑
환경
환영
환율
환자
활기
활동
활발히
활용
활짝
회견
회관
회복
회색
회원
회장
회전
횟수
횡단보도
효율적
후반
후춧가루
훈련
훨씬
휴식
휴일
흉내
흐름
흑백
흑인
흔적
흔히
흥미
흥분
희곡
희망
희생
흰색
힘껏`;
const bip39WordListKorean = raw$2.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw$1 = `abacate
abaixo
abalar
abater
abduzir
abelha
aberto
abismo
abotoar
abranger
abreviar
abrigar
abrupto
absinto
absoluto
absurdo
abutre
acabado
acalmar
acampar
acanhar
acaso
aceitar
acelerar
acenar
acervo
acessar
acetona
achatar
acidez
acima
acionado
acirrar
aclamar
aclive
acolhida
acomodar
acoplar
acordar
acumular
acusador
adaptar
adega
adentro
adepto
adequar
aderente
adesivo
adeus
adiante
aditivo
adjetivo
adjunto
admirar
adorar
adquirir
adubo
adverso
advogado
aeronave
afastar
aferir
afetivo
afinador
afivelar
aflito
afluente
afrontar
agachar
agarrar
agasalho
agenciar
agilizar
agiota
agitado
agora
agradar
agreste
agrupar
aguardar
agulha
ajoelhar
ajudar
ajustar
alameda
alarme
alastrar
alavanca
albergue
albino
alcatra
aldeia
alecrim
alegria
alertar
alface
alfinete
algum
alheio
aliar
alicate
alienar
alinhar
aliviar
almofada
alocar
alpiste
alterar
altitude
alucinar
alugar
aluno
alusivo
alvo
amaciar
amador
amarelo
amassar
ambas
ambiente
ameixa
amenizar
amido
amistoso
amizade
amolador
amontoar
amoroso
amostra
amparar
ampliar
ampola
anagrama
analisar
anarquia
anatomia
andaime
anel
anexo
angular
animar
anjo
anomalia
anotado
ansioso
anterior
anuidade
anunciar
anzol
apagador
apalpar
apanhado
apego
apelido
apertada
apesar
apetite
apito
aplauso
aplicada
apoio
apontar
aposta
aprendiz
aprovar
aquecer
arame
aranha
arara
arcada
ardente
areia
arejar
arenito
aresta
argiloso
argola
arma
arquivo
arraial
arrebate
arriscar
arroba
arrumar
arsenal
arterial
artigo
arvoredo
asfaltar
asilado
aspirar
assador
assinar
assoalho
assunto
astral
atacado
atadura
atalho
atarefar
atear
atender
aterro
ateu
atingir
atirador
ativo
atoleiro
atracar
atrevido
atriz
atual
atum
auditor
aumentar
aura
aurora
autismo
autoria
autuar
avaliar
avante
avaria
avental
avesso
aviador
avisar
avulso
axila
azarar
azedo
azeite
azulejo
babar
babosa
bacalhau
bacharel
bacia
bagagem
baiano
bailar
baioneta
bairro
baixista
bajular
baleia
baliza
balsa
banal
bandeira
banho
banir
banquete
barato
barbado
baronesa
barraca
barulho
baseado
bastante
batata
batedor
batida
batom
batucar
baunilha
beber
beijo
beirada
beisebol
beldade
beleza
belga
beliscar
bendito
bengala
benzer
berimbau
berlinda
berro
besouro
bexiga
bezerro
bico
bicudo
bienal
bifocal
bifurcar
bigorna
bilhete
bimestre
bimotor
biologia
biombo
biosfera
bipolar
birrento
biscoito
bisneto
bispo
bissexto
bitola
bizarro
blindado
bloco
bloquear
boato
bobagem
bocado
bocejo
bochecha
boicotar
bolada
boletim
bolha
bolo
bombeiro
bonde
boneco
bonita
borbulha
borda
boreal
borracha
bovino
boxeador
branco
brasa
braveza
breu
briga
brilho
brincar
broa
brochura
bronzear
broto
bruxo
bucha
budismo
bufar
bule
buraco
busca
busto
buzina
cabana
cabelo
cabide
cabo
cabrito
cacau
cacetada
cachorro
cacique
cadastro
cadeado
cafezal
caiaque
caipira
caixote
cajado
caju
calafrio
calcular
caldeira
calibrar
calmante
calota
camada
cambista
camisa
camomila
campanha
camuflar
canavial
cancelar
caneta
canguru
canhoto
canivete
canoa
cansado
cantar
canudo
capacho
capela
capinar
capotar
capricho
captador
capuz
caracol
carbono
cardeal
careca
carimbar
carneiro
carpete
carreira
cartaz
carvalho
casaco
casca
casebre
castelo
casulo
catarata
cativar
caule
causador
cautelar
cavalo
caverna
cebola
cedilha
cegonha
celebrar
celular
cenoura
censo
centeio
cercar
cerrado
certeiro
cerveja
cetim
cevada
chacota
chaleira
chamado
chapada
charme
chatice
chave
chefe
chegada
cheiro
cheque
chicote
chifre
chinelo
chocalho
chover
chumbo
chutar
chuva
cicatriz
ciclone
cidade
cidreira
ciente
cigana
cimento
cinto
cinza
ciranda
circuito
cirurgia
citar
clareza
clero
clicar
clone
clube
coado
coagir
cobaia
cobertor
cobrar
cocada
coelho
coentro
coeso
cogumelo
coibir
coifa
coiote
colar
coleira
colher
colidir
colmeia
colono
coluna
comando
combinar
comentar
comitiva
comover
complexo
comum
concha
condor
conectar
confuso
congelar
conhecer
conjugar
consumir
contrato
convite
cooperar
copeiro
copiador
copo
coquetel
coragem
cordial
corneta
coronha
corporal
correio
cortejo
coruja
corvo
cosseno
costela
cotonete
couro
couve
covil
cozinha
cratera
cravo
creche
credor
creme
crer
crespo
criada
criminal
crioulo
crise
criticar
crosta
crua
cruzeiro
cubano
cueca
cuidado
cujo
culatra
culminar
culpar
cultura
cumprir
cunhado
cupido
curativo
curral
cursar
curto
cuspir
custear
cutelo
damasco
datar
debater
debitar
deboche
debulhar
decalque
decimal
declive
decote
decretar
dedal
dedicado
deduzir
defesa
defumar
degelo
degrau
degustar
deitado
deixar
delator
delegado
delinear
delonga
demanda
demitir
demolido
dentista
depenado
depilar
depois
depressa
depurar
deriva
derramar
desafio
desbotar
descanso
desenho
desfiado
desgaste
desigual
deslize
desmamar
desova
despesa
destaque
desviar
detalhar
detentor
detonar
detrito
deusa
dever
devido
devotado
dezena
diagrama
dialeto
didata
difuso
digitar
dilatado
diluente
diminuir
dinastia
dinheiro
diocese
direto
discreta
disfarce
disparo
disquete
dissipar
distante
ditador
diurno
diverso
divisor
divulgar
dizer
dobrador
dolorido
domador
dominado
donativo
donzela
dormente
dorsal
dosagem
dourado
doutor
drenagem
drible
drogaria
duelar
duende
dueto
duplo
duquesa
durante
duvidoso
eclodir
ecoar
ecologia
edificar
edital
educado
efeito
efetivar
ejetar
elaborar
eleger
eleitor
elenco
elevador
eliminar
elogiar
embargo
embolado
embrulho
embutido
emenda
emergir
emissor
empatia
empenho
empinado
empolgar
emprego
empurrar
emulador
encaixe
encenado
enchente
encontro
endeusar
endossar
enfaixar
enfeite
enfim
engajado
engenho
englobar
engomado
engraxar
enguia
enjoar
enlatar
enquanto
enraizar
enrolado
enrugar
ensaio
enseada
ensino
ensopado
entanto
enteado
entidade
entortar
entrada
entulho
envergar
enviado
envolver
enxame
enxerto
enxofre
enxuto
epiderme
equipar
ereto
erguido
errata
erva
ervilha
esbanjar
esbelto
escama
escola
escrita
escuta
esfinge
esfolar
esfregar
esfumado
esgrima
esmalte
espanto
espelho
espiga
esponja
espreita
espumar
esquerda
estaca
esteira
esticar
estofado
estrela
estudo
esvaziar
etanol
etiqueta
euforia
europeu
evacuar
evaporar
evasivo
eventual
evidente
evoluir
exagero
exalar
examinar
exato
exausto
excesso
excitar
exclamar
executar
exemplo
exibir
exigente
exonerar
expandir
expelir
expirar
explanar
exposto
expresso
expulsar
externo
extinto
extrato
fabricar
fabuloso
faceta
facial
fada
fadiga
faixa
falar
falta
familiar
fandango
fanfarra
fantoche
fardado
farelo
farinha
farofa
farpa
fartura
fatia
fator
favorita
faxina
fazenda
fechado
feijoada
feirante
felino
feminino
fenda
feno
fera
feriado
ferrugem
ferver
festejar
fetal
feudal
fiapo
fibrose
ficar
ficheiro
figurado
fileira
filho
filme
filtrar
firmeza
fisgada
fissura
fita
fivela
fixador
fixo
flacidez
flamingo
flanela
flechada
flora
flutuar
fluxo
focal
focinho
fofocar
fogo
foguete
foice
folgado
folheto
forjar
formiga
forno
forte
fosco
fossa
fragata
fralda
frango
frasco
fraterno
freira
frente
fretar
frieza
friso
fritura
fronha
frustrar
fruteira
fugir
fulano
fuligem
fundar
fungo
funil
furador
furioso
futebol
gabarito
gabinete
gado
gaiato
gaiola
gaivota
galega
galho
galinha
galocha
ganhar
garagem
garfo
gargalo
garimpo
garoupa
garrafa
gasoduto
gasto
gata
gatilho
gaveta
gazela
gelado
geleia
gelo
gemada
gemer
gemido
generoso
gengiva
genial
genoma
genro
geologia
gerador
germinar
gesso
gestor
ginasta
gincana
gingado
girafa
girino
glacial
glicose
global
glorioso
goela
goiaba
golfe
golpear
gordura
gorjeta
gorro
gostoso
goteira
governar
gracejo
gradual
grafite
gralha
grampo
granada
gratuito
graveto
graxa
grego
grelhar
greve
grilo
grisalho
gritaria
grosso
grotesco
grudado
grunhido
gruta
guache
guarani
guaxinim
guerrear
guiar
guincho
guisado
gula
guloso
guru
habitar
harmonia
haste
haver
hectare
herdar
heresia
hesitar
hiato
hibernar
hidratar
hiena
hino
hipismo
hipnose
hipoteca
hoje
holofote
homem
honesto
honrado
hormonal
hospedar
humorado
iate
ideia
idoso
ignorado
igreja
iguana
ileso
ilha
iludido
iluminar
ilustrar
imagem
imediato
imenso
imersivo
iminente
imitador
imortal
impacto
impedir
implante
impor
imprensa
impune
imunizar
inalador
inapto
inativo
incenso
inchar
incidir
incluir
incolor
indeciso
indireto
indutor
ineficaz
inerente
infantil
infestar
infinito
inflamar
informal
infrator
ingerir
inibido
inicial
inimigo
injetar
inocente
inodoro
inovador
inox
inquieto
inscrito
inseto
insistir
inspetor
instalar
insulto
intacto
integral
intimar
intocado
intriga
invasor
inverno
invicto
invocar
iogurte
iraniano
ironizar
irreal
irritado
isca
isento
isolado
isqueiro
italiano
janeiro
jangada
janta
jararaca
jardim
jarro
jasmim
jato
javali
jazida
jejum
joaninha
joelhada
jogador
joia
jornal
jorrar
jovem
juba
judeu
judoca
juiz
julgador
julho
jurado
jurista
juro
justa
labareda
laboral
lacre
lactante
ladrilho
lagarta
lagoa
laje
lamber
lamentar
laminar
lampejo
lanche
lapidar
lapso
laranja
lareira
largura
lasanha
lastro
lateral
latido
lavanda
lavoura
lavrador
laxante
lazer
lealdade
lebre
legado
legendar
legista
leigo
leiloar
leitura
lembrete
leme
lenhador
lentilha
leoa
lesma
leste
letivo
letreiro
levar
leveza
levitar
liberal
libido
liderar
ligar
ligeiro
limitar
limoeiro
limpador
linda
linear
linhagem
liquidez
listagem
lisura
litoral
livro
lixa
lixeira
locador
locutor
lojista
lombo
lona
longe
lontra
lorde
lotado
loteria
loucura
lousa
louvar
luar
lucidez
lucro
luneta
lustre
lutador
luva
macaco
macete
machado
macio
madeira
madrinha
magnata
magreza
maior
mais
malandro
malha
malote
maluco
mamilo
mamoeiro
mamute
manada
mancha
mandato
manequim
manhoso
manivela
manobrar
mansa
manter
manusear
mapeado
maquinar
marcador
maresia
marfim
margem
marinho
marmita
maroto
marquise
marreco
martelo
marujo
mascote
masmorra
massagem
mastigar
matagal
materno
matinal
matutar
maxilar
medalha
medida
medusa
megafone
meiga
melancia
melhor
membro
memorial
menino
menos
mensagem
mental
merecer
mergulho
mesada
mesclar
mesmo
mesquita
mestre
metade
meteoro
metragem
mexer
mexicano
micro
migalha
migrar
milagre
milenar
milhar
mimado
minerar
minhoca
ministro
minoria
miolo
mirante
mirtilo
misturar
mocidade
moderno
modular
moeda
moer
moinho
moita
moldura
moleza
molho
molinete
molusco
montanha
moqueca
morango
morcego
mordomo
morena
mosaico
mosquete
mostarda
motel
motim
moto
motriz
muda
muito
mulata
mulher
multar
mundial
munido
muralha
murcho
muscular
museu
musical
nacional
nadador
naja
namoro
narina
narrado
nascer
nativa
natureza
navalha
navegar
navio
neblina
nebuloso
negativa
negociar
negrito
nervoso
neta
neural
nevasca
nevoeiro
ninar
ninho
nitidez
nivelar
nobreza
noite
noiva
nomear
nominal
nordeste
nortear
notar
noticiar
noturno
novelo
novilho
novo
nublado
nudez
numeral
nupcial
nutrir
nuvem
obcecado
obedecer
objetivo
obrigado
obscuro
obstetra
obter
obturar
ocidente
ocioso
ocorrer
oculista
ocupado
ofegante
ofensiva
oferenda
oficina
ofuscado
ogiva
olaria
oleoso
olhar
oliveira
ombro
omelete
omisso
omitir
ondulado
oneroso
ontem
opcional
operador
oponente
oportuno
oposto
orar
orbitar
ordem
ordinal
orfanato
orgasmo
orgulho
oriental
origem
oriundo
orla
ortodoxo
orvalho
oscilar
ossada
osso
ostentar
otimismo
ousadia
outono
outubro
ouvido
ovelha
ovular
oxidar
oxigenar
pacato
paciente
pacote
pactuar
padaria
padrinho
pagar
pagode
painel
pairar
paisagem
palavra
palestra
palheta
palito
palmada
palpitar
pancada
panela
panfleto
panqueca
pantanal
papagaio
papelada
papiro
parafina
parcial
pardal
parede
partida
pasmo
passado
pastel
patamar
patente
patinar
patrono
paulada
pausar
peculiar
pedalar
pedestre
pediatra
pedra
pegada
peitoral
peixe
pele
pelicano
penca
pendurar
peneira
penhasco
pensador
pente
perceber
perfeito
pergunta
perito
permitir
perna
perplexo
persiana
pertence
peruca
pescado
pesquisa
pessoa
petiscar
piada
picado
piedade
pigmento
pilastra
pilhado
pilotar
pimenta
pincel
pinguim
pinha
pinote
pintar
pioneiro
pipoca
piquete
piranha
pires
pirueta
piscar
pistola
pitanga
pivete
planta
plaqueta
platina
plebeu
plumagem
pluvial
pneu
poda
poeira
poetisa
polegada
policiar
poluente
polvilho
pomar
pomba
ponderar
pontaria
populoso
porta
possuir
postal
pote
poupar
pouso
povoar
praia
prancha
prato
praxe
prece
predador
prefeito
premiar
prensar
preparar
presilha
pretexto
prevenir
prezar
primata
princesa
prisma
privado
processo
produto
profeta
proibido
projeto
prometer
propagar
prosa
protetor
provador
publicar
pudim
pular
pulmonar
pulseira
punhal
punir
pupilo
pureza
puxador
quadra
quantia
quarto
quase
quebrar
queda
queijo
quente
querido
quimono
quina
quiosque
rabanada
rabisco
rachar
racionar
radial
raiar
rainha
raio
raiva
rajada
ralado
ramal
ranger
ranhura
rapadura
rapel
rapidez
raposa
raquete
raridade
rasante
rascunho
rasgar
raspador
rasteira
rasurar
ratazana
ratoeira
realeza
reanimar
reaver
rebaixar
rebelde
rebolar
recado
recente
recheio
recibo
recordar
recrutar
recuar
rede
redimir
redonda
reduzida
reenvio
refinar
refletir
refogar
refresco
refugiar
regalia
regime
regra
reinado
reitor
rejeitar
relativo
remador
remendo
remorso
renovado
reparo
repelir
repleto
repolho
represa
repudiar
requerer
resenha
resfriar
resgatar
residir
resolver
respeito
ressaca
restante
resumir
retalho
reter
retirar
retomada
retratar
revelar
revisor
revolta
riacho
rica
rigidez
rigoroso
rimar
ringue
risada
risco
risonho
robalo
rochedo
rodada
rodeio
rodovia
roedor
roleta
romano
roncar
rosado
roseira
rosto
rota
roteiro
rotina
rotular
rouco
roupa
roxo
rubro
rugido
rugoso
ruivo
rumo
rupestre
russo
sabor
saciar
sacola
sacudir
sadio
safira
saga
sagrada
saibro
salada
saleiro
salgado
saliva
salpicar
salsicha
saltar
salvador
sambar
samurai
sanar
sanfona
sangue
sanidade
sapato
sarda
sargento
sarjeta
saturar
saudade
saxofone
sazonal
secar
secular
seda
sedento
sediado
sedoso
sedutor
segmento
segredo
segundo
seiva
seleto
selvagem
semanal
semente
senador
senhor
sensual
sentado
separado
sereia
seringa
serra
servo
setembro
setor
sigilo
silhueta
silicone
simetria
simpatia
simular
sinal
sincero
singular
sinopse
sintonia
sirene
siri
situado
soberano
sobra
socorro
sogro
soja
solda
soletrar
solteiro
sombrio
sonata
sondar
sonegar
sonhador
sono
soprano
soquete
sorrir
sorteio
sossego
sotaque
soterrar
sovado
sozinho
suavizar
subida
submerso
subsolo
subtrair
sucata
sucesso
suco
sudeste
sufixo
sugador
sugerir
sujeito
sulfato
sumir
suor
superior
suplicar
suposto
suprimir
surdina
surfista
surpresa
surreal
surtir
suspiro
sustento
tabela
tablete
tabuada
tacho
tagarela
talher
talo
talvez
tamanho
tamborim
tampa
tangente
tanto
tapar
tapioca
tardio
tarefa
tarja
tarraxa
tatuagem
taurino
taxativo
taxista
teatral
tecer
tecido
teclado
tedioso
teia
teimar
telefone
telhado
tempero
tenente
tensor
tentar
termal
terno
terreno
tese
tesoura
testado
teto
textura
texugo
tiara
tigela
tijolo
timbrar
timidez
tingido
tinteiro
tiragem
titular
toalha
tocha
tolerar
tolice
tomada
tomilho
tonel
tontura
topete
tora
torcido
torneio
torque
torrada
torto
tostar
touca
toupeira
toxina
trabalho
tracejar
tradutor
trafegar
trajeto
trama
trancar
trapo
traseiro
tratador
travar
treino
tremer
trepidar
trevo
triagem
tribo
triciclo
tridente
trilogia
trindade
triplo
triturar
triunfal
trocar
trombeta
trova
trunfo
truque
tubular
tucano
tudo
tulipa
tupi
turbo
turma
turquesa
tutelar
tutorial
uivar
umbigo
unha
unidade
uniforme
urologia
urso
urtiga
urubu
usado
usina
usufruir
vacina
vadiar
vagaroso
vaidoso
vala
valente
validade
valores
vantagem
vaqueiro
varanda
vareta
varrer
vascular
vasilha
vassoura
vazar
vazio
veado
vedar
vegetar
veicular
veleiro
velhice
veludo
vencedor
vendaval
venerar
ventre
verbal
verdade
vereador
vergonha
vermelho
verniz
versar
vertente
vespa
vestido
vetorial
viaduto
viagem
viajar
viatura
vibrador
videira
vidraria
viela
viga
vigente
vigiar
vigorar
vilarejo
vinco
vinheta
vinil
violeta
virada
virtude
visitar
visto
vitral
viveiro
vizinho
voador
voar
vogal
volante
voleibol
voltagem
volumoso
vontade
vulto
vuvuzela
xadrez
xarope
xeque
xeretar
xerife
xingar
zangado
zarpar
zebu
zelador
zombar
zoologia
zumbido`;
const bip39WordListPortuguese = raw$1.split('\n');

/* eslint-disable max-lines */ /* cspell: disable */ const raw = `ábaco
abdomen
abeja
abierto
abogado
abono
aborto
abrazo
abrir
abuelo
abuso
acabar
academia
acceso
acción
aceite
acelga
acento
aceptar
ácido
aclarar
acné
acoger
acoso
activo
acto
actriz
actuar
acudir
acuerdo
acusar
adicto
admitir
adoptar
adorno
aduana
adulto
aéreo
afectar
afición
afinar
afirmar
ágil
agitar
agonía
agosto
agotar
agregar
agrio
agua
agudo
águila
aguja
ahogo
ahorro
aire
aislar
ajedrez
ajeno
ajuste
alacrán
alambre
alarma
alba
álbum
alcalde
aldea
alegre
alejar
alerta
aleta
alfiler
alga
algodón
aliado
aliento
alivio
alma
almeja
almíbar
altar
alteza
altivo
alto
altura
alumno
alzar
amable
amante
amapola
amargo
amasar
ámbar
ámbito
ameno
amigo
amistad
amor
amparo
amplio
ancho
anciano
ancla
andar
andén
anemia
ángulo
anillo
ánimo
anís
anotar
antena
antiguo
antojo
anual
anular
anuncio
añadir
añejo
año
apagar
aparato
apetito
apio
aplicar
apodo
aporte
apoyo
aprender
aprobar
apuesta
apuro
arado
araña
arar
árbitro
árbol
arbusto
archivo
arco
arder
ardilla
arduo
área
árido
aries
armonía
arnés
aroma
arpa
arpón
arreglo
arroz
arruga
arte
artista
asa
asado
asalto
ascenso
asegurar
aseo
asesor
asiento
asilo
asistir
asno
asombro
áspero
astilla
astro
astuto
asumir
asunto
atajo
ataque
atar
atento
ateo
ático
atleta
átomo
atraer
atroz
atún
audaz
audio
auge
aula
aumento
ausente
autor
aval
avance
avaro
ave
avellana
avena
avestruz
avión
aviso
ayer
ayuda
ayuno
azafrán
azar
azote
azúcar
azufre
azul
baba
babor
bache
bahía
baile
bajar
balanza
balcón
balde
bambú
banco
banda
baño
barba
barco
barniz
barro
báscula
bastón
basura
batalla
batería
batir
batuta
baúl
bazar
bebé
bebida
bello
besar
beso
bestia
bicho
bien
bingo
blanco
bloque
blusa
boa
bobina
bobo
boca
bocina
boda
bodega
boina
bola
bolero
bolsa
bomba
bondad
bonito
bono
bonsái
borde
borrar
bosque
bote
botín
bóveda
bozal
bravo
brazo
brecha
breve
brillo
brinco
brisa
broca
broma
bronce
brote
bruja
brusco
bruto
buceo
bucle
bueno
buey
bufanda
bufón
búho
buitre
bulto
burbuja
burla
burro
buscar
butaca
buzón
caballo
cabeza
cabina
cabra
cacao
cadáver
cadena
caer
café
caída
caimán
caja
cajón
cal
calamar
calcio
caldo
calidad
calle
calma
calor
calvo
cama
cambio
camello
camino
campo
cáncer
candil
canela
canguro
canica
canto
caña
cañón
caoba
caos
capaz
capitán
capote
captar
capucha
cara
carbón
cárcel
careta
carga
cariño
carne
carpeta
carro
carta
casa
casco
casero
caspa
castor
catorce
catre
caudal
causa
cazo
cebolla
ceder
cedro
celda
célebre
celoso
célula
cemento
ceniza
centro
cerca
cerdo
cereza
cero
cerrar
certeza
césped
cetro
chacal
chaleco
champú
chancla
chapa
charla
chico
chiste
chivo
choque
choza
chuleta
chupar
ciclón
ciego
cielo
cien
cierto
cifra
cigarro
cima
cinco
cine
cinta
ciprés
circo
ciruela
cisne
cita
ciudad
clamor
clan
claro
clase
clave
cliente
clima
clínica
cobre
cocción
cochino
cocina
coco
código
codo
cofre
coger
cohete
cojín
cojo
cola
colcha
colegio
colgar
colina
collar
colmo
columna
combate
comer
comida
cómodo
compra
conde
conejo
conga
conocer
consejo
contar
copa
copia
corazón
corbata
corcho
cordón
corona
correr
coser
cosmos
costa
cráneo
cráter
crear
crecer
creído
crema
cría
crimen
cripta
crisis
cromo
crónica
croqueta
crudo
cruz
cuadro
cuarto
cuatro
cubo
cubrir
cuchara
cuello
cuento
cuerda
cuesta
cueva
cuidar
culebra
culpa
culto
cumbre
cumplir
cuna
cuneta
cuota
cupón
cúpula
curar
curioso
curso
curva
cutis
dama
danza
dar
dardo
dátil
deber
débil
década
decir
dedo
defensa
definir
dejar
delfín
delgado
delito
demora
denso
dental
deporte
derecho
derrota
desayuno
deseo
desfile
desnudo
destino
desvío
detalle
detener
deuda
día
diablo
diadema
diamante
diana
diario
dibujo
dictar
diente
dieta
diez
difícil
digno
dilema
diluir
dinero
directo
dirigir
disco
diseño
disfraz
diva
divino
doble
doce
dolor
domingo
don
donar
dorado
dormir
dorso
dos
dosis
dragón
droga
ducha
duda
duelo
dueño
dulce
dúo
duque
durar
dureza
duro
ébano
ebrio
echar
eco
ecuador
edad
edición
edificio
editor
educar
efecto
eficaz
eje
ejemplo
elefante
elegir
elemento
elevar
elipse
élite
elixir
elogio
eludir
embudo
emitir
emoción
empate
empeño
empleo
empresa
enano
encargo
enchufe
encía
enemigo
enero
enfado
enfermo
engaño
enigma
enlace
enorme
enredo
ensayo
enseñar
entero
entrar
envase
envío
época
equipo
erizo
escala
escena
escolar
escribir
escudo
esencia
esfera
esfuerzo
espada
espejo
espía
esposa
espuma
esquí
estar
este
estilo
estufa
etapa
eterno
ética
etnia
evadir
evaluar
evento
evitar
exacto
examen
exceso
excusa
exento
exigir
exilio
existir
éxito
experto
explicar
exponer
extremo
fábrica
fábula
fachada
fácil
factor
faena
faja
falda
fallo
falso
faltar
fama
familia
famoso
faraón
farmacia
farol
farsa
fase
fatiga
fauna
favor
fax
febrero
fecha
feliz
feo
feria
feroz
fértil
fervor
festín
fiable
fianza
fiar
fibra
ficción
ficha
fideo
fiebre
fiel
fiera
fiesta
figura
fijar
fijo
fila
filete
filial
filtro
fin
finca
fingir
finito
firma
flaco
flauta
flecha
flor
flota
fluir
flujo
flúor
fobia
foca
fogata
fogón
folio
folleto
fondo
forma
forro
fortuna
forzar
fosa
foto
fracaso
frágil
franja
frase
fraude
freír
freno
fresa
frío
frito
fruta
fuego
fuente
fuerza
fuga
fumar
función
funda
furgón
furia
fusil
fútbol
futuro
gacela
gafas
gaita
gajo
gala
galería
gallo
gamba
ganar
gancho
ganga
ganso
garaje
garza
gasolina
gastar
gato
gavilán
gemelo
gemir
gen
género
genio
gente
geranio
gerente
germen
gesto
gigante
gimnasio
girar
giro
glaciar
globo
gloria
gol
golfo
goloso
golpe
goma
gordo
gorila
gorra
gota
goteo
gozar
grada
gráfico
grano
grasa
gratis
grave
grieta
grillo
gripe
gris
grito
grosor
grúa
grueso
grumo
grupo
guante
guapo
guardia
guerra
guía
guiño
guion
guiso
guitarra
gusano
gustar
haber
hábil
hablar
hacer
hacha
hada
hallar
hamaca
harina
haz
hazaña
hebilla
hebra
hecho
helado
helio
hembra
herir
hermano
héroe
hervir
hielo
hierro
hígado
higiene
hijo
himno
historia
hocico
hogar
hoguera
hoja
hombre
hongo
honor
honra
hora
hormiga
horno
hostil
hoyo
hueco
huelga
huerta
hueso
huevo
huida
huir
humano
húmedo
humilde
humo
hundir
huracán
hurto
icono
ideal
idioma
ídolo
iglesia
iglú
igual
ilegal
ilusión
imagen
imán
imitar
impar
imperio
imponer
impulso
incapaz
índice
inerte
infiel
informe
ingenio
inicio
inmenso
inmune
innato
insecto
instante
interés
íntimo
intuir
inútil
invierno
ira
iris
ironía
isla
islote
jabalí
jabón
jamón
jarabe
jardín
jarra
jaula
jazmín
jefe
jeringa
jinete
jornada
joroba
joven
joya
juerga
jueves
juez
jugador
jugo
juguete
juicio
junco
jungla
junio
juntar
júpiter
jurar
justo
juvenil
juzgar
kilo
koala
labio
lacio
lacra
lado
ladrón
lagarto
lágrima
laguna
laico
lamer
lámina
lámpara
lana
lancha
langosta
lanza
lápiz
largo
larva
lástima
lata
látex
latir
laurel
lavar
lazo
leal
lección
leche
lector
leer
legión
legumbre
lejano
lengua
lento
leña
león
leopardo
lesión
letal
letra
leve
leyenda
libertad
libro
licor
líder
lidiar
lienzo
liga
ligero
lima
límite
limón
limpio
lince
lindo
línea
lingote
lino
linterna
líquido
liso
lista
litera
litio
litro
llaga
llama
llanto
llave
llegar
llenar
llevar
llorar
llover
lluvia
lobo
loción
loco
locura
lógica
logro
lombriz
lomo
lonja
lote
lucha
lucir
lugar
lujo
luna
lunes
lupa
lustro
luto
luz
maceta
macho
madera
madre
maduro
maestro
mafia
magia
mago
maíz
maldad
maleta
malla
malo
mamá
mambo
mamut
manco
mando
manejar
manga
maniquí
manjar
mano
manso
manta
mañana
mapa
máquina
mar
marco
marea
marfil
margen
marido
mármol
marrón
martes
marzo
masa
máscara
masivo
matar
materia
matiz
matriz
máximo
mayor
mazorca
mecha
medalla
medio
médula
mejilla
mejor
melena
melón
memoria
menor
mensaje
mente
menú
mercado
merengue
mérito
mes
mesón
meta
meter
método
metro
mezcla
miedo
miel
miembro
miga
mil
milagro
militar
millón
mimo
mina
minero
mínimo
minuto
miope
mirar
misa
miseria
misil
mismo
mitad
mito
mochila
moción
moda
modelo
moho
mojar
molde
moler
molino
momento
momia
monarca
moneda
monja
monto
moño
morada
morder
moreno
morir
morro
morsa
mortal
mosca
mostrar
motivo
mover
móvil
mozo
mucho
mudar
mueble
muela
muerte
muestra
mugre
mujer
mula
muleta
multa
mundo
muñeca
mural
muro
músculo
museo
musgo
música
muslo
nácar
nación
nadar
naipe
naranja
nariz
narrar
nasal
natal
nativo
natural
náusea
naval
nave
navidad
necio
néctar
negar
negocio
negro
neón
nervio
neto
neutro
nevar
nevera
nicho
nido
niebla
nieto
niñez
niño
nítido
nivel
nobleza
noche
nómina
noria
norma
norte
nota
noticia
novato
novela
novio
nube
nuca
núcleo
nudillo
nudo
nuera
nueve
nuez
nulo
número
nutria
oasis
obeso
obispo
objeto
obra
obrero
observar
obtener
obvio
oca
ocaso
océano
ochenta
ocho
ocio
ocre
octavo
octubre
oculto
ocupar
ocurrir
odiar
odio
odisea
oeste
ofensa
oferta
oficio
ofrecer
ogro
oído
oír
ojo
ola
oleada
olfato
olivo
olla
olmo
olor
olvido
ombligo
onda
onza
opaco
opción
ópera
opinar
oponer
optar
óptica
opuesto
oración
orador
oral
órbita
orca
orden
oreja
órgano
orgía
orgullo
oriente
origen
orilla
oro
orquesta
oruga
osadía
oscuro
osezno
oso
ostra
otoño
otro
oveja
óvulo
óxido
oxígeno
oyente
ozono
pacto
padre
paella
página
pago
país
pájaro
palabra
palco
paleta
pálido
palma
paloma
palpar
pan
panal
pánico
pantera
pañuelo
papá
papel
papilla
paquete
parar
parcela
pared
parir
paro
párpado
parque
párrafo
parte
pasar
paseo
pasión
paso
pasta
pata
patio
patria
pausa
pauta
pavo
payaso
peatón
pecado
pecera
pecho
pedal
pedir
pegar
peine
pelar
peldaño
pelea
peligro
pellejo
pelo
peluca
pena
pensar
peñón
peón
peor
pepino
pequeño
pera
percha
perder
pereza
perfil
perico
perla
permiso
perro
persona
pesa
pesca
pésimo
pestaña
pétalo
petróleo
pez
pezuña
picar
pichón
pie
piedra
pierna
pieza
pijama
pilar
piloto
pimienta
pino
pintor
pinza
piña
piojo
pipa
pirata
pisar
piscina
piso
pista
pitón
pizca
placa
plan
plata
playa
plaza
pleito
pleno
plomo
pluma
plural
pobre
poco
poder
podio
poema
poesía
poeta
polen
policía
pollo
polvo
pomada
pomelo
pomo
pompa
poner
porción
portal
posada
poseer
posible
poste
potencia
potro
pozo
prado
precoz
pregunta
premio
prensa
preso
previo
primo
príncipe
prisión
privar
proa
probar
proceso
producto
proeza
profesor
programa
prole
promesa
pronto
propio
próximo
prueba
público
puchero
pudor
pueblo
puerta
puesto
pulga
pulir
pulmón
pulpo
pulso
puma
punto
puñal
puño
pupa
pupila
puré
quedar
queja
quemar
querer
queso
quieto
química
quince
quitar
rábano
rabia
rabo
ración
radical
raíz
rama
rampa
rancho
rango
rapaz
rápido
rapto
rasgo
raspa
rato
rayo
raza
razón
reacción
realidad
rebaño
rebote
recaer
receta
rechazo
recoger
recreo
recto
recurso
red
redondo
reducir
reflejo
reforma
refrán
refugio
regalo
regir
regla
regreso
rehén
reino
reír
reja
relato
relevo
relieve
relleno
reloj
remar
remedio
remo
rencor
rendir
renta
reparto
repetir
reposo
reptil
res
rescate
resina
respeto
resto
resumen
retiro
retorno
retrato
reunir
revés
revista
rey
rezar
rico
riego
rienda
riesgo
rifa
rígido
rigor
rincón
riñón
río
riqueza
risa
ritmo
rito
rizo
roble
roce
rociar
rodar
rodeo
rodilla
roer
rojizo
rojo
romero
romper
ron
ronco
ronda
ropa
ropero
rosa
rosca
rostro
rotar
rubí
rubor
rudo
rueda
rugir
ruido
ruina
ruleta
rulo
rumbo
rumor
ruptura
ruta
rutina
sábado
saber
sabio
sable
sacar
sagaz
sagrado
sala
saldo
salero
salir
salmón
salón
salsa
salto
salud
salvar
samba
sanción
sandía
sanear
sangre
sanidad
sano
santo
sapo
saque
sardina
sartén
sastre
satán
sauna
saxofón
sección
seco
secreto
secta
sed
seguir
seis
sello
selva
semana
semilla
senda
sensor
señal
señor
separar
sepia
sequía
ser
serie
sermón
servir
sesenta
sesión
seta
setenta
severo
sexo
sexto
sidra
siesta
siete
siglo
signo
sílaba
silbar
silencio
silla
símbolo
simio
sirena
sistema
sitio
situar
sobre
socio
sodio
sol
solapa
soldado
soledad
sólido
soltar
solución
sombra
sondeo
sonido
sonoro
sonrisa
sopa
soplar
soporte
sordo
sorpresa
sorteo
sostén
sótano
suave
subir
suceso
sudor
suegra
suelo
sueño
suerte
sufrir
sujeto
sultán
sumar
superar
suplir
suponer
supremo
sur
surco
sureño
surgir
susto
sutil
tabaco
tabique
tabla
tabú
taco
tacto
tajo
talar
talco
talento
talla
talón
tamaño
tambor
tango
tanque
tapa
tapete
tapia
tapón
taquilla
tarde
tarea
tarifa
tarjeta
tarot
tarro
tarta
tatuaje
tauro
taza
tazón
teatro
techo
tecla
técnica
tejado
tejer
tejido
tela
teléfono
tema
temor
templo
tenaz
tender
tener
tenis
tenso
teoría
terapia
terco
término
ternura
terror
tesis
tesoro
testigo
tetera
texto
tez
tibio
tiburón
tiempo
tienda
tierra
tieso
tigre
tijera
tilde
timbre
tímido
timo
tinta
tío
típico
tipo
tira
tirón
titán
títere
título
tiza
toalla
tobillo
tocar
tocino
todo
toga
toldo
tomar
tono
tonto
topar
tope
toque
tórax
torero
tormenta
torneo
toro
torpedo
torre
torso
tortuga
tos
tosco
toser
tóxico
trabajo
tractor
traer
tráfico
trago
traje
tramo
trance
trato
trauma
trazar
trébol
tregua
treinta
tren
trepar
tres
tribu
trigo
tripa
triste
triunfo
trofeo
trompa
tronco
tropa
trote
trozo
truco
trueno
trufa
tubería
tubo
tuerto
tumba
tumor
túnel
túnica
turbina
turismo
turno
tutor
ubicar
úlcera
umbral
unidad
unir
universo
uno
untar
uña
urbano
urbe
urgente
urna
usar
usuario
útil
utopía
uva
vaca
vacío
vacuna
vagar
vago
vaina
vajilla
vale
válido
valle
valor
válvula
vampiro
vara
variar
varón
vaso
vecino
vector
vehículo
veinte
vejez
vela
velero
veloz
vena
vencer
venda
veneno
vengar
venir
venta
venus
ver
verano
verbo
verde
vereda
verja
verso
verter
vía
viaje
vibrar
vicio
víctima
vida
vídeo
vidrio
viejo
viernes
vigor
vil
villa
vinagre
vino
viñedo
violín
viral
virgo
virtud
visor
víspera
vista
vitamina
viudo
vivaz
vivero
vivir
vivo
volcán
volumen
volver
voraz
votar
voto
voz
vuelo
vulgar
yacer
yate
yegua
yema
yerno
yeso
yodo
yoga
yogur
zafiro
zanja
zapato
zarza
zona
zorro
zumo
zurdo`;
const bip39WordListSpanish = raw.split('\n');

var Bip39Error;
(function (Bip39Error) {
    Bip39Error["invalidEntropyLength"] = "BIP39 Error: invalid entropy length. Entropy length must be 16, 20, 24, 28, or 32 bytes.";
    Bip39Error["invalidMnemonicLength"] = "BIP39 Error: invalid mnemonic length. Word count must be 12, 15, 18, 21, or 24.";
    Bip39Error["invalidWordListLength"] = "BIP39 Error: invalid word list length. BIP39 word lists must contain exactly 2048 words.";
    Bip39Error["invalidChecksum"] = "BIP39 Error: invalid checksum for the given mnemonic phrase.";
    Bip39Error["unknownWord"] = "BIP39 Error: unknown word(s). The mnemonic phrase contains one or more words that do not exist in the word list.";
})(Bip39Error || (Bip39Error = {}));
/**
 * Verify that the provided BIP39 word list contains exactly 2048 words.
 *
 * @param wordList - the word list
 */
const isValidBip39WordList = (wordList) => wordList.length === 2048 /* Bip39.validWordListLength */;
/**
 * Verify that the length of the provided entropy is valid for BIP39: 16, 20,
 * 24, 28, or 32 bytes.
 *
 * @param entropy - the entropy bytes
 */
const isValidBip39EntropyLength = (entropy) => entropy.length >= 16 /* Bip39.minEntropyBytes */ &&
    entropy.length <= 32 /* Bip39.maxEntropyBytes */ &&
    entropy.length % 4 /* Bip39.entropyLengthStepSize */ === 0;
/**
 * Derive BIP39 checksum bits for the given entropy bytes.
 *
 * Note, this method always completes. For a valid result, `entropy` must
 * satisfy {@link isValidBip39EntropyLength}.
 *
 * @param entropy - the entropy bytes
 */
const deriveBip39ChecksumBits = (entropy) => {
    const ENT = entropy.length * 8 /* Bip39.bitsPerByte */;
    const CS = ENT / 32 /* Bip39.checksumRatio */;
    const hash = sha256.hash(entropy);
    return binToBinString(hash).slice(0, CS);
};
/**
 * Decode the provided BIP39 mnemonic phrase using the provided word list.
 * Reverses {@link encodeBip39MnemonicNonStandard}.
 *
 * See {@link decodeBip39Mnemonic} to decode using the English word list.
 *
 * @param mnemonic - the BIP39 mnemonic phrase
 * @param wordList - the word list to use
 */
// eslint-disable-next-line complexity
const decodeBip39MnemonicNonStandard = (mnemonic, wordList) => {
    if (!isValidBip39WordList(wordList)) {
        return formatError(Bip39Error.invalidWordListLength, `Word list length: ${wordList.length}.`);
    }
    const words = mnemonic.normalize('NFKD').split(' ');
    if (words.length % 3 /* Bip39.wordCountStepSize */ !== 0 ||
        words.length < 12 /* Bip39.minWordCount */ ||
        words.length > 24 /* Bip39.maxWordCount */) {
        return formatError(Bip39Error.invalidMnemonicLength, `Word count: ${words.length}.`);
    }
    const unknownWords = words.filter((word) => !wordList.includes(word));
    if (unknownWords.length !== 0) {
        return formatError(Bip39Error.unknownWord, `Unknown word(s): ${unknownWords.join(', ')}.`);
    }
    const binString = words
        .map((word) => {
        const index = wordList.indexOf(word);
        return index.toString(2 /* Bip39.base2 */).padStart(11 /* Bip39.bitsPerWord */, '0');
    })
        .join('');
    const splitIndex = (words.length / 3 /* Bip39.wordCountStepSize */) * 32 /* Bip39.checksumRatio */;
    const entropyBits = binString.slice(0, splitIndex);
    const checksumBits = binString.slice(splitIndex);
    const entropy = binStringToBin(entropyBits);
    const newChecksum = deriveBip39ChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        return formatError(Bip39Error.invalidChecksum, `Encoded: ${checksumBits}; computed: ${newChecksum}.`);
    }
    return entropy;
};
/**
 * Decode the provided BIP39 mnemonic phrase using the English word list.
 * Reverses {@link encodeBip39Mnemonic}.
 *
 * See {@link decodeBip39MnemonicNonStandard} for other word lists.
 *
 * @param mnemonic - the BIP39 mnemonic phrase
 */
const decodeBip39Mnemonic = (mnemonic) => decodeBip39MnemonicNonStandard(mnemonic, bip39WordListEnglish);
/**
 * Encode the provided entropy in a BIP39 mnemonic phrase using a custom word
 * list. Reverses {@link decodeBip39MnemonicNonStandard}.
 *
 * See {@link encodeBip39Mnemonic} to encode using the English word list.
 *
 * If the provided `entropy` and `wordList` each has a valid length, this method
 * will never error.
 *
 * @param entropy - the entropy (length must be 16, 20, 24, 28, or 32 bytes)
 * @param wordList - the word list to use
 */
const encodeBip39MnemonicNonStandard = (entropy, wordList) => {
    if (!isValidBip39EntropyLength(entropy)) {
        return formatError(Bip39Error.invalidEntropyLength, `Entropy length: ${entropy.length}.`);
    }
    if (!isValidBip39WordList(wordList)) {
        return formatError(Bip39Error.invalidWordListLength, `Word list length: ${wordList.length}.`);
    }
    const entropyBits = binToBinString(entropy);
    const checksumBits = deriveBip39ChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = splitEvery(bits, 11 /* Bip39.bitsPerWord */);
    const words = chunks.map((binary) => {
        const index = parseInt(binary, 2);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const word = wordList[index];
        return word;
    });
    /*
     * Japanese phrases use an ideographic space separator; if the first word is
     * Japanese, join using `\u3000`.
     */
    const phrase = wordList[0] === '\u3042\u3044\u3053\u304f\u3057\u3093'
        ? words.join('\u3000')
        : words.join(' ');
    return { phrase };
};
/**
 * Encode the provided entropy in an English BIP39 mnemonic phrase.
 * Reverses {@link decodeBip39Mnemonic}.
 *
 * Even for localized applications, English is the safest choice for BIP39
 * mnemonic phrase encoding. English mnemonic phrases are the most widely used
 * and supported by ecosystem tooling, meaning they can be more reliably error
 * corrected than phrases using other word lists, and they are more likely to be
 * recognized as valuable by humans and generalized automation, e.g.
 * organizational secret scanning and anti-exfiltration software. Note also that
 * specialized exfiltration efforts are unlikely to be thwarted by obscuring
 * mnemonic phrases with localized or custom word lists; instead, consider using
 * a passphrase during seed derivation.
 *
 * If the provided `entropy` is a valid length, this method will never error.
 *
 * To use other word lists, see {@link encodeBip39MnemonicNonStandard}.
 *
 * @param entropy - the entropy (length must be 16, 20, 24, 28, or 32 bytes)
 */
const encodeBip39Mnemonic = (entropy) => encodeBip39MnemonicNonStandard(entropy, bip39WordListEnglish);
/**
 * Derive a seed from the provided BIP39 mnemonic phrase.
 *
 * Note that by design, **BIP39 seed derivation is one-way**: seeds derived from
 * a mnemonic phrase cannot be used to recover the source phrase. Additionally,
 * BIP39 seed derivation does not perform any validation on the provided
 * mnemonic phrase, **allowing derivation from any string**.
 *
 * For use cases in which a particular mnemonic phrase is expected to be
 * correctly formed (with a valid checksum), first verify that it can be decoded
 * with {@link decodeBip39Mnemonic}.
 *
 * @param mnemonic - the BIP39 mnemonic phrase
 * @param passphrase - an optional passphrase (defaults to `undefined`)
 * @param crypto - an optional object containing an implementation of PBKDF2
 * using HMAC SHA512 (defaults to the internal WASM implementations)
 */
const deriveSeedFromBip39Mnemonic = (mnemonic, { crypto = { pbkdf2HmacSha512: pbkdf2HmacSha512 }, passphrase = '', } = {}) => {
    const mnemonicNormalized = mnemonic.normalize('NFKD');
    const salt = `mnemonic${passphrase}`;
    const saltNormalized = salt.normalize('NFKD');
    const mnemonicBin = utf8ToBin(mnemonicNormalized);
    const saltBin = utf8ToBin(saltNormalized);
    return crypto.pbkdf2HmacSha512({
        derivedKeyLength: 64 /* Bip39.derivedKeyLength */,
        iterations: 2048 /* Bip39.pbkdf2Iterations */,
        password: mnemonicBin,
        salt: saltBin,
    });
};
/**
 * Derive an {@link HdPrivateNode} from the provided BIP39 mnemonic phrase
 * following the BIP32 and BIP39 specifications.
 *
 * Note that by design, **BIP39 seed derivation is one-way**: seeds derived from
 * a mnemonic phrase cannot be used to recover the source phrase. Additionally,
 * BIP39 seed derivation does not perform any validation on the provided
 * mnemonic phrase, **allowing derivation from any string**.
 *
 * For use cases in which a particular mnemonic phrase is expected to be
 * correctly formed (with a valid checksum), first verify that it can be decoded
 * with {@link decodeBip39Mnemonic}.
 *
 * @param mnemonic - the BIP39 mnemonic phrase
 * @param passphrase - an optional passphrase (defaults to `undefined`)
 * @param crypto - an optional object containing an implementation of SHA-512
 * and PBKDF2 using HMAC SHA-512 (defaults to the internal WASM implementations)
 * @param hmacSha512Key - the HMAC SHA-512 key to use (defaults the HMAC SHA-512
 * key used by BIP32, `utf8ToBin('Bitcoin seed')`
 */
const deriveHdPrivateNodeFromBip39Mnemonic = (mnemonic, { crypto = {
    pbkdf2HmacSha512: pbkdf2HmacSha512,
    sha512: sha512,
}, hmacSha512Key, passphrase, } = {}) => deriveHdPrivateNodeFromSeed(deriveSeedFromBip39Mnemonic(mnemonic, { crypto, passphrase }), { crypto, hmacSha512Key });
/**
 * Generate a new, cryptographically secure, BIP39 mnemonic phrase using a
 * localized or custom word list.
 *
 * See {@link generateBip39Mnemonic} to generate a standard, 12-word English
 * mnemonic phrase.
 *
 * See {@link encodeBip39Mnemonic} to encode existing entropy as a BIP39
 * mnemonic phrase.
 *
 * **Usage**
 * ```ts
 * import {
 *   assertSuccess,
 *   bip39WordListSpanish,
 *   generateBip39Mnemonic
 * } from '@bitauth/libauth';
 *
 * const { phrase } = assertSuccess(generateBip39Mnemonic(bip39WordListSpanish, 32));
 * ```
 *
 * @param wordList - a 2048-word array to use as the BIP39 word list
 * @param entropyLength - the entropy length to generate – 16, 20, 24, 28, or 32
 * bytes (defaults to 16).
 */
const generateBip39MnemonicNonStandard = (wordList, entropyLength = 16 /* Bip39.minEntropyBytes */, { generateRandomBytes: generateRandomBytes$1 = generateRandomBytes, } = {}) => {
    if (!isValidBip39WordList(wordList)) {
        return formatError(Bip39Error.invalidWordListLength, `Word list length: ${wordList.length}.`);
    }
    const entropy = generateRandomBytes$1(entropyLength);
    if (!isValidBip39EntropyLength(entropy)) {
        return formatError(Bip39Error.invalidEntropyLength, `Entropy length: ${entropy.length}.`);
    }
    return encodeBip39MnemonicNonStandard(entropy, wordList);
};
/**
 * Generate a new, cryptographically secure, 12-word English BIP39
 * mnemonic phrase.
 *
 * See {@link generateBip39MnemonicNonStandard} to use a localized or custom
 * word list.
 *
 * See {@link encodeBip39Mnemonic} to encode existing entropy as a BIP39
 * mnemonic phrase.
 *
 * **Usage**
 * ```ts
 * import { generateBip39Mnemonic } from '@bitauth/libauth';
 *
 * const phrase = generateBip39Mnemonic();
 * ```
 */
const generateBip39Mnemonic = () => generateBip39MnemonicNonStandard(bip39WordListEnglish, 16 /* Bip39.minEntropyBytes */).phrase;
// cSpell:ignore aban
/**
 * TODO: not yet implemented; see also: {@link attemptCashAddressFormatErrorCorrection}
 *
 * Attempt to automatically correct any typographical errors in a BIP39 mnemonic
 * phrase, returning correction information for the closest matching valid
 * mnemonic phrase.
 *
 * Note that by design, BIP39 allows seed derivation from any NFKD-normalized
 * string, including phrases containing an incorrect or unrecognized checksum.
 *
 * **Indiscriminate use of this function during BIP39 mnemonic phrase import
 * would prevent the use of seeds derived from such nonstandard phrases.**
 *
 * Instead, this function should be used to offer an end user the best possible
 * correction for the provided mnemonic phrase, e.g.:
 *
 * ```
 * Warning: the BIP39 mnemonic phrase you entered appears to have typographical
 * errors. The phrase could be corrected to:
 *
 * [Render the corrected phrase, emphasizing all correction ranges.]
 *
 * Correction description: [render Bip39MnemonicCorrection.description]
 *
 * Would you like to use this corrected phrase?
 *
 * [Button: "Use corrected phrase"] [Button: "Use phrase with errors"]
 * ```
 *
 * This function attempts the following corrections, returning a
 * {@link Bip39MnemonicCorrection} as soon as a BIP39 mnemonic phrase with a
 * valid checksum is produced:
 *
 * - Trim whitespace from the beginning and end of the phrase
 * - Convert the phrase to lowercase characters
 * - Identify the best candidate word list from `possibleWordLists` with which
 * to correct errors by counting exact prefix matches, e.g. `aban` is a prefix
 * match for both English and French. If two word lists share the same number of
 * matches, the earlier index in `possibleWordLists` is prioritized. (Note that
 * `100` words are shared between the French and English word lists, and `1275`
 * words are shared between the Chinese Traditional and Chinese Simplified word
 * lists. Because this function is intended to correct standard BIP39 mnemonic
 * phrases, we assume that all correct words are found in a single word list.
 * - Deduplicate spaces between words, ensuring the expected space separator is
 * used (for the Japanese word list, an ideographic space separator: `\u3000`).
 * - Attempt to verify the checksum for all valid subsets of the phrase by
 * slicing the phrase at 24, 21, 18, 15, and 12 words. In these cases, the
 * additional words may have been entered in error, or they may be part of a
 * passphrase recorded in the same location as the phrase. The returned
 * {@link Bip39MnemonicCorrection.description} indicates that the user should
 * review the source material to see if the deleted word(s) are a passphrase.
 * - For every word where an exact match is not found, develop a ranked list of
 * possible matches:
 *   - Attempt to extend the word by finding all word(s) in the selected word
 * list with a matching prefix (i.e. only the first few characters of the
 * correct word were included in the incorrect phrase). If multiple prefix
 * matches are found, rank them in word list order (in later steps, all of these
 * matches are considered to have a similarity of `1`).
 *   - If no prefix matches were found, compute the Jaro similarity between
 * the unknown word and every word in the candidate word list, adding all
 * words to the ranked list in descending-similarity, then word list order.
 * - Attempt to find a corrected phrase with the minimum possible correction by
 * validating the checksum for each candidate combination in ranked order:
 *   - Beginning with a similarity target of 1, create candidate combinations
 * by replacing unknown words with all possible matches having a similarity
 * equal to or greater than the target.
 *   - If any unknown words have no matches meeting the similarity target, lower
 * the similarity target to the value of the next-most-similar match for that
 * word, using only that match in this correction iteration.
 *   - If no phrases with a valid checksum are found, repeat these steps with
 * the lowered similarity target, excluding previously-tried combinations.
 *
 * If no plausible matches are found, or if the provided phrase has an invalid
 * word count (after attempting to correct whitespace errors), an error (string)
 * is returned.
 *
 * Note, this method does not attempt to correct mnemonic phrases with an
 * incorrect word count; in these cases, the user should be asked to either
 * identify and provide the missing words or use a dedicated brute-forcing tool
 * (if words have been lost).
 *
 * @param mnemonic - the BIP39 mnemonic phrase to error-correct
 * @param possibleWordLists - an array of BIP39 word lists that may be in use by
 * the BIP39 mnemonic
 */
const attemptBip39MnemonicErrorCorrection = /* c8 ignore next */ (
/* c8 ignore next 3 */
_mnemonic, _possibleWordLists) => 'TODO: not yet implemented';
// export enum Bip39MnemonicCorrectionError {}

var WalletImportFormatError;
(function (WalletImportFormatError) {
    WalletImportFormatError["incorrectLength"] = "The WIF private key payload is not the correct length.";
})(WalletImportFormatError || (WalletImportFormatError = {}));
/**
 * Encode a private key using Wallet Import Format (WIF).
 *
 * WIF encodes the 32-byte private key, a 4-byte checksum, and a `type`
 * indicating the intended usage for the private key. See
 * {@link WalletImportFormatType} for details.
 *
 * @remarks
 * WIF-encoding uses the Base58Address format with version
 * {@link Base58AddressFormatVersion.wif} (`128`/`0x80`) or
 * {@link Base58AddressFormatVersion.wifTestnet} (`239`/`0xef`), respectively.
 *
 * To indicate that the private key is intended for use in a P2PKH address using
 * the compressed form of its derived public key, a `0x01` is appended to the
 * payload prior to encoding. For the uncompressed construction, the extra byte
 * is omitted.
 *
 * For the reverse, see {@link decodePrivateKeyWif}.
 *
 * @param privateKey - a 32-byte Secp256k1 ECDSA private key
 * @param type - the intended usage of the private key (e.g. `mainnet` or
 * `testnet`)
 * @param sha256 - an implementation of sha256
 */
const encodePrivateKeyWif = (privateKey, type, sha256$1 = sha256) => {
    const compressedByte = 0x01;
    const mainnet = type === 'mainnet' || type === 'mainnetUncompressed';
    const compressed = type === 'mainnet' || type === 'testnet';
    const payload = compressed
        ? Uint8Array.from([...privateKey, compressedByte])
        : privateKey;
    return encodeBase58AddressFormat(mainnet
        ? Base58AddressFormatVersion.wif
        : Base58AddressFormatVersion.wifTestnet, payload, sha256$1);
};
/**
 * Decode a private key using Wallet Import Format (WIF). See
 * {@link encodePrivateKeyWif} for details.
 *
 * For the reverse, use {@link encodePrivateKeyWif}.
 *
 * @param wifKey - the private key to decode (in Wallet Import Format)
 * @param sha256 - an implementation of sha256
 */
// eslint-disable-next-line complexity
const decodePrivateKeyWif = (wifKey, sha256$1 = sha256) => {
    const compressedPayloadLength = 33;
    const decoded = decodeBase58AddressFormat(wifKey, sha256$1);
    if (typeof decoded === 'string')
        return decoded;
    const mainnet = decoded.version === Base58AddressFormatVersion.wif;
    const compressed = decoded.payload.length === compressedPayloadLength;
    const privateKey = compressed
        ? decoded.payload.slice(0, -1)
        : decoded.payload;
    const type = mainnet
        ? compressed
            ? 'mainnet'
            : 'mainnetUncompressed'
        : compressed
            ? 'testnet'
            : 'testnetUncompressed';
    return { privateKey, type };
};

var IdentifierResolutionType;
(function (IdentifierResolutionType) {
    IdentifierResolutionType["opcode"] = "opcode";
    IdentifierResolutionType["variable"] = "variable";
    IdentifierResolutionType["script"] = "script";
})(IdentifierResolutionType || (IdentifierResolutionType = {}));
var IdentifierResolutionErrorType;
(function (IdentifierResolutionErrorType) {
    IdentifierResolutionErrorType["unknown"] = "unknown";
    IdentifierResolutionErrorType["variable"] = "variable";
    IdentifierResolutionErrorType["script"] = "script";
})(IdentifierResolutionErrorType || (IdentifierResolutionErrorType = {}));

const pluckStartPosition = (range) => ({
    startColumn: range.startColumn,
    startLineNumber: range.startLineNumber,
});
const pluckEndPosition = (range) => ({
    endColumn: range.endColumn,
    endLineNumber: range.endLineNumber,
});
/**
 * Combine an array of `Range`s into a single larger `Range`.
 *
 * @param ranges - an array of `Range`s
 * @param parentRange - the range to assume if `ranges` is an empty array
 */
const mergeRanges = (ranges, parentRange = {
    endColumn: 0,
    endLineNumber: 0,
    startColumn: 0,
    startLineNumber: 0,
}) => {
    const minimumRangesToMerge = 2;
    const unsortedMerged = ranges.length < minimumRangesToMerge
        ? ranges.length === 1
            ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                ranges[0]
            : parentRange
        : ranges.reduce(
        // eslint-disable-next-line complexity
        (merged, range) => ({
            ...(range.endLineNumber > merged.endLineNumber
                ? pluckEndPosition(range)
                : range.endLineNumber === merged.endLineNumber &&
                    range.endColumn > merged.endColumn
                    ? pluckEndPosition(range)
                    : pluckEndPosition(merged)),
            ...(range.startLineNumber < merged.startLineNumber
                ? pluckStartPosition(range)
                : range.startLineNumber === merged.startLineNumber &&
                    range.startColumn < merged.startColumn
                    ? pluckStartPosition(range)
                    : pluckStartPosition(merged)),
        }), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        ranges[0]);
    return {
        ...pluckEndPosition(unsortedMerged),
        ...pluckStartPosition(unsortedMerged),
    };
};
/**
 * Returns true if the `outerRange` fully contains the `innerRange`, otherwise,
 * `false`.
 *
 * @param outerRange - the bounds of the outer range
 * @param innerRange - the inner range to test
 * @param exclusive - disallow the `innerRange` from overlapping the
 * `outerRange` (such that the outer start and end columns may not be equal) –
 * defaults to `true`
 */
// eslint-disable-next-line complexity
const containsRange = (outerRange, innerRange, exclusive = true) => {
    const startsAfter = outerRange.startLineNumber < innerRange.startLineNumber
        ? true
        : outerRange.startLineNumber === innerRange.startLineNumber
            ? exclusive
                ? outerRange.startColumn < innerRange.startColumn
                : outerRange.startColumn <= innerRange.startColumn
            : false;
    const endsBefore = outerRange.endLineNumber > innerRange.endLineNumber
        ? true
        : outerRange.endLineNumber === innerRange.endLineNumber
            ? exclusive
                ? outerRange.endColumn > innerRange.endColumn
                : outerRange.endColumn >= innerRange.endColumn
            : false;
    return startsAfter && endsBefore;
};
/**
 * Extract a list of the errors that occurred while resolving a script.
 *
 * @param resolvedScript - the result of {@link resolveScript} from which to
 * extract errors
 */
const getResolutionErrors = (resolvedScript) => resolvedScript.reduce((errors, segment) => {
    switch (segment.type) {
        case 'error':
            return [
                ...errors,
                {
                    error: segment.value,
                    ...(segment.missingIdentifier === undefined
                        ? {}
                        : {
                            missingIdentifier: segment.missingIdentifier,
                            owningEntity: segment.owningEntity,
                        }),
                    range: segment.range,
                },
            ];
        case 'push':
        case 'evaluation':
            return [...errors, ...getResolutionErrors(segment.value)];
        default:
            return errors;
    }
}, []);
/**
 * Verify that every error in the provided array can be resolved by providing
 * additional variables in the compilation data (rather than deeper issues, like
 * problems with the wallet template or wallet implementation).
 *
 * Note, errors are only recoverable if the "entity ownership" of each missing
 * identifier is known (specified in `CompilationData`'s `entityOwnership`).
 *
 * @param errors - an array of compilation errors
 */
const allErrorsAreRecoverable = (errors) => errors.every((error) => 'missingIdentifier' in error && 'owningEntity' in error);
/**
 * Get an array of all resolutions used in a {@link ResolvedScript}.
 * @param resolvedScript - the resolved script to search
 */
const extractBytecodeResolutions = (resolvedScript) => 
// eslint-disable-next-line complexity
resolvedScript.reduce((all, segment) => {
    switch (segment.type) {
        case 'push':
        case 'evaluation':
            return [...all, ...extractBytecodeResolutions(segment.value)];
        case 'bytecode':
            if ('variable' in segment) {
                return [
                    ...all,
                    {
                        bytecode: segment.value,
                        text: segment.variable,
                        type: 'variable',
                    },
                ];
            }
            if ('script' in segment) {
                return [
                    ...all,
                    ...extractBytecodeResolutions(segment.source.resolve),
                    {
                        bytecode: segment.value,
                        text: segment.script,
                        type: 'script',
                    },
                ];
            }
            if ('opcode' in segment) {
                return [
                    ...all,
                    {
                        bytecode: segment.value,
                        text: segment.opcode,
                        type: 'opcode',
                    },
                ];
            }
            return [
                ...all,
                {
                    bytecode: segment.value,
                    text: segment.literal,
                    type: segment.literalType,
                },
            ];
        default:
            return all;
    }
}, []);
/**
 * Extract an object mapping the variable identifiers used in a
 * {@link ResolvedScript} to their resolved bytecode.
 *
 * @param resolvedScript - the resolved script to search
 */
const extractResolvedVariableBytecodeMap = (resolvedScript) => extractBytecodeResolutions(resolvedScript).reduce((all, resolution) => resolution.type === 'variable'
    ? { ...all, [resolution.text]: resolution.bytecode }
    : all, {});
/**
 * Format a list of {@link CompilationError}s into a single string, with an
 * error start position following each error. E.g. for line 1, column 2:
 * `The error message. [1, 2]`
 *
 * Errors are separated with the `separator`, which defaults to `; `, e.g.:
 * `The first error message. [1, 2]; The second error message. [3, 4]`
 *
 * @param errors - an array of compilation errors
 * @param separator - the characters with which to join the formatted errors.
 */
const stringifyErrors = (errors, separator = '; ') => errors
    .map((error) => `[${error.range.startLineNumber}, ${error.range.startColumn}] ${error.error}`)
    .join(separator);
/**
 * Extract a set of "evaluation samples" from the result of a CashAssembly
 * compilation and a matching debug trace (from `vm.debug`), pairing program
 * states with the source ranges that produced them – like a "source map" for
 * complete evaluations. This is useful for omniscient debuggers like
 * Bitauth IDE.
 *
 * Returns an array of samples and an array of unmatched program states
 * remaining if `nodes` doesn't contain enough instructions to consume all
 * program states provided in `trace`. Returned samples are ordered by the
 * ending position (line and column) of their range.
 *
 * If all program states are consumed before the available nodes are exhausted,
 * the remaining nodes are ignored (the produced samples end at the last
 * instruction for which a program state exists). This usually occurs when an
 * error halts evaluation before the end of the script. (Note: if this occurs,
 * the final trace state will not be used, as it is expected to be the
 * duplicated final result produced by `vm.debug`, and should not be matched
 * with the next instruction. The returned `unmatchedStates` will have a length
 * of `0`.)
 *
 * This method allows for samples to be extracted from a single evaluation;
 * most applications should use
 * {@link extractEvaluationSamplesRecursive} instead.
 *
 * @remarks
 * This method incrementally concatenates the reduced bytecode from each node,
 * parsing the result into evaluation samples.
 *
 * Each node can contain only a portion of an instruction (like a long push
 * operation), or it can contain multiple instructions (like a long hex literal
 * representing a string of bytecode or an evaluation that is not wrapped by a
 * push).
 *
 * If a node contains only a portion of an instruction, the bytecode from
 * additional nodes are concatenated (and ranges merged) until an instruction
 * can be created. If any bytecode remains after a sample has been created, the
 * next sample begins in the same range. (For this reason, it's possible that
 * samples overlap.)
 *
 * If a node contains more than one instruction, the intermediate states
 * produced before the final state for that sample are saved to the sample's
 * `intermediateStates` array.
 *
 * If the program states in `trace` are exhausted before the final instruction
 * in a sample (usually caused by an evaluation error), the last instruction
 * with a matching program state is used for the sample (with its program
 * state), and the unmatched instructions are ignored. (This allows the "last
 * known state" to be displayed for the sample that caused evaluation to halt.)
 *
 * ---
 *
 * For example, the following script demonstrates many of these cases:
 *
 * `0x00 0x01 0xab01 0xcd9300 $(OP_3 <0x00> OP_SWAP OP_CAT) 0x010203`
 *
 * Which compiles to `0x0001ab01cd93000003010203`, disassembled:
 *
 * `OP_0 OP_PUSHBYTES_1 0xab OP_PUSHBYTES_1 0xcd OP_ADD OP_0 OP_0 OP_PUSHBYTES_3 0x010203`
 *
 * In the script, there are 6 top-level nodes (identified below within `[]`):
 *
 * `[0x00] [0x01] [0xab01] [0xcd9300] [$(OP_3 <0x00> OP_SWAP OP_CAT)] [0x010203]`
 *
 * These nodes together encode 7 instructions, some within a single node, and
 * some split between several nodes. Below we substitute the evaluation for its
 * result `0x0003` to group instructions by `[]`:
 *
 * `[0x00] [0x01 0xab][01 0xcd][93][00] [0x00][03 0x010203]`
 *
 * The "resolution" of samples is limited to the range of single nodes: nodes
 * cannot always be introspected to determine where contained instructions begin
 * and end. For example, it is ambiguous which portions of the evaluation are
 * responsible for the initial `0x00` and which are responsible for the `0x03`.
 *
 * For this reason, the range of each sample is limited to the range(s) of one
 * or more adjacent nodes. Samples may overlap in the range of a node that is
 * responsible for both ending a previous sample and beginning a new sample.
 * (Though, only 2 samples can overlap. If a node is responsible for more than 2
 * instructions, the second sample includes `internalStates` for instructions
 * that occur before the end of the second sample.)
 *
 * In this case, there are 6 samples identified below within `[]`, where each
 * `[` is closed by the closest following `]` (no nesting):
 *
 * `[0x00] [0x01 [0xab01] [0xcd9300]] [[$(OP_3 <0x00> OP_SWAP OP_CAT)] 0x010203]`
 *
 * The ranges for each sample (in terms of nodes) are as follows:
 * - Sample 1: node 1
 * - Sample 2: node 2 + node 3
 * - Sample 3: node 3 + node 4
 * - Sample 4: node 4
 * - Sample 5: node 5
 * - Sample 6: node 5 + node 6
 *
 * Note that the following samples overlap:
 * - Sample 2 and Sample 3
 * - Sample 3 and Sample 4
 * - Sample 5 and Sample 6
 *
 * Finally, note that Sample 4 will have one internal state produced by the
 * `OP_ADD` instruction. Sample 4 then ends with the `OP_0` (`0x00`) instruction
 * at the end of the `0xcd9300` node.
 *
 * ---
 *
 * Note, this implementation relies on the expectation that `trace` begins with
 * the initial program state, contains a single program state per instruction,
 * and ends with the final program state (as produced by `vm.debug`). It also
 * expects the `bytecode` provided by nodes to be parsable by
 * {@link decodeAuthenticationInstructions}.
 */
// eslint-disable-next-line complexity
const extractEvaluationSamples = ({ evaluationRange, nodes, trace, }) => {
    const traceWithoutFinalState = trace.length > 1 ? trace.slice(0, -1) : trace.slice();
    if (traceWithoutFinalState.length === 0) {
        return {
            samples: [],
            unmatchedStates: [],
        };
    }
    const samples = [
        {
            evaluationRange,
            internalStates: [],
            range: {
                endColumn: evaluationRange.startColumn,
                endLineNumber: evaluationRange.startLineNumber,
                startColumn: evaluationRange.startColumn,
                startLineNumber: evaluationRange.startLineNumber,
            },
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            state: traceWithoutFinalState[0],
        },
    ];
    // eslint-disable-next-line functional/no-let
    let nextState = 1;
    // eslint-disable-next-line functional/no-let
    let nextNode = 0;
    // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
    let incomplete;
    // eslint-disable-next-line functional/no-loop-statements
    while (nextState < traceWithoutFinalState.length && nextNode < nodes.length) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const currentNode = nodes[nextNode];
        const { mergedBytecode, mergedRange } = incomplete === undefined
            ? {
                mergedBytecode: currentNode.bytecode,
                mergedRange: currentNode.range,
            }
            : {
                mergedBytecode: flattenBinArray([
                    incomplete.bytecode,
                    currentNode.bytecode,
                ]),
                mergedRange: mergeRanges([incomplete.range, currentNode.range]),
            };
        const decoded = decodeAuthenticationInstructions(mergedBytecode);
        const [zeroth] = decoded;
        const hasNonMalformedInstructions = zeroth !== undefined && !('malformed' in zeroth);
        if (hasNonMalformedInstructions) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const lastInstruction = decoded[decoded.length - 1];
            const validInstructions = authenticationInstructionIsMalformed(lastInstruction)
                ? decoded.slice(0, decoded.length - 1)
                : decoded;
            const firstUnmatchedStateIndex = nextState + validInstructions.length;
            const matchingStates = traceWithoutFinalState.slice(nextState, firstUnmatchedStateIndex);
            const pairedStates = validInstructions.map((instruction, index) => ({
                instruction,
                state: matchingStates[index],
            }));
            /**
             * Guaranteed to have a defined `state` (or the loop would have exited).
             */
            const firstPairedState = pairedStates[0];
            const closesCurrentlyOpenSample = incomplete !== undefined;
            // eslint-disable-next-line functional/no-conditional-statements
            if (closesCurrentlyOpenSample) {
                // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
                samples.push({
                    evaluationRange,
                    instruction: firstPairedState.instruction,
                    internalStates: [],
                    range: mergedRange,
                    state: firstPairedState.state,
                });
            }
            const firstUndefinedStateIndex = pairedStates.findIndex(({ state }) => state === undefined);
            const sampleHasError = firstUndefinedStateIndex !== -1;
            const sampleClosingIndex = sampleHasError
                ? firstUndefinedStateIndex - 1
                : pairedStates.length - 1;
            const closesASecondSample = !closesCurrentlyOpenSample || sampleClosingIndex > 0;
            // eslint-disable-next-line functional/no-conditional-statements
            if (closesASecondSample) {
                const finalState = pairedStates[sampleClosingIndex];
                const secondSamplePairsBegin = closesCurrentlyOpenSample ? 1 : 0;
                const internalStates = pairedStates.slice(secondSamplePairsBegin, sampleClosingIndex);
                // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
                samples.push({
                    evaluationRange,
                    instruction: finalState.instruction,
                    internalStates,
                    range: currentNode.range,
                    state: finalState.state,
                });
            }
            // eslint-disable-next-line functional/no-expression-statements
            nextState = firstUnmatchedStateIndex;
            // eslint-disable-next-line functional/no-conditional-statements
            if (authenticationInstructionIsMalformed(lastInstruction)) {
                // eslint-disable-next-line functional/no-expression-statements
                incomplete = {
                    bytecode: encodeAuthenticationInstructionMalformed(lastInstruction),
                    range: currentNode.range,
                };
                // eslint-disable-next-line functional/no-conditional-statements
            }
            else {
                // eslint-disable-next-line functional/no-expression-statements
                incomplete = undefined;
            }
            // eslint-disable-next-line functional/no-conditional-statements
        }
        else {
            const lastInstruction = decoded[decoded.length - 1];
            // eslint-disable-next-line functional/no-expression-statements
            incomplete =
                lastInstruction === undefined
                    ? undefined
                    : {
                        bytecode: encodeAuthenticationInstructionMalformed(lastInstruction),
                        range: mergedRange,
                    };
        }
        // eslint-disable-next-line functional/no-expression-statements
        nextNode += 1;
    }
    /**
     * Because we ran out of `trace` states before all `nodes` were matched, we
     * know an error occurred which halted evaluation. This error is indicated in
     * the result by returning an empty array of `unmatchedStates`. Successful
     * evaluations will always return at least one unmatched state: the final
     * "evaluation result" state produced by `vm.debug`.
     */
    const errorOccurred = nextNode < nodes.length;
    const unmatchedStates = errorOccurred
        ? []
        : trace.slice(nextState);
    return {
        samples,
        unmatchedStates,
    };
};
/**
 * Similar to {@link extractEvaluationSamples}, but recursively extracts samples
 * from evaluations within the provided array of nodes.
 *
 * Because CashAssembly evaluations are fully self-contained, there should never
 * be unmatched states from evaluations within a script reduction trace tree.
 * (For this reason, this method does not return the `unmatchedStates` from
 * nested evaluations.)
 *
 * Returned samples are ordered by the ending position (line and column) of
 * their range. Samples from CashAssembly evaluations that occur within an
 * outer evaluation appear before their parent sample (which uses their result).
 */
const extractEvaluationSamplesRecursive = ({ 
/**
 * The range of the script node that was evaluated to produce the `trace`
 */
evaluationRange, 
/**
 * An array of reduced nodes to parse
 */
nodes, 
/**
 * The `vm.debug` result to map to these nodes
 */
trace, }) => {
    const extractEvaluations = (node, depth = 1) => {
        if ('push' in node) {
            return node.push.script.reduce((all, childNode) => [...all, ...extractEvaluations(childNode, depth)], []);
        }
        if ('source' in node) {
            const childSamples = node.source.script.reduce((all, childNode) => [
                ...all,
                ...extractEvaluations(childNode, depth + 1),
            ], []);
            const traceWithoutUnlockingPhase = node.trace.slice(1);
            const evaluationBeginToken = '$(';
            const evaluationEndToken = ')';
            const extracted = extractEvaluationSamples({
                evaluationRange: {
                    endColumn: node.range.endColumn - evaluationEndToken.length,
                    endLineNumber: node.range.endLineNumber,
                    startColumn: node.range.startColumn + evaluationBeginToken.length,
                    startLineNumber: node.range.startLineNumber,
                },
                nodes: node.source.script,
                trace: traceWithoutUnlockingPhase,
            });
            return [...extracted.samples, ...childSamples];
        }
        return [];
    };
    const { samples, unmatchedStates } = extractEvaluationSamples({
        evaluationRange,
        nodes,
        trace,
    });
    const childSamples = nodes.reduce((all, node) => [...all, ...extractEvaluations(node)], []);
    const endingOrderedSamples = [...samples, ...childSamples].sort((a, b) => {
        const linesOrdered = a.range.endLineNumber - b.range.endLineNumber;
        return linesOrdered === 0
            ? a.range.endColumn - b.range.endColumn
            : linesOrdered;
    });
    return {
        samples: endingOrderedSamples,
        unmatchedStates,
    };
};
const stateIsExecuting = (state) => state.controlStack.every((item) => item !== false);
/**
 * Extract an array of ranges that were unused by an evaluation. This is useful
 * in development tooling for fading out or hiding code that is unimportant to
 * the current evaluation being tested.
 *
 * @remarks
 * Only ranges that are guaranteed to be unimportant to an evaluation are
 * returned by this method. These ranges are extracted from samples that:
 * - are preceded by a sample that ends with execution disabled (e.g. an
 * unsuccessful `OP_IF`)
 * - end with execution disabled, and
 * - contain no `internalStates` that enable execution.
 *
 * Note, internal states that temporarily re-enable and then disable execution
 * again can still have an effect on the parent evaluation, so this method
 * conservatively excludes such samples. For example, the hex literal
 * `0x675167`, which encodes `OP_ELSE OP_1 OP_ELSE`, could begin and end with
 * states in which execution is disabled, yet a `1` is pushed to the stack
 * during the sample's evaluation. (Samples like this are unusual, and can
 * almost always be reformatted to clearly separate the executed and unexecuted
 * instructions.)
 *
 * @param samples - an array of samples ordered by the ending position (line and
 * column) of their range.
 * @param evaluationBegins - the line and column at which the initial sample's
 * evaluation range begins (where the preceding state is assumed to be
 * executing), defaults to `1,1`
 */
const extractUnexecutedRanges = (samples, evaluationBegins = '1,1') => {
    const reduced = samples.reduce((all, sample) => {
        const { precedingStateSkipsByEvaluation, unexecutedRanges } = all;
        const currentEvaluationStartLineAndColumn = `${sample.evaluationRange.startLineNumber},${sample.evaluationRange.startColumn}`;
        const precedingStateSkips = 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        precedingStateSkipsByEvaluation[currentEvaluationStartLineAndColumn];
        const endsWithSkip = !stateIsExecuting(sample.state);
        const sampleHasNoExecutedInstructions = endsWithSkip &&
            sample.internalStates.every((group) => !stateIsExecuting(group.state));
        if (precedingStateSkips && sampleHasNoExecutedInstructions) {
            return {
                precedingStateSkipsByEvaluation: {
                    ...precedingStateSkipsByEvaluation,
                    [currentEvaluationStartLineAndColumn]: true,
                },
                unexecutedRanges: [...unexecutedRanges, sample.range],
            };
        }
        return {
            precedingStateSkipsByEvaluation: {
                ...precedingStateSkipsByEvaluation,
                [currentEvaluationStartLineAndColumn]: endsWithSkip,
            },
            unexecutedRanges,
        };
    }, {
        precedingStateSkipsByEvaluation: {
            [evaluationBegins]: false,
        },
        unexecutedRanges: [],
    });
    const canHaveContainedRanges = 2;
    const containedRangesExcluded = reduced.unexecutedRanges.length < canHaveContainedRanges
        ? reduced.unexecutedRanges
        : reduced.unexecutedRanges.slice(0, -1).reduceRight((all, range) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (containsRange(all[0], range)) {
                return all;
            }
            return [range, ...all];
        }, 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        [reduced.unexecutedRanges[reduced.unexecutedRanges.length - 1]]);
    return containedRangesExcluded;
};
/**
 * Given a stack, return a summary of the stack's contents, encoding valid VM
 * numbers as numbers, and all other stack items as hex literals.
 *
 * @param stack - a stack of Uint8Array values
 */
const summarizeStack = (stack) => stack.map((item) => {
    const asNumber = vmNumberToBigInt(item);
    return `0x${binToHex(item)}${typeof asNumber === 'string' ? '' : `(${asNumber.toString()})`}`;
});
/**
 * Given a debug trace (produced by {@link AuthenticationVirtualMachine.debug}),
 * return an array summarizing each step of the trace. Note, debug traces
 * include the full program state at the beginning of each evaluation step; the
 * summary produced by this method instead shows the resulting stacks after each
 * evaluation step.
 */
const summarizeDebugTrace = (trace) => trace.reduce(
// eslint-disable-next-line @typescript-eslint/max-params
(steps, state, stateIndex, states) => {
    const nextState = states[stateIndex + 1];
    return nextState === undefined
        ? steps
        : [
            ...steps,
            {
                alternateStack: summarizeStack(nextState.alternateStack),
                ...(nextState.error === undefined
                    ? {}
                    : { error: nextState.error }),
                execute: state.controlStack[state.controlStack.length - 1] !== false,
                instruction: state.instructions[state.ip],
                ip: state.ip,
                stack: summarizeStack(nextState.stack),
            },
        ];
}, []);
const reasonablePaddingForInstructionSetBCH = 23;
/**
 * Return a string with the result of {@link summarizeDebugTrace} including one
 * step per line.
 *
 * @param summary - a summary produced by {@link summarizeDebugTrace}
 */
const stringifyDebugTraceSummary = (summary, { opcodes = OpcodesBCHCHIPs, padInstruction = reasonablePaddingForInstructionSetBCH, } = {}) => summary
    .map(
// eslint-disable-next-line complexity
(line) => `${(line.instruction === undefined
    ? '=>'
    : `${line.ip}. ${line.execute ? '' : '(skip)'}${opcodes[line.instruction.opcode] ??
        `OP_UNKNOWN${line.instruction.opcode}`}:`).padEnd(padInstruction)} ${typeof line.error === 'string'
    ? line.error
    : `${line.stack.join(' ')}${line.alternateStack.length === 0
        ? ''
        : `| alt: ${line.alternateStack.join(' ')}`}`}`)
    .join('\n');

/**
 * This file is derived from https://github.com/jneen/parsimmon and
 * https://github.com/DefinitelyTyped/DefinitelyTyped.
 */
/* eslint-disable @typescript-eslint/unified-signatures, functional/prefer-property-signatures, functional/no-throw-statements, functional/no-conditional-statements, @typescript-eslint/no-this-alias, consistent-this, @typescript-eslint/ban-ts-comment, prefer-spread, func-names, @typescript-eslint/init-declarations, new-cap, guard-for-in, no-plusplus, functional/no-let, functional/no-loop-statements, @typescript-eslint/prefer-for-of, functional/immutable-data, @typescript-eslint/no-use-before-define, @typescript-eslint/strict-boolean-expressions, no-param-reassign, functional/no-expression-statements, functional/no-this-expressions, @typescript-eslint/no-explicit-any, func-style, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-return, @typescript-eslint/naming-convention, @typescript-eslint/method-signature-style, @typescript-eslint/no-confusing-void-expression, prefer-arrow-callback, functional/no-return-void, @typescript-eslint/no-unsafe-argument, functional/functional-parameters */
// cspell: ignore accum
function Parsimmon(action) {
    // @ts-expect-error
    if (!(this instanceof Parsimmon)) {
        // @ts-expect-error
        return new Parsimmon(action);
    }
    // @ts-expect-error
    this._ = action;
}
const _ = Parsimmon.prototype;
// -*- Helpers -*-
function makeSuccess(index, value) {
    return {
        expected: [],
        furthest: -1,
        index,
        status: true,
        value,
    };
}
function makeFailure(index, expected) {
    expected = [expected];
    return {
        expected,
        furthest: index,
        index: -1,
        status: false,
        value: null,
    };
}
function mergeReplies(result, last) {
    if (!last) {
        return result;
    }
    if (result.furthest > last.furthest) {
        return result;
    }
    const expected = result.furthest === last.furthest
        ? union(result.expected, last.expected)
        : last.expected;
    return {
        expected,
        furthest: last.furthest,
        index: result.index,
        status: result.status,
        value: result.value,
    };
}
function makeLineColumnIndex(input, i) {
    const lines = input.slice(0, i).split('\n');
    /*
     * Note that unlike the character offset, the line and column offsets are
     * 1-based.
     */
    const lineWeAreUpTo = lines.length;
    const columnWeAreUpTo = lines[lines.length - 1].length + 1;
    return {
        column: columnWeAreUpTo,
        line: lineWeAreUpTo,
        offset: i,
    };
}
// Returns the sorted set union of two arrays of strings
function union(xs, ys) {
    const obj = {};
    for (let i = 0; i < xs.length; i++) {
        // @ts-expect-error
        obj[xs[i]] = true;
    }
    for (let j = 0; j < ys.length; j++) {
        // @ts-expect-error
        obj[ys[j]] = true;
    }
    const keys = [];
    for (const k in obj) {
        keys.push(k);
    }
    keys.sort();
    return keys;
}
// -*- Error Formatting -*-
function flags(re) {
    const s = String(re);
    return s.slice(s.lastIndexOf('/') + 1);
}
function anchoredRegexp(re) {
    return RegExp(`^(?:${re.source})`, flags(re));
}
// -*- Combinators -*-
function seq(...params) {
    const parsers = [].slice.call(params);
    const numParsers = parsers.length;
    return Parsimmon(function (input, i) {
        let result;
        const accum = new Array(numParsers);
        for (let j = 0; j < numParsers; j += 1) {
            result = mergeReplies(parsers[j]._(input, i), result);
            if (!result.status) {
                return result;
            }
            accum[j] = result.value;
            i = result.index;
        }
        return mergeReplies(makeSuccess(i, accum), result);
    });
}
function seqMap(...params) {
    const args = [].slice.call(params);
    const mapper = args.pop();
    return seq.apply(null, args).map(function (results) {
        // @ts-expect-error
        return mapper.apply(null, results);
    });
}
function createLanguage(parsers) {
    const language = {};
    for (const key in parsers) {
        (function (rule) {
            const func = function () {
                // @ts-expect-error
                return parsers[rule](language);
            };
            // @ts-expect-error
            language[rule] = lazy(func);
        })(key);
    }
    return language;
}
function alt(...params) {
    const parsers = [].slice.call(params);
    return Parsimmon(function (input, i) {
        let result;
        for (let j = 0; j < parsers.length; j += 1) {
            result = mergeReplies(parsers[j]._(input, i), result);
            if (result.status) {
                return result;
            }
        }
        return result;
    });
}
function sepBy(parser, separator) {
    return sepBy1(parser, separator).or(succeed([]));
}
function sepBy1(parser, separator) {
    const pairs = separator.then(parser).many();
    return seqMap(parser, pairs, function (r, rs) {
        return [r].concat(rs);
    });
}
// -*- Core Parsing Methods -*-
_.parse = function (input) {
    const result = this.skip(eof)._(input, 0);
    if (result.status) {
        return {
            status: true,
            value: result.value,
        };
    }
    return {
        expected: result.expected,
        index: makeLineColumnIndex(input, result.furthest),
        status: false,
    };
};
// -*- Other Methods -*-
_.or = function (alternative) {
    return alt(this, alternative);
};
_.then = function (next) {
    return seq(this, next).map(function (results) {
        return results[1];
    });
};
_.many = function () {
    const self = this;
    return Parsimmon(function (input, i) {
        const accum = [];
        let result;
        for (;;) {
            result = mergeReplies(self._(input, i), result);
            if (result.status) {
                /* c8 ignore next 6 */
                if (i === result.index) {
                    throw new Error('infinite loop detected in .many() parser --- calling .many() on ' +
                        'a parser that can accept zero characters is usually the cause');
                }
                i = result.index;
                accum.push(result.value);
            }
            else {
                return mergeReplies(makeSuccess(i, accum), result);
            }
        }
    });
};
_.map = function (fn) {
    const self = this;
    return Parsimmon(function (input, i) {
        const result = self._(input, i);
        if (!result.status) {
            return result;
        }
        return mergeReplies(makeSuccess(result.index, fn(result.value)), result);
    });
};
_.skip = function (next) {
    return seq(this, next).map(function (results) {
        return results[0];
    });
};
_.node = function (name) {
    return seqMap(index, this, index, function (start, value, end) {
        return {
            end,
            name,
            start,
            value,
        };
    });
};
_.sepBy = function (separator) {
    return sepBy(this, separator);
};
_.desc = function (expected) {
    expected = [expected];
    const self = this;
    return Parsimmon(function (input, i) {
        const reply = self._(input, i);
        if (!reply.status) {
            reply.expected = expected;
        }
        return reply;
    });
};
// -*- Constructors -*-
function string(str) {
    const expected = `'${str}'`;
    return Parsimmon(function (input, i) {
        const j = i + str.length;
        const head = input.slice(i, j);
        if (head === str) {
            return makeSuccess(j, head);
        }
        return makeFailure(i, expected);
    });
}
function regexp(re, group = 0) {
    const anchored = anchoredRegexp(re);
    const expected = String(re);
    return Parsimmon(function (input, i) {
        const match = anchored.exec(input.slice(i));
        if (match) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const fullMatch = match[0];
            const groupMatch = match[group];
            return makeSuccess(i + fullMatch.length, groupMatch);
        }
        return makeFailure(i, expected);
    });
}
function succeed(value) {
    return Parsimmon(function (__, i) {
        return makeSuccess(i, value);
    });
}
function lazy(f) {
    const parser = Parsimmon(function (input, i) {
        parser._ = f()._;
        return parser._(input, i);
    });
    return parser;
}
// -*- Base Parsers -*-
const index = Parsimmon(function (input, i) {
    return makeSuccess(i, makeLineColumnIndex(input, i));
});
const eof = Parsimmon(function (input, i) {
    if (i < input.length) {
        return makeFailure(i, 'EOF');
    }
    return makeSuccess(i, null);
});
const optWhitespace = regexp(/\s*/u).desc('optional whitespace');
const whitespace = regexp(/\s+/u).desc('whitespace');
const P = {
    alt,
    createLanguage,
    index,
    lazy,
    makeFailure,
    makeSuccess,
    of: succeed,
    optWhitespace,
    regexp,
    sepBy,
    sepBy1,
    seq,
    seqMap,
    string,
    succeed,
    whitespace,
};

/* eslint-disable sort-keys, @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
const cashAssemblyParser = P.createLanguage({
    script: (r) => P.seqMap(P.optWhitespace, r.expression.sepBy(P.optWhitespace), P.optWhitespace, (_, expressions) => expressions).node('Script'),
    expression: (r) => P.alt(r.comment, r.push, r.evaluation, r.utf8, r.binary, r.hex, r.bigint, r.identifier),
    comment: (r) => P.alt(r.singleLineComment, r.multiLineComment).node('Comment'),
    singleLineComment: () => P.seqMap(P.string('//').desc("the start of a single-line comment ('//')"), P.regexp(/[^\n]*/u), (__, comment) => comment.trim()),
    multiLineComment: () => P.seqMap(P.string('/*').desc("the start of a multi-line comment ('/*')"), P.regexp(/[\s\S]*?\*\//u).desc("the end of this multi-line comment ('*/')"), (__, comment) => comment.slice(0, -'*/'.length).trim()),
    push: (r) => P.seqMap(P.string('<').desc("the start of a push statement ('<')"), r.script, P.string('>').desc("the end of this push statement ('>')"), (_, push) => push).node('Push'),
    evaluation: (r) => P.seqMap(P.string('$').desc("the start of an evaluation ('$')"), P.string('(').desc("the opening parenthesis of this evaluation ('(')"), r.script, P.string(')').desc("the closing parenthesis of this evaluation (')')"), (_, __, evaluation) => evaluation).node('Evaluation'),
    identifier: () => P.regexp(/[a-zA-Z_][.a-zA-Z0-9_-]*/u)
        .desc('a valid identifier')
        .node('Identifier'),
    utf8: () => P.alt(P.seqMap(P.string('"').desc('a double quote (")'), P.regexp(/[^"]*/u), P.string('"').desc('a closing double quote (")'), (__, literal) => literal), P.seqMap(P.string("'").desc("a single quote (')"), P.regexp(/[^']*/u), P.string("'").desc("a closing single quote (')"), (__, literal) => literal)).node('UTF8Literal'),
    hex: () => P.seqMap(P.string('0x').desc("a hex literal ('0x...')"), P.regexp(/[0-9a-f]_*(?:_*[0-9a-f]_*[0-9a-f]_*)*[0-9a-f]/iu).desc('a valid hexadecimal string'), (__, literal) => literal).node('HexLiteral'),
    binary: () => P.seqMap(P.string('0b').desc("a binary literal ('0b...')"), P.regexp(/[01]+(?:[01_]*[01]+)*/iu).desc('a string of binary digits'), (__, literal) => literal).node('BinaryLiteral'),
    bigint: () => P.regexp(/-?[0-9]+(?:[0-9_]*[0-9]+)*/u)
        .desc('an integer literal')
        .node('BigIntLiteral'),
});
/* eslint-enable sort-keys, @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
const parseScript = (script) => cashAssemblyParser.script.parse(lossyNormalize(script));

const emptyReductionTraceNode = (range) => ({
    bytecode: Uint8Array.of(),
    range,
});
/**
 * Perform the standard verification of CashAssembly evaluation results. This
 * ensures that evaluations complete as expected: if an error occurs while
 * computing an evaluation, script compilation should fail.
 *
 * Three requirements are enforced:
 * - the evaluation may not produce an `error`
 * - the resulting stack must contain exactly 1 item
 * - the resulting execution stack must be empty (no missing `OP_ENDIF`s)
 *
 * This differs from the virtual machine's built-in `vm.verify` in that it is
 * often more lenient, for example, evaluations can succeed with a non-truthy
 * value on top of the stack.
 *
 * @param state - the final program state to verify
 */
const verifyCashAssemblyEvaluationState = (state) => {
    if (state.error !== undefined) {
        return state.error;
    }
    if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
    }
    if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
    }
    return true;
};
/**
 * Reduce a resolved script, returning the resulting bytecode and a trace of the
 * reduction process.
 *
 * This method will return an error if provided a {@link resolvedScript} with
 * resolution errors. To check for resolution errors, use
 * {@link getResolutionErrors}.
 *
 * @param resolvedScript - the {@link CompiledScript} to reduce
 * @param vm - the {@link AuthenticationVirtualMachine} to use for evaluations
 * @param createEvaluationProgram - a method which accepts the compiled bytecode
 * of an evaluation and returns the authentication program used to evaluate it
 */
const reduceScript = (resolvedScript, vm, createEvaluationProgram) => {
    const script = resolvedScript.map((segment) => {
        switch (segment.type) {
            case 'bytecode':
                return { bytecode: segment.value, range: segment.range };
            case 'push': {
                const push = reduceScript(segment.value, vm, createEvaluationProgram);
                const bytecode = encodeDataPush(push.bytecode);
                return {
                    bytecode,
                    ...(push.errors === undefined ? undefined : { errors: push.errors }),
                    push,
                    range: segment.range,
                };
            }
            case 'evaluation': {
                if (typeof vm === 'undefined' ||
                    typeof createEvaluationProgram === 'undefined') {
                    return {
                        errors: [
                            {
                                error: 'Both a VM and a createState method are required to reduce evaluations.',
                                range: segment.range,
                            },
                        ],
                        ...emptyReductionTraceNode(segment.range),
                    };
                }
                const reductionTrace = reduceScript(segment.value, vm, createEvaluationProgram);
                if (reductionTrace.errors !== undefined) {
                    return {
                        ...emptyReductionTraceNode(segment.range),
                        errors: reductionTrace.errors,
                        source: reductionTrace,
                        trace: [],
                    };
                }
                const trace = vm.debug(createEvaluationProgram(reductionTrace.bytecode));
                /**
                 * `vm.debug` should always return at least one state.
                 */
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const lastState = trace[trace.length - 1];
                const result = verifyCashAssemblyEvaluationState(lastState);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const bytecode = lastState.stack[lastState.stack.length - 1];
                return {
                    ...(typeof result === 'string'
                        ? {
                            bytecode: Uint8Array.of(),
                            errors: [
                                {
                                    error: `Failed to reduce evaluation: ${result}`,
                                    range: segment.range,
                                },
                            ],
                        }
                        : {
                            bytecode,
                        }),
                    range: segment.range,
                    source: reductionTrace,
                    trace,
                };
            }
            case 'comment':
                return emptyReductionTraceNode(segment.range);
            case 'error':
                return {
                    errors: [
                        {
                            error: `Tried to reduce a CashAssembly script with resolution errors: ${segment.value}`,
                            range: segment.range,
                        },
                    ],
                    ...emptyReductionTraceNode(segment.range),
                };
            default:
                // eslint-disable-next-line functional/no-throw-statements, @typescript-eslint/no-throw-literal
                throw new Error(`"${segment.type}" is not a known segment type.`);
        }
    });
    const reduction = script.reduce((all, segment) => ({
        bytecode: [...all.bytecode, segment.bytecode],
        ranges: [...all.ranges, segment.range],
        ...(all.errors !== undefined || segment.errors !== undefined
            ? {
                errors: [...(all.errors ?? []), ...(segment.errors ?? [])],
            }
            : undefined),
    }), { bytecode: [], ranges: [] });
    return {
        ...(reduction.errors === undefined
            ? undefined
            : { errors: reduction.errors }),
        bytecode: flattenBinArray(reduction.bytecode),
        range: mergeRanges(reduction.ranges, 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        resolvedScript.length === 0 ? undefined : resolvedScript[0].range),
        script,
    };
};

const pluckRange = (node) => ({
    endColumn: node.end.column,
    endLineNumber: node.end.line,
    startColumn: node.start.column,
    startLineNumber: node.start.line,
});
const removeNumericSeparators = (numericLiteral) => numericLiteral.replace(/_/gu, '');
const resolveScriptSegment = (segment, resolveIdentifiers) => {
    // eslint-disable-next-line complexity
    const resolved = segment.value.map((child) => {
        const range = pluckRange(child);
        switch (child.name) {
            case 'Identifier': {
                const identifier = child.value;
                const result = resolveIdentifiers(identifier);
                const ret = result.status
                    ? {
                        range,
                        type: 'bytecode',
                        value: result.bytecode,
                        ...(result.type === IdentifierResolutionType.opcode
                            ? {
                                opcode: identifier,
                            }
                            : result.type === IdentifierResolutionType.variable
                                ? {
                                    ...('debug' in result ? { debug: result.debug } : {}),
                                    ...('signature' in result
                                        ? { signature: result.signature }
                                        : {}),
                                    variable: identifier,
                                }
                                : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                                    result.type === IdentifierResolutionType.script
                                        ? { script: identifier, source: result.source }
                                        : { unknown: identifier }),
                    }
                    : {
                        ...('debug' in result ? { debug: result.debug } : {}),
                        ...('recoverable' in result && result.recoverable
                            ? {
                                missingIdentifier: identifier,
                                owningEntity: result.entityOwnership,
                            }
                            : {}),
                        range,
                        type: 'error',
                        value: result.error,
                    };
                return ret;
            }
            case 'Push':
                return {
                    range,
                    type: 'push',
                    value: resolveScriptSegment(child.value, resolveIdentifiers),
                };
            case 'Evaluation':
                return {
                    range,
                    type: 'evaluation',
                    value: resolveScriptSegment(child.value, resolveIdentifiers),
                };
            case 'BigIntLiteral':
                return {
                    literal: child.value,
                    literalType: 'BigIntLiteral',
                    range,
                    type: 'bytecode',
                    value: bigIntToVmNumber(BigInt(removeNumericSeparators(child.value))),
                };
            case 'BinaryLiteral':
                return {
                    literal: child.value,
                    literalType: 'BinaryLiteral',
                    range,
                    type: 'bytecode',
                    value: binStringToBin(removeNumericSeparators(child.value)),
                };
            case 'HexLiteral':
                return {
                    literal: child.value,
                    literalType: 'HexLiteral',
                    range,
                    type: 'bytecode',
                    value: hexToBin(removeNumericSeparators(child.value)),
                };
            case 'UTF8Literal':
                return {
                    literal: child.value,
                    literalType: 'UTF8Literal',
                    range,
                    type: 'bytecode',
                    value: utf8ToBin(child.value),
                };
            case 'Comment':
                return {
                    range,
                    type: 'comment',
                    value: child.value,
                };
            default:
                return {
                    range,
                    type: 'error',
                    value: `Unrecognized segment: ${child.name}`,
                };
        }
    });
    return resolved.length === 0
        ? [{ range: pluckRange(segment), type: 'comment', value: '' }]
        : resolved;
};
var BuiltInVariables;
(function (BuiltInVariables) {
    BuiltInVariables["currentBlockTime"] = "current_block_time";
    BuiltInVariables["currentBlockHeight"] = "current_block_height";
    BuiltInVariables["signingSerialization"] = "signing_serialization";
})(BuiltInVariables || (BuiltInVariables = {}));
const attemptCompilerOperation = ({ data, configuration, identifier, matchingOperations, operationExample = 'operation_identifier', operationId, variableId, variableType, }) => {
    if (matchingOperations === undefined) {
        return {
            error: `The "${variableId}" variable type can not be resolved because the "${variableType}" operation has not been included in this compiler's configuration.`,
            status: 'error',
        };
    }
    if (typeof matchingOperations === 'function') {
        const operation = matchingOperations;
        return operation(identifier, data, configuration);
    }
    if (operationId === undefined) {
        return {
            error: `This "${variableId}" variable could not be resolved because this compiler's "${variableType}" operations require an operation identifier, e.g. '${variableId}.${operationExample}'.`,
            status: 'error',
        };
    }
    const operation = matchingOperations[operationId];
    if (operation === undefined) {
        return {
            error: `The identifier "${identifier}" could not be resolved because the "${variableId}.${operationId}" operation is not available to this compiler.`,
            status: 'error',
        };
    }
    return operation(identifier, data, configuration);
};
/**
 * If the identifier can be successfully resolved as a variable, the result is
 * returned as a Uint8Array. If the identifier references a known variable, but
 * an error occurs in resolving it, the error is returned as a string.
 * Otherwise, the identifier is not recognized as a variable, and this method
 * simply returns `false`.
 *
 * @param identifier - The full identifier used to describe this operation, e.g.
 * `owner.schnorr_signature.all_outputs`.
 * @param data - The {@link CompilationData} provided to the compiler
 * @param configuration - The {@link CompilerConfiguration} provided to
 * the compiler
 */
const resolveVariableIdentifier = ({ data, configuration, identifier, }) => {
    const [variableId, operationId] = identifier.split('.');
    switch (variableId) {
        case BuiltInVariables.currentBlockHeight:
            return attemptCompilerOperation({
                configuration,
                data,
                identifier,
                matchingOperations: configuration.operations?.currentBlockHeight,
                operationId,
                variableId,
                variableType: 'currentBlockHeight',
            });
        case BuiltInVariables.currentBlockTime:
            return attemptCompilerOperation({
                configuration,
                data,
                identifier,
                matchingOperations: configuration.operations?.currentBlockTime,
                operationId,
                variableId,
                variableType: 'currentBlockTime',
            });
        case BuiltInVariables.signingSerialization:
            return attemptCompilerOperation({
                configuration,
                data,
                identifier,
                matchingOperations: configuration.operations?.signingSerialization,
                operationExample: 'version',
                operationId,
                variableId,
                variableType: 'signingSerialization',
            });
        default: {
            const expectedVariable = configuration.variables?.[variableId];
            if (expectedVariable === undefined) {
                return { status: 'skip' };
            }
            return attemptCompilerOperation({
                configuration,
                data,
                identifier,
                operationId,
                variableId,
                ...{
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    AddressData: {
                        matchingOperations: configuration.operations?.addressData,
                        variableType: 'addressData',
                    },
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    HdKey: {
                        matchingOperations: configuration.operations?.hdKey,
                        operationExample: 'public_key',
                        variableType: 'hdKey',
                    },
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    Key: {
                        matchingOperations: configuration.operations?.key,
                        operationExample: 'public_key',
                        variableType: 'key',
                    },
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    WalletData: {
                        matchingOperations: configuration.operations?.walletData,
                        variableType: 'walletData',
                    },
                }[expectedVariable.type],
            });
        }
    }
};
/**
 * A text-formatting method to pretty-print the list of expected inputs
 * (`Encountered unexpected input while parsing script. Expected ...`). If
 * present, the `EOF` expectation is always moved to the end of the list.
 * @param expectedArray - the alphabetized list of expected inputs produced by
 * `parseScript`
 */
const describeExpectedInput = (expectedArray) => {
    /**
     * The constant used by the parser to denote the end of the input
     */
    const EOF = 'EOF';
    const newArray = expectedArray.filter((value) => value !== EOF);
    // eslint-disable-next-line functional/no-conditional-statements
    if (newArray.length !== expectedArray.length) {
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        newArray.push('the end of the script');
    }
    const withoutLastElement = newArray.slice(0, newArray.length - 1);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const lastElement = newArray[newArray.length - 1];
    const arrayRequiresCommas = 3;
    const arrayRequiresOr = 2;
    return `Encountered unexpected input while parsing script. Expected ${newArray.length >= arrayRequiresCommas
        ? withoutLastElement.join(', ').concat(`, or ${lastElement}`)
        : newArray.length === arrayRequiresOr
            ? newArray.join(' or ')
            : lastElement}.`;
};
const createEmptyRange = () => ({
    endColumn: 0,
    endLineNumber: 0,
    startColumn: 0,
    startLineNumber: 0,
});
/**
 * Validate all compilation data (i.e. validate all public and private keys),
 * returning an array of validation errors. If no validity issues are detected,
 * an empty array is returned.
 *
 * The function ensures that compilation fails whenever invalid compilation data
 * is provided, regardless of whether or not the offending public or private key
 * material is used. This is intended to surface software defects (particularly
 * in the software used by counterparties) as early as possible.
 */
const validateCompilationData = ({ configuration, data, }) => [
    ...(data.bytecode === undefined
        ? []
        : Object.entries(data.bytecode)
            .filter(([identifier]) => identifier.endsWith('.public_key'))
            .reduce((all, [identifier, publicKey]) => all.concat(configuration.secp256k1?.validatePublicKey(publicKey) === true
            ? []
            : [
                configuration.secp256k1 === undefined
                    ? {
                        error: `Could not validate compilation data: the public key provided for "${identifier}" could not be validated because the "secp256k1" property was not provided in the compiler configuration.`,
                        range: createEmptyRange(),
                    }
                    : {
                        error: `Invalid compilation data detected: the public key provided for "${identifier}" is not a valid Secp256k1 public key.`,
                        range: createEmptyRange(),
                    },
            ]), [])),
    ...(data.keys?.privateKeys === undefined
        ? []
        : Object.entries(data.keys.privateKeys).reduce((all, [variableId, privateKey]) => all.concat(validateSecp256k1PrivateKey(privateKey)
            ? []
            : [
                {
                    error: `Invalid compilation data detected: the private key provided for the "${variableId}" variable is not a valid Secp256k1 private key.`,
                    range: createEmptyRange(),
                },
            ]), [])),
    ...(data.hdKeys?.hdPrivateKeys === undefined
        ? []
        : Object.entries(data.hdKeys.hdPrivateKeys).reduce((all, [entityId, hdPrivateKey]) => {
            const decoded = decodeHdPrivateKey(hdPrivateKey);
            return all.concat(typeof decoded === 'string'
                ? [
                    {
                        error: `Invalid compilation data detected: the HD private key provided for the "${entityId}" entity is not a valid HD private key. ${decoded}`,
                        range: createEmptyRange(),
                    },
                ]
                : []);
        }, [])),
    ...(data.hdKeys?.hdPublicKeys === undefined
        ? []
        : Object.entries(data.hdKeys.hdPublicKeys).reduce((all, [entityId, hdPublicKey]) => {
            const decoded = decodeHdPublicKey(hdPublicKey);
            return all.concat(typeof decoded === 'string'
                ? [
                    {
                        error: `Invalid compilation data detected: the HD public key provided for the "${entityId}" entity is not a valid HD public key. ${decoded}`,
                        range: createEmptyRange(),
                    },
                ]
                : []);
        }, [])),
];
/**
 * This method is generally for internal use. The {@link compileScript} method
 * is the recommended API for direct compilation.
 */
const compileScriptRaw = ({ data, configuration, scriptId, }) => {
    const script = configuration.scripts[scriptId];
    if (script === undefined) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `No script with an ID of "${scriptId}" was provided in the compiler configuration.`,
                    range: createEmptyRange(),
                },
            ],
            success: false,
        };
    }
    if (configuration.sourceScriptIds?.includes(scriptId) === true) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `A circular dependency was encountered: script "${scriptId}" relies on itself to be generated. (Source scripts: ${configuration.sourceScriptIds.join(' → ')})`,
                    range: createEmptyRange(),
                },
            ],
            success: false,
        };
    }
    const sourceScriptIds = configuration.sourceScriptIds === undefined
        ? [scriptId]
        : [...configuration.sourceScriptIds, scriptId];
    const dataErrors = validateCompilationData({ configuration, data });
    if (dataErrors.length !== 0) {
        return {
            errorType: 'parse',
            errors: dataErrors,
            success: false,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return compileScriptContents({
        configuration: { ...configuration, sourceScriptIds },
        data,
        script,
    });
};
/**
 * Compile an internal script identifier.
 *
 * @remarks
 * If the identifier can be successfully resolved as a script, the script is
 * compiled and returned as a {@link CompilationResultSuccess}. If an error
 * occurs in compiling it, the error is returned as a string.
 *
 * Otherwise, the identifier is not recognized as a script, and this method
 * simply returns `false`.
 */
const resolveScriptIdentifier = ({ data, configuration, identifier, }) => {
    if (configuration.scripts[identifier] === undefined) {
        return false;
    }
    const result = compileScriptRaw({
        configuration,
        data,
        scriptId: identifier,
    });
    if (result.success) {
        return result;
    }
    return `Compilation error in resolved script "${identifier}": ${stringifyErrors(result.errors)}`;
};
/**
 * Return an {@link IdentifierResolutionFunction} for use in
 * {@link resolveScriptSegment}.
 *
 * @param scriptId - the `id` of the script for which the resulting
 * `IdentifierResolutionFunction` will be used.
 */
const createIdentifierResolver = ({ data, configuration, }) => 
// eslint-disable-next-line complexity
(identifier) => {
    const opcodeResult = configuration.opcodes?.[identifier];
    if (opcodeResult !== undefined) {
        return {
            bytecode: opcodeResult,
            status: true,
            type: IdentifierResolutionType.opcode,
        };
    }
    const variableResult = resolveVariableIdentifier({
        configuration,
        data,
        identifier,
    });
    if (variableResult.status !== 'skip') {
        return variableResult.status === 'error'
            ? {
                ...('debug' in variableResult
                    ? { debug: variableResult.debug }
                    : {}),
                error: variableResult.error,
                ...(configuration.entityOwnership === undefined
                    ? {}
                    : {
                        entityOwnership: 
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        configuration.entityOwnership[identifier.split('.')[0]],
                    }),
                recoverable: 'recoverable' in variableResult,
                status: false,
                type: IdentifierResolutionErrorType.variable,
            }
            : {
                ...('debug' in variableResult
                    ? { debug: variableResult.debug }
                    : {}),
                bytecode: variableResult.bytecode,
                ...('signature' in variableResult
                    ? {
                        signature: variableResult.signature,
                    }
                    : {}),
                status: true,
                type: IdentifierResolutionType.variable,
            };
    }
    const scriptResult = resolveScriptIdentifier({
        configuration,
        data,
        identifier,
    });
    if (scriptResult !== false) {
        return typeof scriptResult === 'string'
            ? {
                error: scriptResult,
                scriptId: identifier,
                status: false,
                type: IdentifierResolutionErrorType.script,
            }
            : {
                bytecode: scriptResult.bytecode,
                source: scriptResult,
                status: true,
                type: IdentifierResolutionType.script,
            };
    }
    return {
        error: `Unknown identifier "${identifier}".`,
        status: false,
        type: IdentifierResolutionErrorType.unknown,
    };
};
/**
 * This method is generally for internal use. The {@link compileScript} method
 * is the recommended API for direct compilation.
 */
const compileScriptContents = ({ data, configuration, script, }) => {
    const parseResult = parseScript(script);
    if (!parseResult.status) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: describeExpectedInput(parseResult.expected),
                    range: {
                        endColumn: parseResult.index.column,
                        endLineNumber: parseResult.index.line,
                        startColumn: parseResult.index.column,
                        startLineNumber: parseResult.index.line,
                    },
                },
            ],
            success: false,
        };
    }
    const resolver = createIdentifierResolver({ configuration, data });
    const resolvedScript = resolveScriptSegment(parseResult.value, resolver);
    const resolutionErrors = getResolutionErrors(resolvedScript);
    if (resolutionErrors.length !== 0) {
        return {
            errorType: 'resolve',
            errors: resolutionErrors,
            parse: parseResult.value,
            resolve: resolvedScript,
            success: false,
        };
    }
    const reduction = reduceScript(resolvedScript, configuration.vm, configuration.createAuthenticationProgram);
    return {
        ...(reduction.errors === undefined
            ? { bytecode: reduction.bytecode, success: true }
            : { errorType: 'reduce', errors: reduction.errors, success: false }),
        parse: parseResult.value,
        reduce: reduction,
        resolve: resolvedScript,
    };
};

/**
 * Parse, resolve, and reduce the selected script using the provided `data` and
 * `configuration`.
 *
 * Note, locktime validation only occurs if `compilationContext` is provided in
 * the configuration.
 */
// eslint-disable-next-line complexity
const compileScript = (scriptId, data, configuration) => {
    const locktimeDisablingSequenceNumber = 0xffffffff;
    const lockTimeTypeBecomesTimestamp = 500000000;
    if (data.compilationContext?.transaction.locktime !== undefined) {
        if (configuration.unlockingScriptTimeLockTypes?.[scriptId] === 'height' &&
            data.compilationContext.transaction.locktime >=
                lockTimeTypeBecomesTimestamp) {
            return {
                errorType: 'parse',
                errors: [
                    {
                        error: `The script "${scriptId}" requires a height-based locktime (less than 500,000,000), but this transaction uses a timestamp-based locktime ("${data.compilationContext.transaction.locktime}").`,
                        range: createEmptyRange(),
                    },
                ],
                success: false,
            };
        }
        if (configuration.unlockingScriptTimeLockTypes?.[scriptId] === 'timestamp' &&
            data.compilationContext.transaction.locktime <
                lockTimeTypeBecomesTimestamp) {
            return {
                errorType: 'parse',
                errors: [
                    {
                        error: `The script "${scriptId}" requires a timestamp-based locktime (greater than or equal to 500,000,000), but this transaction uses a height-based locktime ("${data.compilationContext.transaction.locktime}").`,
                        range: createEmptyRange(),
                    },
                ],
                success: false,
            };
        }
    }
    if (data.compilationContext?.transaction.inputs[data.compilationContext.inputIndex]?.sequenceNumber !== undefined &&
        configuration.unlockingScriptTimeLockTypes?.[scriptId] !== undefined &&
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].sequenceNumber === locktimeDisablingSequenceNumber) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `The script "${scriptId}" requires a locktime, but this input's sequence number is set to disable transaction locktime (0xffffffff). This will cause the OP_CHECKLOCKTIMEVERIFY operation to error when the transaction is verified. To be valid, this input must use a sequence number that does not disable locktime.`,
                    range: createEmptyRange(),
                },
            ],
            success: false,
        };
    }
    const rawResult = compileScriptRaw({
        configuration,
        data,
        scriptId,
    });
    if (!rawResult.success) {
        return rawResult;
    }
    const unlocks = configuration.unlockingScripts?.[scriptId];
    const unlockingScriptType = unlocks === undefined
        ? undefined
        : configuration.lockingScriptTypes?.[unlocks];
    const isP2shUnlock = unlockingScriptType === 'p2sh20' || unlockingScriptType === 'p2sh32';
    const lockingScriptType = configuration.lockingScriptTypes?.[scriptId];
    const isP2shLock = lockingScriptType === 'p2sh20' || lockingScriptType === 'p2sh32';
    if (isP2shLock) {
        const transformedResult = compileScriptRaw({
            configuration: {
                ...configuration,
                scripts: {
                    p2sh20Locking: 'OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL',
                    p2sh32Locking: 'OP_HASH256 <$(<lockingBytecode> OP_HASH256)> OP_EQUAL',
                },
                variables: { lockingBytecode: { type: 'AddressData' } },
            },
            data: { bytecode: { lockingBytecode: rawResult.bytecode } },
            scriptId: lockingScriptType === 'p2sh20' ? 'p2sh20Locking' : 'p2sh32Locking',
        });
        if (!transformedResult.success) {
            return transformedResult;
        }
        return {
            ...rawResult,
            bytecode: transformedResult.bytecode,
            transformed: lockingScriptType === 'p2sh20' ? 'p2sh20-locking' : 'p2sh32-locking',
        };
    }
    if (isP2shUnlock) {
        const lockingBytecodeResult = compileScriptRaw({
            configuration,
            data,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            scriptId: unlocks,
        });
        if (!lockingBytecodeResult.success) {
            return lockingBytecodeResult;
        }
        const transformedResult = compileScriptRaw({
            configuration: {
                ...configuration,
                scripts: {
                    p2shUnlocking: 'unlockingBytecode <lockingBytecode>',
                },
                variables: {
                    lockingBytecode: { type: 'AddressData' },
                    unlockingBytecode: { type: 'AddressData' },
                },
            },
            data: {
                bytecode: {
                    lockingBytecode: lockingBytecodeResult.bytecode,
                    unlockingBytecode: rawResult.bytecode,
                },
            },
            scriptId: 'p2shUnlocking',
        });
        return {
            ...rawResult,
            bytecode: transformedResult.bytecode,
            transformed: unlockingScriptType === 'p2sh20'
                ? 'p2sh20-unlocking'
                : 'p2sh32-unlocking',
        };
    }
    return rawResult;
};

/* eslint-disable @typescript-eslint/no-duplicate-enum-values */
var CompilerDefaults;
(function (CompilerDefaults) {
    /**
     * The `addressIndex` used by the default scenario `data`.
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioAddressIndex"] = 0] = "defaultScenarioAddressIndex";
    /**
     * The value used for `["slot"]` and `["copy"]` locking or unlocking bytecode
     * when generating a scenario and no `unlockingScriptId` is provided.
     */
    // eslint-disable-next-line @typescript-eslint/no-mixed-enums
    CompilerDefaults["defaultScenarioBytecode"] = "";
    /**
     *
     * The value of `currentBlockHeight` in the default wallet template
     * scenario. This is the height of the second mined block after the genesis
     * block: `000000006a625f06636b8bb6ac7b960a8d03705d1ace08b1a19da3fdcc99ddbd`.
     *
     * This default value was chosen to be low enough to simplify the debugging of
     * block height offsets while remaining differentiated from `0` and `1`, which
     * are used both as boolean return values and for control flow.
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioCurrentBlockHeight"] = 2] = "defaultScenarioCurrentBlockHeight";
    /**
     * The value of `currentBlockTime` in the default wallet template
     * scenario. This is the Median Time-Past block time (BIP113) of block `2`
     * (the block used in
     * {@link CompilerDefaults.defaultScenarioCurrentBlockHeight}).
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioCurrentBlockTime"] = 1231469665] = "defaultScenarioCurrentBlockTime";
    /**
     * The default `outpointTransactionHash` of inputs in scenarios.
     */
    CompilerDefaults["defaultScenarioInputOutpointTransactionHash"] = "0000000000000000000000000000000000000000000000000000000000000001";
    /**
     * The default `category` of tokens in scenarios.
     */
    CompilerDefaults["defaultScenarioOutputTokenCategory"] = "0000000000000000000000000000000000000000000000000000000000000002";
    /**
     * The default `sequenceNumber` of inputs in scenarios.
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioInputSequenceNumber"] = 0] = "defaultScenarioInputSequenceNumber";
    /**
     * The default `lockingBytecode` value for scenario outputs,
     * `OP_RETURN <"libauth">` (hex: `6a076c696261757468`).
     */
    CompilerDefaults["defaultScenarioOutputLockingBytecode"] = "6a076c696261757468";
    /**
     * The default `valueSatoshis` of outputs in scenarios.
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioOutputValueSatoshis"] = 0] = "defaultScenarioOutputValueSatoshis";
    /**
     * The value of `transaction.locktime` in the default wallet template
     * scenario.
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioTransactionLocktime"] = 0] = "defaultScenarioTransactionLocktime";
    /**
     * The value of `transaction.version` in the default wallet template
     * scenario. Transaction version `2` enables `OP_CHECKSEQUENCEVERIFY` as
     * described in BIP68, BIP112, and BIP113.
     */
    CompilerDefaults[CompilerDefaults["defaultScenarioTransactionVersion"] = 2] = "defaultScenarioTransactionVersion";
    /**
     *s
     * If unset, each `HdKey` uses this `addressOffset`.
     */
    CompilerDefaults[CompilerDefaults["hdKeyAddressOffset"] = 0] = "hdKeyAddressOffset";
    /**
     * If unset, each `HdKey` uses this `hdPublicKeyDerivationPath`.
     */
    CompilerDefaults["hdKeyHdPublicKeyDerivationPath"] = "";
    /**
     * If unset, each `HdKey` uses this `privateDerivationPath`.
     */
    CompilerDefaults["hdKeyPrivateDerivationPath"] = "i";
    /**
     * The prefix used to refer to other scenario bytecode scripts from within a
     * bytecode script. See {@link WalletTemplateScenarioData.bytecode}
     * for details.
     */
    CompilerDefaults["scenarioBytecodeScriptPrefix"] = "_scenario.";
})(CompilerDefaults || (CompilerDefaults = {}));

/**
 * Attempt a series of compiler operations, skipping to the next operation if
 * the current operation returns a {@link CompilerOperationSkip} (indicating it
 * failed and can be skipped). The `finalOperation` may not be skipped, and must
 * either return {@link CompilerOperationSuccess} or
 * {@link CompilerOperationError}.
 *
 * @param operations - an array of skippable operations to try
 * @param finalOperation - a final, un-skippable operation
 */
const attemptCompilerOperations = (operations, finalOperation) => (identifier, data, configuration) => {
    // eslint-disable-next-line functional/no-loop-statements
    for (const operation of operations) {
        const result = operation(identifier, data, configuration);
        if (result.status !== 'skip')
            return result;
    }
    return finalOperation(identifier, data, configuration);
};
/**
 * Modify a compiler operation to verify that certain properties exist in the
 * {@link CompilationData} and {@link CompilerConfiguration} before executing
 * the provided operation. If the properties don't exist, an error message
 * is returned.
 *
 * This is useful for eliminating repetitive existence checks.
 */
const compilerOperationRequires = ({ 
/**
 * If `true`, the accepted operation may return `false`, and any missing
 * properties will cause the returned operation to return `false` (meaning
 * the operation should be skipped)
 */
canBeSkipped, 
/**
 * An array of the top-level properties required in the
 * {@link CompilationData}.
 */
dataProperties, 
/**
 * An array of the top-level properties required in the
 * {@link CompilerConfiguration}
 */
configurationProperties, 
/**
 * The operation to run if all required properties exist
 */
operation, }) => 
// eslint-disable-next-line complexity
(identifier, data, configuration) => {
    // eslint-disable-next-line functional/no-loop-statements
    for (const property of configurationProperties) {
        if (configuration[property] === undefined)
            return (canBeSkipped
                ? { status: 'skip' }
                : {
                    error: `Cannot resolve "${identifier}" - the "${property}" property was not provided in the compiler configuration.`,
                    status: 'error',
                });
    }
    // eslint-disable-next-line functional/no-loop-statements
    for (const property of dataProperties) {
        if (data[property] ===
            undefined)
            return (canBeSkipped
                ? { status: 'skip' }
                : {
                    error: `Cannot resolve "${identifier}" - the "${property}" property was not provided in the compilation data.`,
                    status: 'error',
                });
    }
    return operation(identifier, data, configuration);
};
const compilerOperationAttemptBytecodeResolution = compilerOperationRequires({
    canBeSkipped: true,
    configurationProperties: [],
    dataProperties: ['bytecode'],
    operation: (identifier, data) => {
        const bytecode = data.bytecode[identifier];
        if (bytecode !== undefined) {
            return { bytecode, status: 'success' };
        }
        return { status: 'skip' };
    },
});
// eslint-disable-next-line complexity
const compilerOperationHelperDeriveHdPrivateNode = ({ addressIndex, entityId, entityHdPrivateKey, configuration, hdKey, identifier, }) => {
    const addressOffset = hdKey.addressOffset ?? CompilerDefaults.hdKeyAddressOffset;
    const privateDerivationPath = hdKey.privateDerivationPath ?? CompilerDefaults.hdKeyPrivateDerivationPath;
    const i = addressIndex + addressOffset;
    const validPrivatePathWithIndex = /^(?:m|i|[0-9]+)'?(?:\/(?:[0-9]+|i)'?)*$/u;
    if (!validPrivatePathWithIndex.test(privateDerivationPath)) {
        return {
            error: `Could not generate "${identifier}" - the path "${privateDerivationPath}" is not a valid "privateDerivationPath".`,
            status: 'error',
        };
    }
    /**
     * Provided keys are already verified by `validateCompilationData`.
     */
    const masterContents = assertSuccess(decodeHdPrivateKey(entityHdPrivateKey, {
        crypto: configuration,
    }));
    const instancePath = privateDerivationPath.replace('i', i.toString());
    const usesAbsoluteDerivation = instancePath.includes('m');
    const instanceNode = (usesAbsoluteDerivation ? deriveHdPath : deriveHdPathRelative)(masterContents.node, instancePath, {
        crypto: configuration,
        throwErrors: false,
    });
    if (typeof instanceNode === 'string') {
        return {
            error: `Could not generate "${identifier}" - the path "${instancePath}" could not be derived for entity "${entityId}": ${instanceNode}`,
            status: 'error',
        };
    }
    return {
        bytecode: instanceNode.privateKey,
        status: 'success',
    };
};
const compilerOperationHelperUnknownEntity = (identifier, variableId) => ({
    error: `Identifier "${identifier}" refers to an HdKey, but the "entityOwnership" for "${variableId}" is not available in this compiler configuration.`,
    status: 'error',
});
const compilerOperationHelperAddressIndex = (identifier) => ({
    error: `Identifier "${identifier}" refers to an HdKey, but "hdKeys.addressIndex" was not provided in the compilation data.`,
    status: 'error',
});
const compilerOperationHelperDeriveHdKeyPrivate = ({ configuration, hdKeys, identifier, }) => {
    const { addressIndex, hdPrivateKeys } = hdKeys;
    const [variableId] = identifier.split('.');
    const entityId = configuration.entityOwnership[variableId];
    if (entityId === undefined) {
        return compilerOperationHelperUnknownEntity(identifier, variableId);
    }
    if (addressIndex === undefined) {
        return compilerOperationHelperAddressIndex(identifier);
    }
    const entityHdPrivateKey = hdPrivateKeys === undefined ? undefined : hdPrivateKeys[entityId];
    if (entityHdPrivateKey === undefined) {
        return {
            error: `Identifier "${identifier}" refers to an HdKey owned by "${entityId}", but an HD private key for this entity (or an existing signature) was not provided in the compilation data.`,
            recoverable: true,
            status: 'error',
        };
    }
    /**
     * Guaranteed to be an `HdKey` if this method is reached in the compiler.
     */
    const hdKey = configuration.variables[variableId];
    return compilerOperationHelperDeriveHdPrivateNode({
        addressIndex,
        configuration,
        entityHdPrivateKey,
        entityId,
        hdKey,
        identifier,
    });
};
/**
 * Returns `false` if the target script ID doesn't exist in the compiler
 * configuration (allows for the caller to generate the error message).
 *
 * If the compilation produced errors, returns a
 * {@link CompilerOperationErrorFatal}.
 *
 * If the compilation was successful, returns the compiled bytecode as a
 * `Uint8Array`.
 */
const compilerOperationHelperCompileScript = ({ targetScriptId, data, configuration, }) => {
    const signingTarget = configuration.scripts[targetScriptId];
    const compiledTarget = resolveScriptIdentifier({
        configuration,
        data,
        identifier: targetScriptId,
    });
    if (signingTarget === undefined || compiledTarget === false) {
        return false;
    }
    if (typeof compiledTarget === 'string') {
        return {
            error: compiledTarget,
            status: 'error',
        };
    }
    return compiledTarget.bytecode;
};
/**
 * Returns either the properly generated `coveredBytecode` or a
 * {@link CompilerOperationErrorFatal}.
 */
const compilerOperationHelperGenerateCoveredBytecode = ({ data, configuration, identifier, sourceScriptIds, unlockingScripts, }) => {
    const currentScriptId = sourceScriptIds[sourceScriptIds.length - 1];
    if (currentScriptId === undefined) {
        return {
            error: `Identifier "${identifier}" requires a signing serialization, but "coveredBytecode" cannot be determined because the compiler configuration's "sourceScriptIds" is empty.`,
            status: 'error',
        };
    }
    const targetLockingScriptId = unlockingScripts[currentScriptId];
    if (targetLockingScriptId === undefined) {
        return {
            error: `Identifier "${identifier}" requires a signing serialization, but "coveredBytecode" cannot be determined because "${currentScriptId}" is not present in the compiler configuration's "unlockingScripts".`,
            status: 'error',
        };
    }
    const result = compilerOperationHelperCompileScript({
        configuration,
        data,
        targetScriptId: targetLockingScriptId,
    });
    if (result === false) {
        return {
            error: `Identifier "${identifier}" requires a signing serialization that covers an unknown locking script, "${targetLockingScriptId}".`,
            status: 'error',
        };
    }
    return result;
};

const compilerOperationAddressData = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['bytecode'],
    operation: (identifier, data) => {
        const bytecode = data.bytecode[identifier];
        if (bytecode !== undefined) {
            return { bytecode, status: 'success' };
        }
        return {
            error: `Identifier "${identifier}" refers to an AddressData, but "${identifier}" was not provided in the CompilationData "bytecode".`,
            recoverable: true,
            status: 'error',
        };
    },
});
const compilerOperationWalletData = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['bytecode'],
    operation: (identifier, data) => {
        const bytecode = data.bytecode[identifier];
        if (bytecode !== undefined) {
            return { bytecode, status: 'success' };
        }
        return {
            error: `Identifier "${identifier}" refers to a WalletData, but "${identifier}" was not provided in the CompilationData "bytecode".`,
            recoverable: true,
            status: 'error',
        };
    },
});
const compilerOperationCurrentBlockTime = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['currentBlockTime'],
    operation: (_, data) => ({
        bytecode: numberToBinUint32LE(data.currentBlockTime),
        status: 'success',
    }),
});
const compilerOperationCurrentBlockHeight = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['currentBlockHeight'],
    operation: (_, data) => ({
        bytecode: bigIntToVmNumber(BigInt(data.currentBlockHeight)),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationCorrespondingOutput = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => {
        const { correspondingOutput } = generateSigningSerializationComponentsBCH(data.compilationContext);
        return correspondingOutput === undefined
            ? { bytecode: Uint8Array.of(), status: 'success' }
            : {
                bytecode: correspondingOutput,
                status: 'success',
            };
    },
});
const compilerOperationSigningSerializationCorrespondingOutputHash = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256'],
    dataProperties: ['compilationContext'],
    operation: (_, data, configuration) => {
        const { correspondingOutput } = generateSigningSerializationComponentsBCH(data.compilationContext);
        return correspondingOutput === undefined
            ? { bytecode: Uint8Array.of(), status: 'success' }
            : {
                bytecode: configuration.sha256.hash(configuration.sha256.hash(correspondingOutput)),
                status: 'success',
            };
    },
});
const compilerOperationHelperSigningSerializationCoveredBytecode = (returnLength) => compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sourceScriptIds', 'unlockingScripts'],
    dataProperties: ['compilationContext'],
    operation: (identifier, data, configuration) => {
        const { unlockingScripts, sourceScriptIds } = configuration;
        const result = compilerOperationHelperGenerateCoveredBytecode({
            configuration,
            data,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        return {
            bytecode: returnLength
                ? bigIntToCompactUint(BigInt(result.length))
                : result,
            status: 'success',
        };
    },
});
const compilerOperationSigningSerializationCoveredBytecode = compilerOperationHelperSigningSerializationCoveredBytecode(false);
const compilerOperationSigningSerializationCoveredBytecodeLength = compilerOperationHelperSigningSerializationCoveredBytecode(true);
const compilerOperationSigningSerializationLocktime = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: numberToBinUint32LE(data.compilationContext.transaction.locktime),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationOutpointIndex = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: numberToBinUint32LE(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].outpointIndex),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationOutpointTransactionHash = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].outpointTransactionHash,
        status: 'success',
    }),
});
const compilerOperationSigningSerializationOutputValue = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: valueSatoshisToBin(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        data.compilationContext.sourceOutputs[data.compilationContext.inputIndex].valueSatoshis),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationSequenceNumber = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: numberToBinUint32LE(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].sequenceNumber),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationTransactionOutpoints = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: encodeTransactionOutpoints(data.compilationContext.transaction.inputs),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationTransactionOutpointsHash = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256'],
    dataProperties: ['compilationContext'],
    operation: (_, data, configuration) => ({
        bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionOutpoints(data.compilationContext.transaction.inputs))),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationTransactionOutputs = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: encodeTransactionOutputsForSigning(data.compilationContext.transaction.outputs),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationTransactionOutputsHash = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256'],
    dataProperties: ['compilationContext'],
    operation: (_, data, configuration) => ({
        bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionOutputsForSigning(data.compilationContext.transaction.outputs))),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationTransactionSequenceNumbers = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: encodeTransactionInputSequenceNumbersForSigning(data.compilationContext.transaction.inputs),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationTransactionSequenceNumbersHash = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256'],
    dataProperties: ['compilationContext'],
    operation: (_, data, configuration) => ({
        bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionInputSequenceNumbersForSigning(data.compilationContext.transaction.inputs))),
        status: 'success',
    }),
});
const compilerOperationSigningSerializationVersion = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: numberToBinUint32LE(data.compilationContext.transaction.version),
        status: 'success',
    }),
});
const compilerOperationKeyPublicKeyCommon = attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['secp256k1'],
    dataProperties: ['keys'],
    operation: (identifier, data, configuration) => {
        const { keys } = data;
        const { secp256k1 } = configuration;
        const { privateKeys } = keys;
        const [variableId] = identifier.split('.');
        if (privateKeys?.[variableId] !== undefined) {
            return {
                bytecode: secp256k1.derivePublicKeyCompressed(
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                privateKeys[variableId]),
                status: 'success',
            };
        }
        return {
            error: `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`,
            recoverable: true,
            status: 'error',
        };
    },
}));
const compilerOperationHdKeyPublicKeyCommon = attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [
        'entityOwnership',
        'ripemd160',
        'secp256k1',
        'sha256',
        'sha512',
        'variables',
    ],
    dataProperties: ['hdKeys'],
    operation: 
    // eslint-disable-next-line complexity
    (identifier, data, configuration) => {
        const { hdKeys } = data;
        const { hdPrivateKeys, addressIndex, hdPublicKeys } = hdKeys;
        const [variableId] = identifier.split('.');
        const entityId = configuration.entityOwnership[variableId];
        if (entityId === undefined) {
            return compilerOperationHelperUnknownEntity(identifier, variableId);
        }
        if (addressIndex === undefined) {
            return compilerOperationHelperAddressIndex(identifier);
        }
        const entityHdPrivateKey = hdPrivateKeys === undefined ? undefined : hdPrivateKeys[entityId];
        /**
         * Guaranteed to be an `HdKey` if this method is reached in the compiler.
         */
        const hdKey = configuration.variables[variableId];
        if (entityHdPrivateKey !== undefined) {
            const privateResult = compilerOperationHelperDeriveHdPrivateNode({
                addressIndex,
                configuration,
                entityHdPrivateKey,
                entityId,
                hdKey,
                identifier,
            });
            if (privateResult.status === 'error')
                return privateResult;
            return {
                bytecode: configuration.secp256k1.derivePublicKeyCompressed(privateResult.bytecode),
                status: 'success',
            };
        }
        const entityHdPublicKey = hdPublicKeys === undefined ? undefined : hdPublicKeys[entityId];
        if (entityHdPublicKey === undefined) {
            return {
                error: `Identifier "${identifier}" refers to an HdKey owned by "${entityId}", but an HD private key or HD public key for this entity was not provided in the compilation data.`,
                recoverable: true,
                status: 'error',
            };
        }
        const addressOffset = hdKey.addressOffset ?? CompilerDefaults.hdKeyAddressOffset;
        const privateDerivationPath = hdKey.privateDerivationPath ??
            CompilerDefaults.hdKeyPrivateDerivationPath;
        const hdPublicKeyDerivationPath = hdKey.hdPublicKeyDerivationPath ??
            CompilerDefaults.hdKeyHdPublicKeyDerivationPath;
        const publicDerivationPath = hdKey.publicDerivationPath ?? privateDerivationPath.replace('m/', '');
        const validHdPublicKeyDerivationPath = /^(?:m|[0-9]+)'?(?:\/(?:[0-9]+'?))*$/u;
        if (hdPublicKeyDerivationPath !== '' &&
            !validHdPublicKeyDerivationPath.test(hdPublicKeyDerivationPath)) {
            return {
                error: `Could not generate "${identifier}" - "hdPublicKeyDerivationPath" ("${hdPublicKeyDerivationPath}") must be a fixed (no "i" characters), valid absolute derivation path.`,
                status: 'error',
            };
        }
        const expected = hdPublicKeyDerivationPath === ''
            ? publicDerivationPath
            : `${hdPublicKeyDerivationPath}/${publicDerivationPath}`;
        if (privateDerivationPath !== expected) {
            return {
                error: `Could not generate "${identifier}" - "privateDerivationPath" ("${privateDerivationPath}") is expected to be the combination of "hdPublicKeyDerivationPath" and "publicDerivationPath": "${expected}".`,
                status: 'error',
            };
        }
        /**
         * Provided keys are already verified by `validateCompilationData`.
         */
        const masterContents = assertSuccess(decodeHdPublicKey(entityHdPublicKey, {
            crypto: configuration,
        }));
        const i = addressIndex + addressOffset;
        const instancePath = publicDerivationPath.replace('i', i.toString());
        const expectedDepth = hdPublicKeyDerivationPath.split('/').length - 1;
        if (hdPublicKeyDerivationPath !== '' &&
            masterContents.node.depth !== expectedDepth) {
            return {
                error: `Could not generate "${identifier}" - the HD public key derivation path ("${hdPublicKeyDerivationPath}") indicates an expected depth of ${expectedDepth}, but the provided HD public key has a depth of ${masterContents.node.depth}.`,
                status: 'error',
            };
        }
        const instanceNode = deriveHdPathRelative(masterContents.node, instancePath, { crypto: configuration, throwErrors: false });
        if (typeof instanceNode === 'string') {
            return {
                error: `Could not generate "${identifier}" - the path "${instancePath}" could not be derived for entity "${entityId}": ${instanceNode}`,
                status: 'error',
            };
        }
        return { bytecode: instanceNode.publicKey, status: 'success' };
    },
}));
/* eslint-disable camelcase, @typescript-eslint/naming-convention */
const compilerOperationsCommon = {
    addressData: compilerOperationAddressData,
    currentBlockHeight: compilerOperationCurrentBlockHeight,
    currentBlockTime: compilerOperationCurrentBlockTime,
    hdKey: {
        public_key: compilerOperationHdKeyPublicKeyCommon,
    },
    key: {
        public_key: compilerOperationKeyPublicKeyCommon,
    },
    signingSerialization: {
        corresponding_output: compilerOperationSigningSerializationCorrespondingOutput,
        corresponding_output_hash: compilerOperationSigningSerializationCorrespondingOutputHash,
        covered_bytecode: compilerOperationSigningSerializationCoveredBytecode,
        covered_bytecode_length: compilerOperationSigningSerializationCoveredBytecodeLength,
        locktime: compilerOperationSigningSerializationLocktime,
        outpoint_index: compilerOperationSigningSerializationOutpointIndex,
        outpoint_transaction_hash: compilerOperationSigningSerializationOutpointTransactionHash,
        output_value: compilerOperationSigningSerializationOutputValue,
        sequence_number: compilerOperationSigningSerializationSequenceNumber,
        transaction_outpoints: compilerOperationSigningSerializationTransactionOutpoints,
        transaction_outpoints_hash: compilerOperationSigningSerializationTransactionOutpointsHash,
        transaction_outputs: compilerOperationSigningSerializationTransactionOutputs,
        transaction_outputs_hash: compilerOperationSigningSerializationTransactionOutputsHash,
        transaction_sequence_numbers: compilerOperationSigningSerializationTransactionSequenceNumbers,
        transaction_sequence_numbers_hash: compilerOperationSigningSerializationTransactionSequenceNumbersHash,
        version: compilerOperationSigningSerializationVersion,
    },
    walletData: compilerOperationWalletData,
};
/* eslint-enable camelcase, @typescript-eslint/naming-convention */

/* eslint-disable max-lines */
/**
 * Given a compiler configuration, generate the default scenario that is
 * extended by all the configuration's scenarios.
 *
 * For details on default scenario generation, see
 * {@link WalletTemplateScenario.extends}.
 *
 * @param configuration - the compiler configuration from which to generate the
 * default scenario
 */
// eslint-disable-next-line complexity
const generateDefaultScenarioDefinition = (configuration) => {
    const { variables, entityOwnership } = configuration;
    const keyVariableIds = variables === undefined
        ? []
        : Object.entries(variables)
            .filter((entry) => entry[1].type === 'Key')
            .map(([id]) => id);
    const entityIds = entityOwnership === undefined
        ? []
        : Object.keys(Object.values(entityOwnership).reduce((all, entityId) => ({ ...all, [entityId]: true }), {}));
    const valueMap = [...keyVariableIds, ...entityIds]
        .sort((idA, idB) => idA.localeCompare(idB, 'en'))
        .reduce((all, id, index) => ({
        ...all,
        [id]: bigIntToBinUint256BEClamped(BigInt(index + 1)),
    }), {});
    const privateKeys = variables === undefined
        ? undefined
        : Object.entries(variables).reduce((all, [variableId, variable]) => variable.type === 'Key'
            ? {
                ...all,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                [variableId]: binToHex(valueMap[variableId]),
            }
            : all, {});
    const defaultScenario = {
        data: {
            currentBlockHeight: CompilerDefaults.defaultScenarioCurrentBlockHeight,
            currentBlockTime: CompilerDefaults.defaultScenarioCurrentBlockTime,
            ...(privateKeys === undefined || Object.keys(privateKeys).length === 0
                ? {}
                : { keys: { privateKeys } }),
        },
        sourceOutputs: [{ lockingBytecode: ['slot'] }],
        transaction: {
            inputs: [{ unlockingBytecode: ['slot'] }],
            locktime: CompilerDefaults.defaultScenarioTransactionLocktime,
            outputs: [
                {
                    lockingBytecode: CompilerDefaults.defaultScenarioOutputLockingBytecode,
                },
            ],
            version: CompilerDefaults.defaultScenarioTransactionVersion,
        },
    };
    const hasHdKeys = variables === undefined
        ? false
        : Object.values(variables).findIndex((variable) => variable.type === 'HdKey') !== -1;
    if (!hasHdKeys) {
        return defaultScenario;
    }
    const { sha256, sha512 } = configuration;
    if (sha256 === undefined) {
        return 'An implementations of "sha256" is required to generate defaults for HD keys, but the "sha256" property is not included in this compiler configuration.';
    }
    if (sha512 === undefined) {
        return 'An implementations of "sha512" is required to generate defaults for HD keys, but the "sha512" property is not included in this compiler configuration.';
    }
    const crypto = { sha256, sha512 };
    const hdPrivateKeys = entityIds.reduce((all, entityId) => {
        /**
         * The first 5,000,000,000 seeds have been tested, scenarios are
         * unlikely to exceed this number of entities.
         */
        const assumeValidity = true;
        const masterNode = deriveHdPrivateNodeFromSeed(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        valueMap[entityId], { assumeValidity, crypto });
        const { hdPrivateKey } = encodeHdPrivateKey({ network: 'mainnet', node: masterNode }, { crypto });
        return { ...all, [entityId]: hdPrivateKey };
    }, {});
    return {
        ...defaultScenario,
        data: {
            ...defaultScenario.data,
            hdKeys: {
                addressIndex: CompilerDefaults.defaultScenarioAddressIndex,
                hdPrivateKeys,
            },
        },
    };
};
/**
 * Extend the `data` property of a scenario definition with values from a parent
 * scenario definition. Returns the extended value for `data`.
 *
 * @param parentData - the scenario `data` that is extended by the child
 * scenario
 * @param childData - the scenario `data` that may override values from the
 * parent scenario
 */
// eslint-disable-next-line complexity
const extendScenarioDefinitionData = (parentData, childData) => ({
    ...parentData,
    ...childData,
    ...(parentData.bytecode === undefined && childData.bytecode === undefined
        ? {}
        : {
            bytecode: {
                ...parentData.bytecode,
                ...childData.bytecode,
            },
        }),
    ...(parentData.hdKeys === undefined && childData.hdKeys === undefined
        ? {}
        : {
            hdKeys: {
                ...parentData.hdKeys,
                ...childData.hdKeys,
                ...(parentData.hdKeys?.hdPrivateKeys === undefined &&
                    childData.hdKeys?.hdPrivateKeys === undefined
                    ? {}
                    : {
                        hdPrivateKeys: {
                            ...parentData.hdKeys?.hdPrivateKeys,
                            ...childData.hdKeys?.hdPrivateKeys,
                        },
                    }),
                ...(parentData.hdKeys?.hdPublicKeys === undefined &&
                    childData.hdKeys?.hdPublicKeys === undefined
                    ? {}
                    : {
                        hdPublicKeys: {
                            ...parentData.hdKeys?.hdPublicKeys,
                            ...childData.hdKeys?.hdPublicKeys,
                        },
                    }),
            },
        }),
    ...(parentData.keys === undefined && childData.keys === undefined
        ? {}
        : {
            keys: {
                privateKeys: {
                    ...parentData.keys?.privateKeys,
                    ...childData.keys?.privateKeys,
                },
            },
        }),
});
/**
 * Extend a child scenario definition with values from a parent scenario
 * definition. Returns the extended values for `data`, `transaction`, and
 * `value`.
 *
 * @param parentScenario - the scenario that is extended by the child scenario
 * @param childScenario - the scenario that may override values from the parent
 * scenario
 */
// eslint-disable-next-line complexity
const extendScenarioDefinition = (parentScenario, childScenario) => ({
    ...(parentScenario.data === undefined && childScenario.data === undefined
        ? {}
        : {
            data: extendScenarioDefinitionData(parentScenario.data ?? {}, childScenario.data ?? {}),
        }),
    ...(parentScenario.transaction === undefined &&
        childScenario.transaction === undefined
        ? {}
        : {
            transaction: {
                ...parentScenario.transaction,
                ...childScenario.transaction,
            },
        }),
    ...(parentScenario.sourceOutputs === undefined &&
        childScenario.sourceOutputs === undefined
        ? {}
        : {
            sourceOutputs: childScenario.sourceOutputs ?? parentScenario.sourceOutputs,
        }),
});
/**
 * Generate the full scenario that is extended by the provided scenario
 * identifier. Scenarios for which `extends` is `undefined` extend the default
 * scenario for the provided compiler configuration.
 */
// eslint-disable-next-line complexity
const generateExtendedScenario = ({ configuration, scenarioId, sourceScenarioIds = [], }) => {
    if (scenarioId === undefined) {
        return generateDefaultScenarioDefinition(configuration);
    }
    if (sourceScenarioIds.includes(scenarioId)) {
        return `Cannot extend scenario "${scenarioId}": scenario "${scenarioId}" extends itself. Scenario inheritance path: ${sourceScenarioIds.join(' → ')}`;
    }
    const scenario = configuration.scenarios?.[scenarioId];
    if (scenario === undefined) {
        return `Cannot extend scenario "${scenarioId}": a scenario with the identifier ${scenarioId} is not included in this compiler configuration.`;
    }
    const parentScenario = scenario.extends === undefined
        ? generateDefaultScenarioDefinition(configuration)
        : generateExtendedScenario({
            configuration,
            scenarioId: scenario.extends,
            sourceScenarioIds: [...sourceScenarioIds, scenarioId],
        });
    if (typeof parentScenario === 'string') {
        return parentScenario;
    }
    return extendScenarioDefinition(parentScenario, scenario);
};
/**
 * Derive standard {@link CompilationData} properties from an extended scenario
 * definition.
 *
 * @param definition - a scenario definition that has been extended by the
 * default scenario definition
 */
// eslint-disable-next-line complexity
const extendedScenarioDefinitionToCompilationData = (definition) => ({
    ...(definition.data.currentBlockHeight === undefined
        ? {}
        : {
            currentBlockHeight: definition.data.currentBlockHeight,
        }),
    ...(definition.data.currentBlockTime === undefined
        ? {}
        : {
            currentBlockTime: definition.data.currentBlockTime,
        }),
    ...(definition.data.hdKeys === undefined
        ? {}
        : {
            hdKeys: {
                ...(definition.data.hdKeys.addressIndex === undefined
                    ? {}
                    : {
                        addressIndex: definition.data.hdKeys.addressIndex,
                    }),
                ...(definition.data.hdKeys.hdPrivateKeys !== undefined &&
                    Object.keys(definition.data.hdKeys.hdPrivateKeys).length > 0
                    ? {
                        hdPrivateKeys: definition.data.hdKeys.hdPrivateKeys,
                    }
                    : {}),
                ...(definition.data.hdKeys.hdPublicKeys === undefined
                    ? {}
                    : {
                        hdPublicKeys: definition.data.hdKeys.hdPublicKeys,
                    }),
            },
        }),
    ...(definition.data.keys?.privateKeys !== undefined &&
        Object.keys(definition.data.keys.privateKeys).length > 0
        ? {
            keys: {
                privateKeys: Object.entries(definition.data.keys.privateKeys).reduce((all, [id, hex]) => ({ ...all, [id]: hexToBin(hex) }), {}),
            },
        }
        : {}),
});
/**
 * Extend a {@link CompilationData} object with the compiled result of the
 * bytecode scripts provided by an {@link WalletTemplateScenarioData}.
 */
const extendCompilationDataWithScenarioBytecode = ({ compilationData, configuration, scenarioDataBytecodeScripts, }) => {
    const prefixBytecodeScriptId = (id) => `${CompilerDefaults.scenarioBytecodeScriptPrefix}${id}`;
    const bytecodeScripts = Object.entries(scenarioDataBytecodeScripts).reduce((all, [id, script]) => ({
        ...all,
        [prefixBytecodeScriptId(id)]: script,
    }), {});
    const bytecodeScriptExtendedConfiguration = {
        ...configuration,
        scripts: {
            ...configuration.scripts,
            ...bytecodeScripts,
        },
    };
    const bytecodeCompilations = Object.keys(scenarioDataBytecodeScripts).map((id) => {
        const result = compileScriptRaw({
            configuration: bytecodeScriptExtendedConfiguration,
            data: compilationData,
            scriptId: prefixBytecodeScriptId(id),
        });
        if (result.success) {
            return {
                bytecode: result.bytecode,
                id,
            };
        }
        return {
            errors: result.errors,
            id,
        };
    });
    const failedResults = bytecodeCompilations.filter((result) => 'errors' in result);
    if (failedResults.length > 0) {
        return failedResults
            .map((result) => `Compilation error while generating bytecode for "${result.id}": ${stringifyErrors(result.errors)}`)
            .join('; ');
    }
    const compiledBytecode = bytecodeCompilations.reduce((all, result) => ({ ...all, [result.id]: result.bytecode }), {});
    return {
        ...(Object.keys(compiledBytecode).length > 0
            ? { bytecode: compiledBytecode }
            : {}),
        ...compilationData,
    };
};
/**
 * Compile a {@link WalletTemplateScenarioOutput.valueSatoshis},
 * returning the `Uint8Array` result.
 */
const compileWalletTemplateScenarioValueSatoshis = (valueSatoshisDefinition = CompilerDefaults.defaultScenarioOutputValueSatoshis) => typeof valueSatoshisDefinition === 'string'
    ? binToValueSatoshis(hexToBin(valueSatoshisDefinition))
    : BigInt(valueSatoshisDefinition);
/**
 * Compile an {@link WalletTemplateScenarioBytecode} definition for an
 * {@link WalletTemplateScenario}, returning either a
 * simple `Uint8Array` result or a full CashAssembly {@link CompilationResult}.
 */
// eslint-disable-next-line complexity
const compileWalletTemplateScenarioBytecode = ({ bytecodeDefinition, compilationContext, configuration, defaultOverride, extendedScenario, generateBytecode, lockingOrUnlockingScriptIdUnderTest, }) => {
    if (typeof bytecodeDefinition === 'string') {
        return hexToBin(bytecodeDefinition);
    }
    const scriptId = bytecodeDefinition.script === undefined ||
        Array.isArray(bytecodeDefinition.script)
        ? lockingOrUnlockingScriptIdUnderTest
        : bytecodeDefinition.script;
    /**
     * The script ID to compile. If `undefined`, we are attempting to "copy" the
     * script ID in a scenario generation that does not define a locking or
     * unlocking script under test (e.g. the scenario is only used for debugging
     * values in an editor) - in these cases, simply return an empty `Uint8Array`.
     */
    if (scriptId === undefined) {
        return hexToBin('');
    }
    const overrides = bytecodeDefinition.overrides ?? defaultOverride;
    const overriddenDataDefinition = extendScenarioDefinitionData(extendedScenario.data, overrides);
    const data = extendCompilationDataWithScenarioBytecode({
        compilationData: extendedScenarioDefinitionToCompilationData({
            data: overriddenDataDefinition,
        }),
        configuration,
        scenarioDataBytecodeScripts: overriddenDataDefinition.bytecode ?? {},
    });
    if (typeof data === 'string') {
        const error = `Could not compile scenario "data.bytecode": ${data}`;
        return { errors: [{ error }], success: false };
    }
    return generateBytecode({
        data: { ...data, compilationContext },
        debug: true,
        scriptId,
    });
};
/**
 * Compile a {@link WalletTemplateScenarioOutput.token},
 * returning the {@link Output.token} result.
 */
// eslint-disable-next-line complexity
const compileScenarioOutputTokenData = (output) => output.token === undefined
    ? {}
    : {
        token: {
            amount: BigInt(output.token.amount ?? 0),
            // TODO: doesn't verify length
            category: hexToBin(output.token.category ??
                CompilerDefaults.defaultScenarioOutputTokenCategory),
            ...(output.token.nft === undefined
                ? {}
                : {
                    nft: {
                        capability: output.token.nft.capability ?? 'none',
                        commitment: hexToBin(output.token.nft.commitment ?? ''),
                    },
                }),
        },
    };
/**
 * Generate a scenario given a compiler configuration. If neither `scenarioId`
 * or `unlockingScriptId` are provided, the default scenario for the compiler
 * configuration will be generated.
 *
 * Returns either the full `CompilationData` for the selected scenario or an
 * error message (as a `string`).
 *
 * Note, this method should typically not be used directly, use
 * {@link Compiler.generateScenario} instead.
 */
// eslint-disable-next-line complexity
const generateScenarioBCH = ({ configuration, generateBytecode, scenarioId, unlockingScriptId, lockingScriptId: providedLockingScriptId, }, debug) => {
    const { scenarioDefinition, scenarioName } = scenarioId === undefined
        ? { scenarioDefinition: {}, scenarioName: `the default scenario` }
        : {
            scenarioDefinition: configuration.scenarios?.[scenarioId],
            scenarioName: `scenario "${scenarioId}"`,
        };
    if (scenarioDefinition === undefined) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return `Cannot generate ${scenarioName}: a scenario definition with the identifier ${scenarioId} is not included in this compiler configuration.`;
    }
    const parentScenario = generateExtendedScenario({ configuration, scenarioId });
    if (typeof parentScenario === 'string') {
        return `Cannot generate ${scenarioName}: ${parentScenario}`;
    }
    const extendedScenario = extendScenarioDefinition(parentScenario, scenarioDefinition);
    const partialCompilationData = extendedScenarioDefinitionToCompilationData(extendedScenario);
    const fullCompilationData = extendCompilationDataWithScenarioBytecode({
        compilationData: partialCompilationData,
        configuration,
        scenarioDataBytecodeScripts: extendedScenario.data.bytecode ?? {},
    });
    if (typeof fullCompilationData === 'string') {
        return `Cannot generate ${scenarioName}. ${fullCompilationData}`;
    }
    if (extendedScenario.transaction.inputs.length !==
        extendedScenario.sourceOutputs.length) {
        return `Cannot generate ${scenarioName}: could not match source outputs with inputs - "sourceOutputs" must be the same length as "transaction.inputs".`;
    }
    const testedInputs = extendedScenario.transaction.inputs.filter((input) => Array.isArray(input.unlockingBytecode));
    if (testedInputs.length !== 1) {
        return `Cannot generate ${scenarioName}: the specific input under test in this scenario is ambiguous - "transaction.inputs" must include exactly one input that has "unlockingBytecode" set to ["slot"].`;
    }
    const testedInputIndex = extendedScenario.transaction.inputs.findIndex((input) => Array.isArray(input.unlockingBytecode));
    const testedSourceOutputs = extendedScenario.sourceOutputs.filter((output) => Array.isArray(output.lockingBytecode));
    if (testedSourceOutputs.length !== 1) {
        return `Cannot generate ${scenarioName}: the source output unlocked by the input under test in this scenario is ambiguous - "sourceOutputs" must include exactly one output that has "lockingBytecode" set to ["slot"].`;
    }
    if (!Array.isArray(extendedScenario.sourceOutputs[testedInputIndex]?.lockingBytecode)) {
        return `Cannot generate ${scenarioName}: the source output unlocked by the input under test in this scenario is ambiguous - the ["slot"] in "transaction.inputs" and "sourceOutputs" must be at the same index.`;
    }
    if (unlockingScriptId !== undefined &&
        providedLockingScriptId !== undefined) {
        return `Cannot generate ${scenarioName}: a scenario cannot be generated with both unlocking and locking script IDs defined. If an unlocking script is provided, the associated locking script ID must be read from the template.`;
    }
    const lockingScriptId = providedLockingScriptId ??
        (unlockingScriptId === undefined
            ? undefined
            : configuration.unlockingScripts?.[unlockingScriptId]);
    if (unlockingScriptId !== undefined && lockingScriptId === undefined) {
        return `Cannot generate ${scenarioName} using unlocking script "${unlockingScriptId}": the locking script unlocked by "${unlockingScriptId}" is not provided in this compiler configuration.`;
    }
    const sourceOutputCompilations = extendedScenario.sourceOutputs.map((sourceOutput, index) => {
        const slot = Array.isArray(sourceOutput.lockingBytecode);
        const bytecodeDefinition = slot
            ? lockingScriptId === undefined
                ? CompilerDefaults.defaultScenarioBytecode
                : { script: lockingScriptId }
            : sourceOutput.lockingBytecode ?? {};
        const defaultOverride = {};
        return {
            compiled: {
                lockingBytecode: compileWalletTemplateScenarioBytecode({
                    bytecodeDefinition,
                    configuration,
                    defaultOverride,
                    extendedScenario,
                    generateBytecode,
                    lockingOrUnlockingScriptIdUnderTest: lockingScriptId,
                }),
                valueSatoshis: compileWalletTemplateScenarioValueSatoshis(sourceOutput.valueSatoshis),
                ...compileScenarioOutputTokenData(sourceOutput),
            },
            index,
            slot,
            type: 'source output',
        };
    });
    const lockingCompilation = sourceOutputCompilations.find((compilation) => compilation.slot)?.compiled.lockingBytecode;
    const transactionOutputCompilations = extendedScenario.transaction.outputs.map((transactionOutput, index) => {
        const defaultOverride = { hdKeys: { addressIndex: 1 } };
        return {
            compiled: {
                lockingBytecode: compileWalletTemplateScenarioBytecode({
                    bytecodeDefinition: transactionOutput.lockingBytecode ?? {},
                    configuration,
                    defaultOverride,
                    extendedScenario,
                    generateBytecode,
                    lockingOrUnlockingScriptIdUnderTest: lockingScriptId,
                }),
                valueSatoshis: compileWalletTemplateScenarioValueSatoshis(transactionOutput.valueSatoshis),
                ...compileScenarioOutputTokenData(transactionOutput),
            },
            index,
            type: 'transaction output',
        };
    });
    const outputCompilationErrors = [
        ...sourceOutputCompilations,
        ...transactionOutputCompilations,
    ].reduce((accumulated, result) => {
        if ('errors' in result.compiled.lockingBytecode) {
            return [
                ...accumulated,
                ...result.compiled.lockingBytecode.errors.map((errorObject) => `Failed compilation of ${result.type} at index ${result.index}: ${errorObject.error}`),
            ];
        }
        return accumulated;
    }, []);
    if (outputCompilationErrors.length > 0) {
        const error = `Cannot generate ${scenarioName}: ${outputCompilationErrors.join(' ')}`;
        if (debug === true) {
            return {
                lockingCompilation,
                scenario: error,
            };
        }
        return error;
    }
    const sourceOutputCompilationsSuccess = sourceOutputCompilations;
    const transactionOutputCompilationsSuccess = transactionOutputCompilations;
    const extractOutput = (compilation) => {
        const { lockingBytecode, valueSatoshis, token } = compilation.compiled;
        return {
            lockingBytecode: 'bytecode' in lockingBytecode
                ? lockingBytecode.bytecode
                : lockingBytecode,
            valueSatoshis,
            ...(token === undefined ? {} : { token }),
        };
    };
    const sourceOutputs = sourceOutputCompilationsSuccess.map(extractOutput);
    const outputs = transactionOutputCompilationsSuccess.map(extractOutput);
    const inputsContext = extendedScenario.transaction.inputs.map((input, inputIndex) => ({
        outpointIndex: input.outpointIndex ?? inputIndex,
        // TODO: doesn't verify length
        outpointTransactionHash: hexToBin(input.outpointTransactionHash ??
            CompilerDefaults.defaultScenarioInputOutpointTransactionHash),
        sequenceNumber: input.sequenceNumber ??
            CompilerDefaults.defaultScenarioInputSequenceNumber,
        unlockingBytecode: undefined,
    }));
    const transactionInputCompilations = extendedScenario.transaction.inputs.map((input, index) => {
        const slot = Array.isArray(input.unlockingBytecode);
        const bytecodeDefinition = Array.isArray(input.unlockingBytecode)
            ? unlockingScriptId === undefined
                ? CompilerDefaults.defaultScenarioBytecode
                : { script: unlockingScriptId }
            : input.unlockingBytecode ?? {};
        const defaultOverride = {};
        return {
            compiled: {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                outpointIndex: inputsContext[index].outpointIndex,
                outpointTransactionHash: 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                inputsContext[index].outpointTransactionHash,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                sequenceNumber: inputsContext[index].sequenceNumber,
                unlockingBytecode: compileWalletTemplateScenarioBytecode({
                    bytecodeDefinition,
                    compilationContext: {
                        inputIndex: index,
                        sourceOutputs,
                        transaction: {
                            inputs: inputsContext,
                            locktime: extendedScenario.transaction.locktime,
                            outputs,
                            version: extendedScenario.transaction.version,
                        },
                    },
                    configuration,
                    defaultOverride,
                    extendedScenario,
                    generateBytecode,
                    lockingOrUnlockingScriptIdUnderTest: unlockingScriptId,
                }),
            },
            index,
            slot,
        };
    });
    const unlockingCompilation = transactionInputCompilations.find((compilation) => compilation.slot)?.compiled.unlockingBytecode;
    const inputCompilationErrors = transactionInputCompilations.reduce((accumulated, result) => {
        if ('errors' in result.compiled.unlockingBytecode) {
            return [
                ...accumulated,
                ...result.compiled.unlockingBytecode.errors.map((errorObject) => `Failed compilation of input at index ${result.index}: ${errorObject.error}`),
            ];
        }
        return accumulated;
    }, []);
    if (inputCompilationErrors.length > 0) {
        const error = `Cannot generate ${scenarioName}: ${inputCompilationErrors.join(' ')}`;
        if (debug === true) {
            return {
                lockingCompilation,
                scenario: error,
                unlockingCompilation,
            };
        }
        return error;
    }
    const transactionInputCompilationsSuccess = transactionInputCompilations;
    const inputs = transactionInputCompilationsSuccess.map((compilation) => {
        const { outpointIndex, outpointTransactionHash, sequenceNumber, unlockingBytecode, } = compilation.compiled;
        return {
            outpointIndex,
            outpointTransactionHash,
            sequenceNumber,
            unlockingBytecode: 'bytecode' in unlockingBytecode
                ? unlockingBytecode.bytecode
                : unlockingBytecode,
        };
    });
    const scenario = {
        data: fullCompilationData,
        program: {
            inputIndex: testedInputIndex,
            sourceOutputs,
            transaction: {
                inputs,
                locktime: extendedScenario.transaction.locktime,
                outputs,
                version: extendedScenario.transaction.version,
            },
        },
    };
    return (debug === true
        ? { lockingCompilation, scenario, unlockingCompilation }
        : scenario);
};

/**
 * Create a {@link Compiler.generateBytecode} method given a compiler
 * configuration.
 */
const createCompilerGenerateBytecodeFunction = (compilerConfiguration) => ({ data, debug, scriptId, }) => {
    const result = compileScript(scriptId, data, compilerConfiguration);
    return (debug === true
        ? result
        : result.success
            ? { bytecode: result.bytecode, success: true }
            : {
                errorType: result.errorType,
                errors: result.errors,
                success: false,
            });
};
/**
 * Create a {@link Compiler} from the provided compiler configuration. This
 * method requires a full {@link CompilerConfiguration} and does not provide any
 * crypto or VM implementations.
 *
 * @param configuration - the configuration from which to create the compiler
 */
const compilerConfigurationToCompilerBCH = (configuration) => {
    const generateBytecode = createCompilerGenerateBytecodeFunction(configuration);
    return {
        configuration,
        generateBytecode,
        generateScenario: ({ lockingScriptId, unlockingScriptId, scenarioId, debug, }) => generateScenarioBCH({
            configuration,
            generateBytecode,
            lockingScriptId,
            scenarioId,
            unlockingScriptId,
        }, debug),
    };
};
const compilerConfigurationToCompiler = compilerConfigurationToCompilerBCH;
const nullHashLength = 32;
/**
 * A common {@link createAuthenticationProgram} implementation for
 * most compilers.
 *
 * Accepts the compiled contents of an evaluation and produces a
 * {@link AuthenticationProgramCommon} that can be evaluated to produce the
 * resulting program state.
 *
 * The precise shape of the authentication program produced by this method is
 * critical to the determinism of CashAssembly evaluations for the compiler in
 * which it is used, it therefore must be standardized between compiler
 * implementations.
 *
 * @param evaluationBytecode - the compiled bytecode to incorporate in the
 * created authentication program
 */
const createAuthenticationProgramEvaluationCommon = (evaluationBytecode) => ({
    inputIndex: 0,
    sourceOutputs: [
        {
            lockingBytecode: evaluationBytecode,
            valueSatoshis: 0n,
        },
    ],
    transaction: {
        inputs: [
            {
                outpointIndex: 0,
                outpointTransactionHash: new Uint8Array(nullHashLength),
                sequenceNumber: 0,
                unlockingBytecode: Uint8Array.of(),
            },
        ],
        locktime: 0,
        outputs: [
            {
                lockingBytecode: Uint8Array.of(),
                valueSatoshis: 0n,
            },
        ],
        version: 0,
    },
});
/**
 * Create a compiler using the default common compiler configuration. Because
 * this compiler has no access to a VM, it cannot compile evaluations.
 *
 * @param scriptsAndOverrides - a compiler configuration from which properties
 * will be used to override properties of the default common compiler
 * configuration – must include the `scripts` property
 */
const createCompilerCommon = (scriptsAndOverrides) => compilerConfigurationToCompilerBCH({
    ...{
        createAuthenticationProgram: createAuthenticationProgramEvaluationCommon,
        opcodes: generateBytecodeMap(Opcodes),
        operations: compilerOperationsCommon,
        ripemd160: ripemd160,
        secp256k1: secp256k1,
        sha256: sha256,
        sha512: sha512,
    },
    ...scriptsAndOverrides,
});
/**
 * Perform a simplified compilation on a CashAssembly script containing only hex
 * literals, bigint literals, UTF8 literals, and push statements. Scripts may
 * not contain variables/operations, evaluations, or opcode identifiers (use hex
 * literals instead).
 *
 * This is useful for accepting complex user input in advanced interfaces,
 * especially for `AddressData` and `WalletData`.
 *
 * Returns the compiled bytecode as a `Uint8Array`, or throws an error message.
 *
 * @param script - a simple CashAssembly script containing no variables or
 * evaluations
 */
const compileCashAssembly = (script) => {
    const result = createCompilerCommon({
        opcodes: {},
        operations: {},
        scripts: { script },
    }).generateBytecode({ data: {}, scriptId: 'script' });
    if (result.success) {
        return result.bytecode;
    }
    return `CashAssembly compilation error:${result.errors.reduce((all, { error, range }) => `${all} [${range.startLineNumber}, ${range.startColumn}]: ${error}`, '')}`;
};
/**
 * Re-assemble a string of disassembled bytecode
 * (see {@link disassembleBytecode}).
 *
 * @param opcodes - a mapping of opcodes to their respective Uint8Array
 * representation
 * @param disassembledBytecode - the disassembled bytecode to re-assemble
 */
const assembleBytecode = (opcodes, disassembledBytecode) => {
    const configuration = {
        opcodes,
        scripts: { asm: disassembledBytecode },
    };
    return createCompilerCommon(configuration).generateBytecode({ data: {}, scriptId: 'asm' });
};
/**
 * Re-assemble a string of disassembled BCH bytecode; see
 * {@link disassembleBytecodeBCH}.
 *
 * Note, this method performs automatic minimization of push instructions.
 *
 * @param disassembledBytecode - the disassembled BCH bytecode to re-assemble
 */
const assembleBytecodeBCH = (disassembledBytecode) => assembleBytecode(generateBytecodeMap(OpcodesBCH), disassembledBytecode);
/**
 * A convenience method to compile CashAssembly (using
 * {@link assembleBytecodeBCH}) to bytecode. If compilation fails, errors are
 * returned as a string.
 */
const cashAssemblyToBin = (cashAssemblyScript) => {
    const result = assembleBytecodeBCH(cashAssemblyScript);
    return result.success
        ? result.bytecode
        : `CashAssembly compilation ${result.errorType} error: ${result.errors
            .map((err) => err.error)
            .join(' ')}`;
};
/**
 * Re-assemble a string of disassembled BCH bytecode; see
 * {@link disassembleBytecodeBTC}.
 *
 * Note, this method performs automatic minimization of push instructions.
 *
 * @param disassembledBytecode - the disassembled BTC bytecode to re-assemble
 */
const assembleBytecodeBTC = (disassembledBytecode) => assembleBytecode(generateBytecodeMap(OpcodesBTC), disassembledBytecode);
/**
 * Create a partial {@link CompilerConfiguration} from an
 * {@link WalletTemplate} by extracting and formatting the `scripts` and
 * `variables` properties.
 *
 * Note, if this {@link WalletTemplate} might be malformed, first
 * validate it with {@link importWalletTemplate}.
 *
 * @param template - the {@link WalletTemplate} from which to extract
 * the compiler configuration
 */
const walletTemplateToCompilerConfiguration = (template) => {
    /**
     * Template scripts including virtualized test scripts.
     */
    const virtualizedScripts = Object.entries(template.scripts).reduce((all, [scriptId, script]) => {
        if ('tests' in script) {
            return {
                ...all,
                ...Object.entries(script.tests).reduce((tests, [testId, test]) => {
                    const pushTestedScript = script.pushed === true;
                    const checkScriptId = `${scriptId}.${testId}.check`;
                    const virtualizedLockingScriptId = `${scriptId}.${testId}.lock`;
                    const virtualizedUnlockingScriptId = `${scriptId}.${testId}.unlock`;
                    return {
                        ...tests,
                        [checkScriptId]: { script: test.check },
                        [virtualizedLockingScriptId]: {
                            lockingType: 'p2sh20',
                            script: pushTestedScript
                                ? `<${scriptId}> ${checkScriptId}`
                                : `${scriptId} ${checkScriptId}`,
                        },
                        [virtualizedUnlockingScriptId]: {
                            script: test.setup ?? '',
                            unlocks: virtualizedLockingScriptId,
                        },
                    };
                }, {}),
            };
        }
        return all;
    }, {});
    const allScripts = {
        ...template.scripts,
        ...virtualizedScripts,
    };
    const scripts = Object.entries(allScripts).reduce((all, [id, def]) => ({ ...all, [id]: def.script }), {});
    const variables = Object.values(template.entities).reduce((all, entity) => ({ ...all, ...entity.variables }), {});
    const entityOwnership = Object.entries(template.entities).reduce((all, [entityId, entity]) => ({
        ...all,
        ...Object.keys(entity.variables ?? {}).reduce((entityVariables, variableId) => ({
            ...entityVariables,
            [variableId]: entityId,
        }), {}),
    }), {});
    const unlockingScripts = Object.entries(allScripts).reduce((all, [id, def]) => 'unlocks' in def && def.unlocks !== undefined
        ? { ...all, [id]: def.unlocks }
        : all, {});
    const unlockingScriptTimeLockTypes = Object.entries(allScripts).reduce((all, [id, def]) => 'timeLockType' in def && def.timeLockType !== undefined
        ? { ...all, [id]: def.timeLockType }
        : all, {});
    const lockingScriptTypes = Object.entries(allScripts).reduce((all, [id, def]) => 'lockingType' in def &&
        def.lockingType !== undefined
        ? { ...all, [id]: def.lockingType }
        : all, {});
    const scenarios = template.scenarios === undefined
        ? undefined
        : Object.entries(template.scenarios).reduce((all, [id, def]) => ({ ...all, [id]: def }), {});
    return {
        entityOwnership,
        lockingScriptTypes,
        ...(scenarios === undefined ? {} : { scenarios }),
        scripts,
        unlockingScriptTimeLockTypes,
        unlockingScripts,
        variables,
    };
};

var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
    /**
     * A.K.A. `SIGHASH_ALL|SIGHASH_FORKID`
     */
    SigningSerializationAlgorithmIdentifier["allOutputs"] = "all_outputs";
    /**
     * A.K.A. `SIGHASH_ALL|SIGHASH_UTXOS|SIGHASH_FORKID`
     */
    SigningSerializationAlgorithmIdentifier["allOutputsAllUtxos"] = "all_outputs_all_utxos";
    /**
     * A.K.A. `SIGHASH_ALL|SIGHASH_FORKID|ANYONECANPAY`
     */
    SigningSerializationAlgorithmIdentifier["allOutputsSingleInput"] = "all_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_ALL|SIGHASH_UTXOS|SIGHASH_FORKID|ANYONECANPAY`
     */
    SigningSerializationAlgorithmIdentifier["allOutputsSingleInputInvalidAllUtxos"] = "all_outputs_single_input_INVALID_all_utxos";
    /**
     * A.K.A. `SIGHASH_SINGLE|SIGHASH_FORKID`
     */
    SigningSerializationAlgorithmIdentifier["correspondingOutput"] = "corresponding_output";
    /**
     * A.K.A. `SIGHASH_SINGLE|SIGHASH_UTXOS|SIGHASH_FORKID`
     */
    SigningSerializationAlgorithmIdentifier["correspondingOutputAllUtxos"] = "corresponding_output_all_utxos";
    /**
     * A.K.A. `SIGHASH_SINGLE|SIGHASH_FORKID|ANYONECANPAY`
     */
    SigningSerializationAlgorithmIdentifier["correspondingOutputSingleInput"] = "corresponding_output_single_input";
    /**
     * A.K.A. `SIGHASH_SINGLE|SIGHASH_UTXOS|SIGHASH_FORKID|ANYONECANPAY`
     */
    SigningSerializationAlgorithmIdentifier["correspondingOutputSingleInputInvalidAllUtxos"] = "corresponding_output_single_input_INVALID_all_utxos";
    /**
     * An alias for `all_outputs_all_utxos`
     * (A.K.A. `SIGHASH_ALL|SIGHASH_UTXOS|SIGHASH_FORKID`),
     * the most secure signing serialization algorithm.
     *
     * Note that as of 2022, `all_outputs` (A.K.A. `SIGHASH_ALL|SIGHASH_FORKID`)
     * is more commonly used and is therefore a better choice for privacy in
     * common, existing contract types.
     */
    SigningSerializationAlgorithmIdentifier["default"] = "default";
    /**
     * A.K.A `SIGHASH_NONE|SIGHASH_FORKID`
     */
    SigningSerializationAlgorithmIdentifier["noOutputs"] = "no_outputs";
    /**
     * A.K.A `SIGHASH_NONE|SIGHASH_UTXOS|SIGHASH_FORKID`
     */
    SigningSerializationAlgorithmIdentifier["noOutputsAllUtxos"] = "no_outputs_all_utxos";
    /**
     * A.K.A `SIGHASH_NONE|SIGHASH_FORKID|ANYONECANPAY`
     */
    SigningSerializationAlgorithmIdentifier["noOutputsSingleInput"] = "no_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_NONE|SIGHASH_UTXOS|SIGHASH_FORKID|ANYONECANPAY`
     */
    SigningSerializationAlgorithmIdentifier["noOutputsSingleInputInvalidAllUtxos"] = "no_outputs_single_input_INVALID_all_utxos";
})(SigningSerializationAlgorithmIdentifier || (SigningSerializationAlgorithmIdentifier = {}));
// eslint-disable-next-line complexity
const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
    switch (algorithmIdentifier) {
        case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputs}`:
            return Uint8Array.of(SigningSerializationTypeBCH.allOutputs);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsAllUtxos}`:
        case `${prefix}${SigningSerializationAlgorithmIdentifier.default}`:
            return Uint8Array.of(SigningSerializationTypeBCH.allOutputsAllUtxos);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsSingleInput}`:
            return Uint8Array.of(SigningSerializationTypeBCH.allOutputsSingleInput);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsSingleInputInvalidAllUtxos}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.allOutputs |
                SigningSerializationFlag.singleInput |
                SigningSerializationFlag.utxos |
                SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutput}`:
            return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutput);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputAllUtxos}`:
            return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutputAllUtxos);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInput}`:
            return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutputSingleInput);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInputInvalidAllUtxos}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.correspondingOutput |
                SigningSerializationFlag.singleInput |
                SigningSerializationFlag.utxos |
                SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputs}`:
            return Uint8Array.of(SigningSerializationTypeBCH.noOutputs);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsAllUtxos}`:
            return Uint8Array.of(SigningSerializationTypeBCH.noOutputsAllUtxos);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsSingleInput}`:
            return Uint8Array.of(SigningSerializationTypeBCH.noOutputsSingleInput);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsSingleInputInvalidAllUtxos}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.noOutputs |
                SigningSerializationFlag.singleInput |
                SigningSerializationFlag.utxos |
                SigningSerializationFlag.forkId);
        default:
            return undefined;
    }
};
const compilerOperationHelperComputeSignatureBCH = ({ coveredBytecode, identifier, compilationContext, operationName, privateKey, sha256, sign, }) => {
    const [, , algorithm, unknown] = identifier.split('.');
    if (unknown !== undefined) {
        return {
            error: `Unknown component in "${identifier}" - the fragment "${unknown}" is not recognized.`,
            status: 'error',
        };
    }
    if (algorithm === undefined) {
        return {
            error: `Invalid signature identifier. Signatures must be of the form: "[variable_id].${operationName}.[signing_serialization_type]".`,
            status: 'error',
        };
    }
    const signingSerializationType = getSigningSerializationType(algorithm);
    if (signingSerializationType === undefined) {
        return {
            error: `Unknown signing serialization algorithm, "${algorithm}".`,
            status: 'error',
        };
    }
    const serialization = generateSigningSerializationBCH(compilationContext, { coveredBytecode, signingSerializationType }, sha256);
    const digest = hash256(serialization, sha256);
    const bitcoinEncodedSignature = Uint8Array.from([
        ...sign(privateKey, digest),
        ...signingSerializationType,
    ]);
    return {
        bytecode: bitcoinEncodedSignature,
        signature: { serialization },
        status: 'success',
    };
};
const compilerOperationHelperHdKeySignatureBCH = ({ operationName, secp256k1Method, }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [
        'entityOwnership',
        'ripemd160',
        'secp256k1',
        'sha256',
        'sha512',
        'variables',
        'sourceScriptIds',
        'unlockingScripts',
    ],
    dataProperties: ['hdKeys', 'compilationContext'],
    operation: (identifier, data, configuration) => {
        const { hdKeys, compilationContext } = data;
        const { secp256k1, sha256, sourceScriptIds, unlockingScripts } = configuration;
        const derivationResult = compilerOperationHelperDeriveHdKeyPrivate({
            configuration,
            hdKeys,
            identifier,
        });
        if (derivationResult.status === 'error')
            return derivationResult;
        const result = compilerOperationHelperGenerateCoveredBytecode({
            configuration,
            data,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        return compilerOperationHelperComputeSignatureBCH({
            compilationContext,
            coveredBytecode: result,
            identifier,
            operationName,
            privateKey: derivationResult.bytecode,
            sha256,
            sign: secp256k1[secp256k1Method],
        });
    },
}));
const compilerOperationHdKeyEcdsaSignatureBCH = compilerOperationHelperHdKeySignatureBCH({
    operationName: 'ecdsa_signature',
    secp256k1Method: 'signMessageHashDER',
});
const compilerOperationHdKeySchnorrSignatureBCH = compilerOperationHelperHdKeySignatureBCH({
    operationName: 'schnorr_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
const compilerOperationHelperKeySignatureBCH = ({ operationName, secp256k1Method, }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [
        'sha256',
        'secp256k1',
        'unlockingScripts',
        'sourceScriptIds',
    ],
    dataProperties: ['keys', 'compilationContext'],
    operation: (identifier, data, configuration) => {
        const { keys, compilationContext } = data;
        const { secp256k1, sha256, unlockingScripts, sourceScriptIds } = configuration;
        const { privateKeys } = keys;
        const [variableId] = identifier.split('.');
        const privateKey = privateKeys === undefined ? undefined : privateKeys[variableId];
        if (privateKey === undefined) {
            return {
                error: `Identifier "${identifier}" refers to a Key, but a private key for "${variableId}" (or an existing signature) was not provided in the compilation data.`,
                recoverable: true,
                status: 'error',
            };
        }
        const result = compilerOperationHelperGenerateCoveredBytecode({
            configuration,
            data,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        return compilerOperationHelperComputeSignatureBCH({
            compilationContext,
            coveredBytecode: result,
            identifier,
            operationName,
            privateKey,
            sha256,
            sign: secp256k1[secp256k1Method],
        });
    },
}));
const compilerOperationKeyEcdsaSignatureBCH = compilerOperationHelperKeySignatureBCH({
    operationName: 'ecdsa_signature',
    secp256k1Method: 'signMessageHashDER',
});
const compilerOperationKeySchnorrSignatureBCH = compilerOperationHelperKeySignatureBCH({
    operationName: 'schnorr_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
const compilerOperationHelperComputeDataSignatureBCH = ({ data, configuration, identifier, operationName, privateKey, sha256, sign, }) => {
    const [, , scriptId, unknown] = identifier.split('.');
    if (unknown !== undefined) {
        return {
            error: `Unknown component in "${identifier}" - the fragment "${unknown}" is not recognized.`,
            status: 'error',
        };
    }
    if (scriptId === undefined) {
        return {
            error: `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${operationName}.[target_script_id]".`,
            status: 'error',
        };
    }
    const result = compilerOperationHelperCompileScript({
        configuration,
        data,
        targetScriptId: scriptId,
    });
    if (result === false) {
        return {
            error: `Data signature tried to sign an unknown target script, "${scriptId}".`,
            status: 'error',
        };
    }
    if ('error' in result) {
        return result;
    }
    const digest = sha256.hash(result);
    return {
        bytecode: sign(privateKey, digest),
        signature: { digest, message: result },
        status: 'success',
    };
};
const compilerOperationHelperKeyDataSignatureBCH = ({ operationName, secp256k1Method, }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256', 'secp256k1'],
    dataProperties: ['keys'],
    operation: (identifier, data, configuration) => {
        const { keys } = data;
        const { secp256k1, sha256 } = configuration;
        const { privateKeys } = keys;
        const [variableId] = identifier.split('.');
        const privateKey = privateKeys === undefined ? undefined : privateKeys[variableId];
        if (privateKey === undefined) {
            return {
                error: `Identifier "${identifier}" refers to a Key, but a private key for "${variableId}" (or an existing signature) was not provided in the compilation data.`,
                recoverable: true,
                status: 'error',
            };
        }
        return compilerOperationHelperComputeDataSignatureBCH({
            configuration,
            data,
            identifier,
            operationName,
            privateKey,
            sha256,
            sign: secp256k1[secp256k1Method],
        });
    },
}));
const compilerOperationKeyEcdsaDataSignatureBCH = compilerOperationHelperKeyDataSignatureBCH({
    operationName: 'ecdsa_data_signature',
    secp256k1Method: 'signMessageHashDER',
});
const compilerOperationKeySchnorrDataSignatureBCH = compilerOperationHelperKeyDataSignatureBCH({
    operationName: 'schnorr_data_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
const compilerOperationHelperHdKeyDataSignatureBCH = ({ operationName, secp256k1Method, }) => attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [
        'entityOwnership',
        'ripemd160',
        'secp256k1',
        'sha256',
        'sha512',
        'variables',
    ],
    dataProperties: ['hdKeys'],
    operation: (identifier, data, configuration) => {
        const { hdKeys } = data;
        const { secp256k1, sha256 } = configuration;
        const derivationResult = compilerOperationHelperDeriveHdKeyPrivate({
            configuration,
            hdKeys,
            identifier,
        });
        if (derivationResult.status === 'error')
            return derivationResult;
        return compilerOperationHelperComputeDataSignatureBCH({
            configuration,
            data,
            identifier,
            operationName,
            privateKey: derivationResult.bytecode,
            sha256,
            sign: secp256k1[secp256k1Method],
        });
    },
}));
const compilerOperationHdKeyEcdsaDataSignatureBCH = compilerOperationHelperHdKeyDataSignatureBCH({
    operationName: 'ecdsa_data_signature',
    secp256k1Method: 'signMessageHashDER',
});
const compilerOperationHdKeySchnorrDataSignatureBCH = compilerOperationHelperHdKeyDataSignatureBCH({
    operationName: 'schnorr_data_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
const compilerOperationSigningSerializationTokenPrefix = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: [],
    dataProperties: ['compilationContext'],
    operation: (_, data) => ({
        bytecode: encodeTokenPrefix(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        data.compilationContext.sourceOutputs[data.compilationContext.inputIndex].token),
        status: 'success',
    }),
});
const compilerOperationSignatureRenamed = (identifier) => ({
    error: `The "signature" compiler operation was renamed to "ecdsa_signature". Consider fixing this error by changing "${identifier}" to "${identifier.replace('signature', 'schnorr_signature')}" (schnorr signatures reduce transaction sizes and enable multi-party signature aggregation).`,
    status: 'error',
});
const compilerOperationDataSignatureRenamed = (identifier) => ({
    error: `The "data_signature" compiler operation was renamed to "ecdsa_data_signature". Consider fixing this error by changing "${identifier}" to "${identifier.replace('data_signature', 'schnorr_data_signature')}" (schnorr signatures reduce transaction sizes and enable multi-party signature aggregation).`,
    status: 'error',
});
const compilerOperationSigningSerializationFullBCH = compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256', 'sourceScriptIds', 'unlockingScripts'],
    dataProperties: ['compilationContext'],
    operation: (identifier, data, configuration) => {
        const [, algorithmOrComponent, unknownPart] = identifier.split('.');
        if (algorithmOrComponent === undefined) {
            return {
                error: `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version".`,
                status: 'error',
            };
        }
        if (unknownPart !== undefined) {
            return {
                error: `Unknown component in "${identifier}" - the fragment "${unknownPart}" is not recognized.`,
                status: 'error',
            };
        }
        const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
        if (signingSerializationType === undefined) {
            return {
                error: `Unknown signing serialization algorithm, "${algorithmOrComponent}".`,
                status: 'error',
            };
        }
        const { sha256, sourceScriptIds, unlockingScripts } = configuration;
        const result = compilerOperationHelperGenerateCoveredBytecode({
            configuration,
            data,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        const { compilationContext } = data;
        return {
            bytecode: generateSigningSerializationBCH(compilationContext, {
                coveredBytecode: result,
                signingSerializationType,
            }, sha256),
            status: 'success',
        };
    },
});
/* eslint-disable camelcase, @typescript-eslint/naming-convention */
const compilerOperationsBCH = {
    ...compilerOperationsCommon,
    hdKey: {
        data_signature: compilerOperationDataSignatureRenamed,
        ecdsa_data_signature: compilerOperationHdKeyEcdsaDataSignatureBCH,
        ecdsa_signature: compilerOperationHdKeyEcdsaSignatureBCH,
        public_key: compilerOperationsCommon.hdKey.public_key,
        schnorr_data_signature: compilerOperationHdKeySchnorrDataSignatureBCH,
        schnorr_signature: compilerOperationHdKeySchnorrSignatureBCH,
        signature: compilerOperationSignatureRenamed,
    },
    key: {
        data_signature: compilerOperationDataSignatureRenamed,
        ecdsa_data_signature: compilerOperationKeyEcdsaDataSignatureBCH,
        ecdsa_signature: compilerOperationKeyEcdsaSignatureBCH,
        public_key: compilerOperationsCommon.key.public_key,
        schnorr_data_signature: compilerOperationKeySchnorrDataSignatureBCH,
        schnorr_signature: compilerOperationKeySchnorrSignatureBCH,
        signature: compilerOperationSignatureRenamed,
    },
    signingSerialization: {
        ...compilerOperationsCommon.signingSerialization,
        full_all_outputs: compilerOperationSigningSerializationFullBCH,
        full_all_outputs_all_utxos: compilerOperationSigningSerializationFullBCH,
        full_all_outputs_single_input: compilerOperationSigningSerializationFullBCH,
        full_all_outputs_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
        full_corresponding_output: compilerOperationSigningSerializationFullBCH,
        full_corresponding_output_all_utxos: compilerOperationSigningSerializationFullBCH,
        full_corresponding_output_single_input: compilerOperationSigningSerializationFullBCH,
        full_corresponding_output_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
        full_default: compilerOperationSigningSerializationFullBCH,
        full_no_outputs: compilerOperationSigningSerializationFullBCH,
        full_no_outputs_all_utxos: compilerOperationSigningSerializationFullBCH,
        full_no_outputs_single_input: compilerOperationSigningSerializationFullBCH,
        full_no_outputs_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
        token_prefix: compilerOperationSigningSerializationTokenPrefix,
    },
};
/**
 * Create a compiler using the default BCH compiler configuration.
 *
 * Internally instantiates the necessary crypto and VM implementations – use
 * {@link compilerConfigurationToCompilerBCH} for more control.
 *
 * @param configuration - a compiler configuration from which properties
 * will be used to override properties of the default BCH configuration – must
 * include the `scripts` property
 */
const createCompilerBCH = (configuration) => compilerConfigurationToCompilerBCH({
    ...{
        createAuthenticationProgram: createAuthenticationProgramEvaluationCommon,
        opcodes: generateBytecodeMap(OpcodesBCHCHIPs),
        operations: compilerOperationsBCH,
        ripemd160: ripemd160,
        secp256k1: secp256k1,
        sha256: sha256,
        sha512: sha512,
        vm: configuration.vm ?? createVirtualMachineBCH(),
    },
    ...configuration,
});
const createCompiler = createCompilerBCH;
/**
 * Create a BCH `Compiler` from an `WalletTemplate` and an optional set
 * of overrides.
 * @param template - the `WalletTemplate` from which to create the BCH
 * compiler
 * @param overrides - a compiler configuration from which properties will be
 * used to override properties of the default BCH configuration
 */
const walletTemplateToCompilerBCH = (template, overrides) => createCompilerBCH({
    ...overrides,
    ...walletTemplateToCompilerConfiguration(template),
});

/**
 * A standard single-factor wallet template that uses
 * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use
 * on the network.
 *
 * This P2PKH template uses BCH Schnorr signatures, reducing the size of
 * transactions.
 *
 * Note, this wallet template uses only a single `Key`. For HD key
 * support, see {@link walletTemplateP2pkhHd}.
 */
const walletTemplateP2pkhNonHd = {
    $schema: 'https://libauth.org/schemas/wallet-template-v0.schema.json',
    description: 'A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\n\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions.',
    entities: {
        owner: {
            description: 'The individual who can spend from this wallet.',
            name: 'Owner',
            scripts: ['lock', 'unlock'],
            variables: {
                key: {
                    description: 'The private key that controls this wallet.',
                    name: 'Key',
                    type: 'Key',
                },
            },
        },
    },
    name: 'Single Signature (P2PKH)',
    scripts: {
        lock: {
            lockingType: 'standard',
            name: 'P2PKH Lock',
            script: 'OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG',
        },
        unlock: {
            name: 'Unlock',
            script: '<key.schnorr_signature.all_outputs>\n<key.public_key>',
            unlocks: 'lock',
        },
    },
    supported: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05'],
    version: 0,
};
/**
 * A standard single-factor wallet template that uses
 * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use
 * on the network.
 *
 * This P2PKH template uses BCH Schnorr signatures, reducing the size of
 * transactions.
 *
 * Because the template uses a Hierarchical Deterministic (HD) key, it also
 * supports watch-only clients.
 */
const walletTemplateP2pkh = {
    $schema: 'https://libauth.org/schemas/wallet-template-v0.schema.json',
    description: 'A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\n\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions. Because the template uses a Hierarchical Deterministic (HD) key, it also supports watch-only clients.',
    entities: {
        owner: {
            description: 'The individual who can spend from this wallet.',
            name: 'Owner',
            scripts: ['lock', 'unlock'],
            variables: {
                key: {
                    description: 'The private key that controls this wallet.',
                    name: 'Key',
                    type: 'HdKey',
                },
            },
        },
    },
    name: 'Single Signature (P2PKH)',
    scripts: {
        lock: {
            lockingType: 'standard',
            name: 'P2PKH Lock',
            script: 'OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG',
        },
        unlock: {
            name: 'Unlock',
            script: '<key.schnorr_signature.all_outputs>\n<key.public_key>',
            unlocks: 'lock',
        },
    },
    supported: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05'],
    version: 0,
};

var P2pkhUtilityError;
(function (P2pkhUtilityError) {
    P2pkhUtilityError["hdPrivateKeyToP2pkhLockingBytecodeCompilation"] = "P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD private key.";
    P2pkhUtilityError["hdPublicKeyToP2pkhLockingBytecodeCompilation"] = "P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD public key.";
    P2pkhUtilityError["privateKeyToP2pkhLockingBytecodeCompilation"] = "P2PKH utility error: could not derive P2PKH locking bytecode from the provided private key.";
    P2pkhUtilityError["publicKeyToP2pkhLockingBytecodeCompilation"] = "P2PKH utility error: could not derive P2PKH locking bytecode from the provided public key.";
})(P2pkhUtilityError || (P2pkhUtilityError = {}));
/**
 * Derive the P2PKH locking bytecode of the provided private key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid private key. To handle errors in a type-safe way, set `throwErrors`
 * to `false`.
 *
 * To derive the resulting CashAddress, use
 * {@link privateKeyToP2pkhCashAddress}. For HD private keys, use
 * {@link hdPrivateKeyToP2pkhLockingBytecode}. For the public key equivalent,
 * see {@link publicKeyToP2pkhLockingBytecode}.
 */
const privateKeyToP2pkhLockingBytecode = ({ privateKey, throwErrors = true, }) => {
    const compiler = walletTemplateToCompilerBCH(walletTemplateP2pkhNonHd);
    const lockingBytecode = compiler.generateBytecode({
        data: { keys: { privateKeys: { key: privateKey } } },
        scriptId: 'lock',
    });
    if (!lockingBytecode.success) {
        return formatError(P2pkhUtilityError.privateKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);
    }
    return lockingBytecode.bytecode;
};
/**
 * Derive the P2PKH locking bytecode of the provided public key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid public key. To handle errors in a type-safe way, set `throwErrors`
 * to `false`.
 *
 * To derive the resulting CashAddress, use {@link publicKeyToP2pkhCashAddress}.
 * For HD public keys, use {@link hdPublicKeyToP2pkhLockingBytecode}. For the
 * private key equivalent, see {@link privateKeyToP2pkhLockingBytecode}.
 */
const publicKeyToP2pkhLockingBytecode = ({ publicKey, throwErrors = true, }) => {
    const compiler = walletTemplateToCompilerBCH(walletTemplateP2pkhNonHd);
    const lockingBytecode = compiler.generateBytecode({
        // eslint-disable-next-line @typescript-eslint/naming-convention
        data: { bytecode: { 'key.public_key': publicKey } },
        scriptId: 'lock',
    });
    if (!lockingBytecode.success) {
        return formatError(P2pkhUtilityError.publicKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);
    }
    return lockingBytecode.bytecode;
};
/**
 * Derive the P2PKH locking bytecode at the provided path and address index of
 * the provided HD private key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid HD private key or derivation path. To handle errors in a type-safe
 * way, set `throwErrors` to `false`.
 *
 * To derive the resulting CashAddress, use
 * {@link hdPrivateKeyToP2pkhCashAddress}. For non-HD private keys, use
 * {@link privateKeyToP2pkhLockingBytecode}. For the HD public key equivalent,
 * see {@link hdPublicKeyToP2pkhLockingBytecode}.
 */
const hdPrivateKeyToP2pkhLockingBytecode = ({ addressIndex, hdPrivateKey, privateDerivationPath = 'i', throwErrors = true, }) => {
    const template = structuredClone(walletTemplateP2pkh);
    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
    template.entities.owner.variables.key.privateDerivationPath =
        privateDerivationPath;
    const compiler = walletTemplateToCompilerBCH(template);
    const lockingBytecode = compiler.generateBytecode({
        data: { hdKeys: { addressIndex, hdPrivateKeys: { owner: hdPrivateKey } } },
        scriptId: 'lock',
    });
    if (!lockingBytecode.success) {
        return formatError(P2pkhUtilityError.hdPrivateKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);
    }
    return lockingBytecode.bytecode;
};
/**
 * Derive the P2PKH locking bytecode at the provided index of the provided HD
 * public key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid HD public key. To handle errors in a type-safe way, set `throwErrors`
 * to `false`.
 *
 * To derive the resulting CashAddress, use
 * {@link hdPublicKeyToP2pkhCashAddress}. For non-HD public keys, use
 * {@link publicKeyToP2pkhLockingBytecode}. For the HD private key equivalent,
 * see {@link hdPrivateKeyToP2pkhLockingBytecode}.
 */
const hdPublicKeyToP2pkhLockingBytecode = ({ addressIndex, hdPublicKey, hdPublicKeyDerivationPath = '', throwErrors = true, publicDerivationPath = 'i', }) => {
    const template = structuredClone(walletTemplateP2pkh);
    /* eslint-disable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */
    template.entities.owner.variables.key.publicDerivationPath =
        publicDerivationPath;
    template.entities.owner.variables.key.hdPublicKeyDerivationPath =
        hdPublicKeyDerivationPath;
    template.entities.owner.variables.key.privateDerivationPath =
        hdPublicKeyDerivationPath === ''
            ? publicDerivationPath
            : `${hdPublicKeyDerivationPath}/${publicDerivationPath}`;
    /* eslint-enable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */
    const compiler = walletTemplateToCompilerBCH(template);
    const lockingBytecode = compiler.generateBytecode({
        data: { hdKeys: { addressIndex, hdPublicKeys: { owner: hdPublicKey } } },
        scriptId: 'lock',
    });
    if (!lockingBytecode.success) {
        return formatError(P2pkhUtilityError.hdPublicKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);
    }
    return lockingBytecode.bytecode;
};
/**
 * Derive the P2PKH address of the provided private key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid private key. To handle errors in a type-safe way, set `throwErrors`
 * to `false`.
 *
 * To derive only the locking bytecode, use
 * {@link privateKeyToP2pkhLockingBytecode}. For HD private keys, use
 * {@link hdPrivateKeyToP2pkhCashAddress}. For the public key equivalent,
 * see {@link publicKeyToP2pkhCashAddress}.
 */
const privateKeyToP2pkhCashAddress = ({ privateKey, prefix = 'bitcoincash', throwErrors = true, tokenSupport = false, }) => {
    const bytecode = privateKeyToP2pkhLockingBytecode({
        privateKey,
        throwErrors,
    });
    if (typeof bytecode === 'string') {
        return formatError(bytecode, undefined, throwErrors);
    }
    return lockingBytecodeToCashAddress({
        bytecode,
        prefix,
        tokenSupport,
    });
};
/**
 * Derive the P2PKH address of the provided public key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid public key. To handle errors in a type-safe way, set `throwErrors`
 * to `false`.
 *
 * To derive only the locking bytecode, use
 * {@link publicKeyToP2pkhLockingBytecode}. For HD public keys, use
 * {@link hdPublicKeyToP2pkhCashAddress}. For the private key equivalent,
 * see {@link privateKeyToP2pkhCashAddress}.
 */
const publicKeyToP2pkhCashAddress = ({ publicKey, prefix = 'bitcoincash', throwErrors = true, tokenSupport = false, }) => {
    const bytecode = publicKeyToP2pkhLockingBytecode({
        publicKey,
        throwErrors,
    });
    if (typeof bytecode === 'string') {
        return formatError(bytecode, undefined, throwErrors);
    }
    return lockingBytecodeToCashAddress({
        bytecode,
        prefix,
        tokenSupport,
    });
};
/**
 * Derive the P2PKH address at the provided index of the provided HD
 * private key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid HD private key or derivation path. To handle errors in a type-safe
 * way, set `throwErrors` to `false`.
 *
 * To derive only the locking bytecode, use
 * {@link hdPrivateKeyToP2pkhLockingBytecode}. For non-HD private keys, use
 * {@link privateKeyToP2pkhCashAddress}. For the HD public key equivalent,
 * see {@link hdPublicKeyToP2pkhCashAddress}.
 */
const hdPrivateKeyToP2pkhCashAddress = ({ addressIndex, hdPrivateKey, prefix = 'bitcoincash', privateDerivationPath = 'i', throwErrors = true, tokenSupport = false, }) => {
    const bytecode = hdPrivateKeyToP2pkhLockingBytecode({
        addressIndex,
        hdPrivateKey,
        privateDerivationPath,
        throwErrors,
    });
    if (typeof bytecode === 'string') {
        return formatError(bytecode, undefined, throwErrors);
    }
    return lockingBytecodeToCashAddress({
        bytecode,
        prefix,
        tokenSupport,
    });
};
/**
 * Derive the P2PKH address at the provided index of the provided HD
 * public key.
 *
 * Note that this function defaults to throwing an error if provided with an
 * invalid HD public key. To handle errors in a type-safe way, set `throwErrors`
 * to `false`.
 *
 * To derive only the locking bytecode, use
 * {@link hdPublicKeyToP2pkhLockingBytecode}. For non-HD public keys, use
 * {@link publicKeyToP2pkhCashAddress}. For the HD private key equivalent,
 * see {@link hdPrivateKeyToP2pkhCashAddress}.
 */
const hdPublicKeyToP2pkhCashAddress = ({ addressIndex, hdPublicKey, hdPublicKeyDerivationPath = '', prefix = 'bitcoincash', publicDerivationPath = 'i', throwErrors = true, tokenSupport = false, }) => {
    const bytecode = hdPublicKeyToP2pkhLockingBytecode({
        addressIndex,
        hdPublicKey,
        hdPublicKeyDerivationPath,
        publicDerivationPath,
        throwErrors,
    });
    if (typeof bytecode === 'string') {
        return formatError(bytecode, undefined, throwErrors);
    }
    return lockingBytecodeToCashAddress({
        bytecode,
        prefix,
        tokenSupport,
    });
};

const schema38 = {
    properties: {
        lockingType: {
            enum: ['p2sh20', 'p2sh32', 'standard']}}};
const schema41 = {
    properties: {
        ageLock: {
            description: 'TODO: not yet implemented\n\nThe minimum input age required for this unlocking script to become valid.\n\nThis value is provided as a CashAssembly script that must compile to the least significant 3 bytes of the minimum sequence number required for this unlocking script to be valid (the "type bit" and the 2-byte "value" – see BIP68 for details). This script has access to all other template scripts and variables, but cyclical references will produce an error at compile time.\n\nIn supporting wallets, this value can be computed at address creation time, and the remaining time for which any UTXO remains "age-locked" can be displayed in user interfaces (by parsing the "type bit" and "value" as described in BIP68).\n\nNote, because the precise value used by `OP_CHECKSEQUENCEVERIFY` can be provided in the unlocking script, it is trivial to create an unlocking script for which a proper value for `ageLock` is not possible to determine until the spending transaction is prepared. These cases are intentionally out-of-scope for this property. Instead, `ageLock` should only be used for unlocking scripts where the expected value can be compiled at address creation time.',
            type: 'string',
        },
        estimate: {
            description: 'The identifier of the scenario to use for this unlocking script when compiling an estimated transaction.\n\nUsing estimate scenarios, it\'s possible for wallet software to compute an "estimated transaction", an invalid transaction that is guaranteed to be the same byte length as the final transaction. This length can be used to calculate the required transaction fee and assign values to the transaction\'s change output(s). Because estimate scenarios provide "estimated" values for all variables, this estimation can be done by a single entity without input from other entities.\n\nIf not provided, the default scenario will be used for estimation. The default scenario only provides values for each `Key` and `HdKey` variable, so compilations requiring other variables will produce errors. See `WalletTemplateScenario.extends` for details.',
            type: 'string',
        },
        fails: {
            description: 'A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in bytecode that fails program verification.\n\nThese scenarios can be used to test this script in development and review.',
            items: { type: 'string' },
            type: 'array',
        },
        invalid: {
            description: 'A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in a compilation error.\n\nThese scenarios can be used to test this script in development and review.',
            items: { type: 'string' },
            type: 'array',
        },
        name: {
            description: 'A single-line, human-readable name for this script (for use in user interfaces).',
            type: 'string',
        },
        passes: {
            description: 'A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in bytecode that passes program verification.\n\nThese scenarios can be used to test this script in development and review.',
            items: { type: 'string' },
            type: 'array',
        },
        script: {
            description: 'The script definition in CashAssembly.',
            type: 'string',
        },
        timeLockType: {
            description: "The expected type of time locks in this script.\n\nBecause `OP_CHECKLOCKTIMEVERIFY` reads from a transaction's `locktime` property, every input to a given transaction must share the same time lock type. This differs from `OP_CHECKSEQUENCEVERIFY` in that each input has its own `sequenceNumber`, so compatibility is not required.\n\nIf a transaction includes multiple inputs using scripts with `timeLockType` defined, and the types are not compatible, generation should fail.\n\nThe `timestamp` type indicates that the transaction's locktime is provided as a UNIX timestamp (the `locktime` value is greater than or equal to `500000000`).\n\nThe `height` type indicates that the transaction's locktime is provided as a block height (the `locktime` value is less than `500000000`).\n\nIf `timeLockType` is undefined, the script is assumed to have no reliance on absolute time locks.",
            enum: ['height', 'timestamp'],
            type: 'string',
        },
        unlocks: {
            description: 'The identifier of the script that can be unlocked by this script.\n\nThe presence of the `unlocks` property indicates that this script is an unlocking script, and the script it unlocks must be a locking script.',
            type: 'string',
        },
    }};
const schema42 = {
    enum: [
        'BCH_2020_05',
        'BCH_2021_05',
        'BCH_2022_05',
        'BCH_2023_05',
        'BCH_SPEC',
        'BSV_2020_02',
        'BSV_SPEC',
        'BTC_2017_08',
        'BTC_SPEC',
        'XEC_2020_05',
        'XEC_SPEC',
    ]};
function validate23$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    const _errs1 = errors;
    const _errs2 = errors;
    if (errors === _errs2) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.type === undefined && (missing0 = 'type')) {
                const err0 = {
                    instancePath,
                    schemaPath: '#/definitions/WalletTemplateAddressData/required',
                    keyword: 'required',
                    params: { missingProperty: missing0 },
                    message: "must have required property '" + missing0 + "'",
                };
                if (vErrors === null) {
                    vErrors = [err0];
                }
                else {
                    vErrors.push(err0);
                }
                errors++;
            }
            else {
                const _errs4 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'description' || key0 === 'name' || key0 === 'type')) {
                        const err1 = {
                            instancePath,
                            schemaPath: '#/definitions/WalletTemplateAddressData/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        };
                        if (vErrors === null) {
                            vErrors = [err1];
                        }
                        else {
                            vErrors.push(err1);
                        }
                        errors++;
                        break;
                    }
                }
                if (_errs4 === errors) {
                    if (data.description !== undefined) {
                        const _errs5 = errors;
                        if (typeof data.description !== 'string') {
                            const err2 = {
                                instancePath: instancePath + '/description',
                                schemaPath: '#/definitions/WalletTemplateAddressData/properties/description/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                            };
                            if (vErrors === null) {
                                vErrors = [err2];
                            }
                            else {
                                vErrors.push(err2);
                            }
                            errors++;
                        }
                        var valid2 = _errs5 === errors;
                    }
                    else {
                        var valid2 = true;
                    }
                    if (valid2) {
                        if (data.name !== undefined) {
                            const _errs7 = errors;
                            if (typeof data.name !== 'string') {
                                const err3 = {
                                    instancePath: instancePath + '/name',
                                    schemaPath: '#/definitions/WalletTemplateAddressData/properties/name/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                };
                                if (vErrors === null) {
                                    vErrors = [err3];
                                }
                                else {
                                    vErrors.push(err3);
                                }
                                errors++;
                            }
                            var valid2 = _errs7 === errors;
                        }
                        else {
                            var valid2 = true;
                        }
                        if (valid2) {
                            if (data.type !== undefined) {
                                let data2 = data.type;
                                const _errs9 = errors;
                                if (typeof data2 !== 'string') {
                                    const err4 = {
                                        instancePath: instancePath + '/type',
                                        schemaPath: '#/definitions/WalletTemplateAddressData/properties/type/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err4];
                                    }
                                    else {
                                        vErrors.push(err4);
                                    }
                                    errors++;
                                }
                                if ('AddressData' !== data2) {
                                    const err5 = {
                                        instancePath: instancePath + '/type',
                                        schemaPath: '#/definitions/WalletTemplateAddressData/properties/type/const',
                                        keyword: 'const',
                                        params: { allowedValue: 'AddressData' },
                                        message: 'must be equal to constant',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err5];
                                    }
                                    else {
                                        vErrors.push(err5);
                                    }
                                    errors++;
                                }
                                var valid2 = _errs9 === errors;
                            }
                            else {
                                var valid2 = true;
                            }
                        }
                    }
                }
            }
        }
        else {
            const err6 = {
                instancePath,
                schemaPath: '#/definitions/WalletTemplateAddressData/type',
                keyword: 'type',
                params: { type: 'object' },
                message: 'must be object',
            };
            if (vErrors === null) {
                vErrors = [err6];
            }
            else {
                vErrors.push(err6);
            }
            errors++;
        }
    }
    var _valid0 = _errs1 === errors;
    valid0 = valid0 || _valid0;
    if (!valid0) {
        const _errs11 = errors;
        const _errs12 = errors;
        if (errors === _errs12) {
            if (data && typeof data == 'object' && !Array.isArray(data)) {
                let missing1;
                if (data.type === undefined && (missing1 = 'type')) {
                    const err7 = {
                        instancePath,
                        schemaPath: '#/definitions/WalletTemplateHdKey/required',
                        keyword: 'required',
                        params: { missingProperty: missing1 },
                        message: "must have required property '" + missing1 + "'",
                    };
                    if (vErrors === null) {
                        vErrors = [err7];
                    }
                    else {
                        vErrors.push(err7);
                    }
                    errors++;
                }
                else {
                    const _errs14 = errors;
                    for (const key1 in data) {
                        if (!(key1 === 'addressOffset' ||
                            key1 === 'description' ||
                            key1 === 'hdPublicKeyDerivationPath' ||
                            key1 === 'name' ||
                            key1 === 'neverSignTwice' ||
                            key1 === 'privateDerivationPath' ||
                            key1 === 'publicDerivationPath' ||
                            key1 === 'type')) {
                            const err8 = {
                                instancePath,
                                schemaPath: '#/definitions/WalletTemplateHdKey/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key1 },
                                message: 'must NOT have additional properties',
                            };
                            if (vErrors === null) {
                                vErrors = [err8];
                            }
                            else {
                                vErrors.push(err8);
                            }
                            errors++;
                            break;
                        }
                    }
                    if (_errs14 === errors) {
                        if (data.addressOffset !== undefined) {
                            let data3 = data.addressOffset;
                            const _errs15 = errors;
                            if (!(typeof data3 == 'number' && isFinite(data3))) {
                                const err9 = {
                                    instancePath: instancePath + '/addressOffset',
                                    schemaPath: '#/definitions/WalletTemplateHdKey/properties/addressOffset/type',
                                    keyword: 'type',
                                    params: { type: 'number' },
                                    message: 'must be number',
                                };
                                if (vErrors === null) {
                                    vErrors = [err9];
                                }
                                else {
                                    vErrors.push(err9);
                                }
                                errors++;
                            }
                            var valid4 = _errs15 === errors;
                        }
                        else {
                            var valid4 = true;
                        }
                        if (valid4) {
                            if (data.description !== undefined) {
                                const _errs17 = errors;
                                if (typeof data.description !== 'string') {
                                    const err10 = {
                                        instancePath: instancePath + '/description',
                                        schemaPath: '#/definitions/WalletTemplateHdKey/properties/description/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err10];
                                    }
                                    else {
                                        vErrors.push(err10);
                                    }
                                    errors++;
                                }
                                var valid4 = _errs17 === errors;
                            }
                            else {
                                var valid4 = true;
                            }
                            if (valid4) {
                                if (data.hdPublicKeyDerivationPath !== undefined) {
                                    const _errs19 = errors;
                                    if (typeof data.hdPublicKeyDerivationPath !== 'string') {
                                        const err11 = {
                                            instancePath: instancePath + '/hdPublicKeyDerivationPath',
                                            schemaPath: '#/definitions/WalletTemplateHdKey/properties/hdPublicKeyDerivationPath/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        };
                                        if (vErrors === null) {
                                            vErrors = [err11];
                                        }
                                        else {
                                            vErrors.push(err11);
                                        }
                                        errors++;
                                    }
                                    var valid4 = _errs19 === errors;
                                }
                                else {
                                    var valid4 = true;
                                }
                                if (valid4) {
                                    if (data.name !== undefined) {
                                        const _errs21 = errors;
                                        if (typeof data.name !== 'string') {
                                            const err12 = {
                                                instancePath: instancePath + '/name',
                                                schemaPath: '#/definitions/WalletTemplateHdKey/properties/name/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err12];
                                            }
                                            else {
                                                vErrors.push(err12);
                                            }
                                            errors++;
                                        }
                                        var valid4 = _errs21 === errors;
                                    }
                                    else {
                                        var valid4 = true;
                                    }
                                    if (valid4) {
                                        if (data.neverSignTwice !== undefined) {
                                            const _errs23 = errors;
                                            if (typeof data.neverSignTwice !== 'boolean') {
                                                const err13 = {
                                                    instancePath: instancePath + '/neverSignTwice',
                                                    schemaPath: '#/definitions/WalletTemplateHdKey/properties/neverSignTwice/type',
                                                    keyword: 'type',
                                                    params: { type: 'boolean' },
                                                    message: 'must be boolean',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err13];
                                                }
                                                else {
                                                    vErrors.push(err13);
                                                }
                                                errors++;
                                            }
                                            var valid4 = _errs23 === errors;
                                        }
                                        else {
                                            var valid4 = true;
                                        }
                                        if (valid4) {
                                            if (data.privateDerivationPath !== undefined) {
                                                const _errs25 = errors;
                                                if (typeof data.privateDerivationPath !== 'string') {
                                                    const err14 = {
                                                        instancePath: instancePath + '/privateDerivationPath',
                                                        schemaPath: '#/definitions/WalletTemplateHdKey/properties/privateDerivationPath/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err14];
                                                    }
                                                    else {
                                                        vErrors.push(err14);
                                                    }
                                                    errors++;
                                                }
                                                var valid4 = _errs25 === errors;
                                            }
                                            else {
                                                var valid4 = true;
                                            }
                                            if (valid4) {
                                                if (data.publicDerivationPath !== undefined) {
                                                    const _errs27 = errors;
                                                    if (typeof data.publicDerivationPath !== 'string') {
                                                        const err15 = {
                                                            instancePath: instancePath + '/publicDerivationPath',
                                                            schemaPath: '#/definitions/WalletTemplateHdKey/properties/publicDerivationPath/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err15];
                                                        }
                                                        else {
                                                            vErrors.push(err15);
                                                        }
                                                        errors++;
                                                    }
                                                    var valid4 = _errs27 === errors;
                                                }
                                                else {
                                                    var valid4 = true;
                                                }
                                                if (valid4) {
                                                    if (data.type !== undefined) {
                                                        let data10 = data.type;
                                                        const _errs29 = errors;
                                                        if (typeof data10 !== 'string') {
                                                            const err16 = {
                                                                instancePath: instancePath + '/type',
                                                                schemaPath: '#/definitions/WalletTemplateHdKey/properties/type/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err16];
                                                            }
                                                            else {
                                                                vErrors.push(err16);
                                                            }
                                                            errors++;
                                                        }
                                                        if ('HdKey' !== data10) {
                                                            const err17 = {
                                                                instancePath: instancePath + '/type',
                                                                schemaPath: '#/definitions/WalletTemplateHdKey/properties/type/const',
                                                                keyword: 'const',
                                                                params: { allowedValue: 'HdKey' },
                                                                message: 'must be equal to constant',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err17];
                                                            }
                                                            else {
                                                                vErrors.push(err17);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid4 = _errs29 === errors;
                                                    }
                                                    else {
                                                        var valid4 = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else {
                const err18 = {
                    instancePath,
                    schemaPath: '#/definitions/WalletTemplateHdKey/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                };
                if (vErrors === null) {
                    vErrors = [err18];
                }
                else {
                    vErrors.push(err18);
                }
                errors++;
            }
        }
        var _valid0 = _errs11 === errors;
        valid0 = valid0 || _valid0;
        if (!valid0) {
            const _errs31 = errors;
            const _errs32 = errors;
            if (errors === _errs32) {
                if (data && typeof data == 'object' && !Array.isArray(data)) {
                    let missing2;
                    if (data.type === undefined && (missing2 = 'type')) {
                        const err19 = {
                            instancePath,
                            schemaPath: '#/definitions/WalletTemplateKey/required',
                            keyword: 'required',
                            params: { missingProperty: missing2 },
                            message: "must have required property '" + missing2 + "'",
                        };
                        if (vErrors === null) {
                            vErrors = [err19];
                        }
                        else {
                            vErrors.push(err19);
                        }
                        errors++;
                    }
                    else {
                        const _errs34 = errors;
                        for (const key2 in data) {
                            if (!(key2 === 'description' ||
                                key2 === 'name' ||
                                key2 === 'neverSignTwice' ||
                                key2 === 'type')) {
                                const err20 = {
                                    instancePath,
                                    schemaPath: '#/definitions/WalletTemplateKey/additionalProperties',
                                    keyword: 'additionalProperties',
                                    params: { additionalProperty: key2 },
                                    message: 'must NOT have additional properties',
                                };
                                if (vErrors === null) {
                                    vErrors = [err20];
                                }
                                else {
                                    vErrors.push(err20);
                                }
                                errors++;
                                break;
                            }
                        }
                        if (_errs34 === errors) {
                            if (data.description !== undefined) {
                                const _errs35 = errors;
                                if (typeof data.description !== 'string') {
                                    const err21 = {
                                        instancePath: instancePath + '/description',
                                        schemaPath: '#/definitions/WalletTemplateKey/properties/description/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err21];
                                    }
                                    else {
                                        vErrors.push(err21);
                                    }
                                    errors++;
                                }
                                var valid6 = _errs35 === errors;
                            }
                            else {
                                var valid6 = true;
                            }
                            if (valid6) {
                                if (data.name !== undefined) {
                                    const _errs37 = errors;
                                    if (typeof data.name !== 'string') {
                                        const err22 = {
                                            instancePath: instancePath + '/name',
                                            schemaPath: '#/definitions/WalletTemplateKey/properties/name/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        };
                                        if (vErrors === null) {
                                            vErrors = [err22];
                                        }
                                        else {
                                            vErrors.push(err22);
                                        }
                                        errors++;
                                    }
                                    var valid6 = _errs37 === errors;
                                }
                                else {
                                    var valid6 = true;
                                }
                                if (valid6) {
                                    if (data.neverSignTwice !== undefined) {
                                        const _errs39 = errors;
                                        if (typeof data.neverSignTwice !== 'boolean') {
                                            const err23 = {
                                                instancePath: instancePath + '/neverSignTwice',
                                                schemaPath: '#/definitions/WalletTemplateKey/properties/neverSignTwice/type',
                                                keyword: 'type',
                                                params: { type: 'boolean' },
                                                message: 'must be boolean',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err23];
                                            }
                                            else {
                                                vErrors.push(err23);
                                            }
                                            errors++;
                                        }
                                        var valid6 = _errs39 === errors;
                                    }
                                    else {
                                        var valid6 = true;
                                    }
                                    if (valid6) {
                                        if (data.type !== undefined) {
                                            let data14 = data.type;
                                            const _errs41 = errors;
                                            if (typeof data14 !== 'string') {
                                                const err24 = {
                                                    instancePath: instancePath + '/type',
                                                    schemaPath: '#/definitions/WalletTemplateKey/properties/type/type',
                                                    keyword: 'type',
                                                    params: { type: 'string' },
                                                    message: 'must be string',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err24];
                                                }
                                                else {
                                                    vErrors.push(err24);
                                                }
                                                errors++;
                                            }
                                            if ('Key' !== data14) {
                                                const err25 = {
                                                    instancePath: instancePath + '/type',
                                                    schemaPath: '#/definitions/WalletTemplateKey/properties/type/const',
                                                    keyword: 'const',
                                                    params: { allowedValue: 'Key' },
                                                    message: 'must be equal to constant',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err25];
                                                }
                                                else {
                                                    vErrors.push(err25);
                                                }
                                                errors++;
                                            }
                                            var valid6 = _errs41 === errors;
                                        }
                                        else {
                                            var valid6 = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    const err26 = {
                        instancePath,
                        schemaPath: '#/definitions/WalletTemplateKey/type',
                        keyword: 'type',
                        params: { type: 'object' },
                        message: 'must be object',
                    };
                    if (vErrors === null) {
                        vErrors = [err26];
                    }
                    else {
                        vErrors.push(err26);
                    }
                    errors++;
                }
            }
            var _valid0 = _errs31 === errors;
            valid0 = valid0 || _valid0;
            if (!valid0) {
                const _errs43 = errors;
                const _errs44 = errors;
                if (errors === _errs44) {
                    if (data && typeof data == 'object' && !Array.isArray(data)) {
                        let missing3;
                        if (data.type === undefined && (missing3 = 'type')) {
                            const err27 = {
                                instancePath,
                                schemaPath: '#/definitions/WalletTemplateWalletData/required',
                                keyword: 'required',
                                params: { missingProperty: missing3 },
                                message: "must have required property '" + missing3 + "'",
                            };
                            if (vErrors === null) {
                                vErrors = [err27];
                            }
                            else {
                                vErrors.push(err27);
                            }
                            errors++;
                        }
                        else {
                            const _errs46 = errors;
                            for (const key3 in data) {
                                if (!(key3 === 'description' ||
                                    key3 === 'name' ||
                                    key3 === 'type')) {
                                    const err28 = {
                                        instancePath,
                                        schemaPath: '#/definitions/WalletTemplateWalletData/additionalProperties',
                                        keyword: 'additionalProperties',
                                        params: { additionalProperty: key3 },
                                        message: 'must NOT have additional properties',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err28];
                                    }
                                    else {
                                        vErrors.push(err28);
                                    }
                                    errors++;
                                    break;
                                }
                            }
                            if (_errs46 === errors) {
                                if (data.description !== undefined) {
                                    const _errs47 = errors;
                                    if (typeof data.description !== 'string') {
                                        const err29 = {
                                            instancePath: instancePath + '/description',
                                            schemaPath: '#/definitions/WalletTemplateWalletData/properties/description/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        };
                                        if (vErrors === null) {
                                            vErrors = [err29];
                                        }
                                        else {
                                            vErrors.push(err29);
                                        }
                                        errors++;
                                    }
                                    var valid8 = _errs47 === errors;
                                }
                                else {
                                    var valid8 = true;
                                }
                                if (valid8) {
                                    if (data.name !== undefined) {
                                        const _errs49 = errors;
                                        if (typeof data.name !== 'string') {
                                            const err30 = {
                                                instancePath: instancePath + '/name',
                                                schemaPath: '#/definitions/WalletTemplateWalletData/properties/name/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err30];
                                            }
                                            else {
                                                vErrors.push(err30);
                                            }
                                            errors++;
                                        }
                                        var valid8 = _errs49 === errors;
                                    }
                                    else {
                                        var valid8 = true;
                                    }
                                    if (valid8) {
                                        if (data.type !== undefined) {
                                            let data17 = data.type;
                                            const _errs51 = errors;
                                            if (typeof data17 !== 'string') {
                                                const err31 = {
                                                    instancePath: instancePath + '/type',
                                                    schemaPath: '#/definitions/WalletTemplateWalletData/properties/type/type',
                                                    keyword: 'type',
                                                    params: { type: 'string' },
                                                    message: 'must be string',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err31];
                                                }
                                                else {
                                                    vErrors.push(err31);
                                                }
                                                errors++;
                                            }
                                            if ('WalletData' !== data17) {
                                                const err32 = {
                                                    instancePath: instancePath + '/type',
                                                    schemaPath: '#/definitions/WalletTemplateWalletData/properties/type/const',
                                                    keyword: 'const',
                                                    params: { allowedValue: 'WalletData' },
                                                    message: 'must be equal to constant',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err32];
                                                }
                                                else {
                                                    vErrors.push(err32);
                                                }
                                                errors++;
                                            }
                                            var valid8 = _errs51 === errors;
                                        }
                                        else {
                                            var valid8 = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        const err33 = {
                            instancePath,
                            schemaPath: '#/definitions/WalletTemplateWalletData/type',
                            keyword: 'type',
                            params: { type: 'object' },
                            message: 'must be object',
                        };
                        if (vErrors === null) {
                            vErrors = [err33];
                        }
                        else {
                            vErrors.push(err33);
                        }
                        errors++;
                    }
                }
                var _valid0 = _errs43 === errors;
                valid0 = valid0 || _valid0;
            }
        }
    }
    if (!valid0) {
        const err34 = {
            instancePath,
            schemaPath: '#/anyOf',
            keyword: 'anyOf',
            params: {},
            message: 'must match a schema in anyOf',
        };
        if (vErrors === null) {
            vErrors = [err34];
        }
        else {
            vErrors.push(err34);
        }
        errors++;
        validate23$1.errors = vErrors;
        return false;
    }
    else {
        errors = _errs0;
        if (vErrors !== null) {
            if (_errs0) {
                vErrors.length = _errs0;
            }
            else {
                vErrors = null;
            }
        }
    }
    validate23$1.errors = vErrors;
    return errors === 0;
}
function validate22$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            const _errs1 = errors;
            for (const key0 in data) {
                if (!(key0 === 'description' ||
                    key0 === 'name' ||
                    key0 === 'scripts' ||
                    key0 === 'variables')) {
                    validate22$1.errors = [
                        {
                            instancePath,
                            schemaPath: '#/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        },
                    ];
                    return false;
                }
            }
            if (_errs1 === errors) {
                if (data.description !== undefined) {
                    const _errs2 = errors;
                    if (typeof data.description !== 'string') {
                        validate22$1.errors = [
                            {
                                instancePath: instancePath + '/description',
                                schemaPath: '#/properties/description/type',
                                keyword: 'type',
                                params: { type: 'string' },
                                message: 'must be string',
                            },
                        ];
                        return false;
                    }
                    var valid0 = _errs2 === errors;
                }
                else {
                    var valid0 = true;
                }
                if (valid0) {
                    if (data.name !== undefined) {
                        const _errs4 = errors;
                        if (typeof data.name !== 'string') {
                            validate22$1.errors = [
                                {
                                    instancePath: instancePath + '/name',
                                    schemaPath: '#/properties/name/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs4 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.scripts !== undefined) {
                            let data2 = data.scripts;
                            const _errs6 = errors;
                            if (errors === _errs6) {
                                if (Array.isArray(data2)) {
                                    var valid1 = true;
                                    const len0 = data2.length;
                                    for (let i0 = 0; i0 < len0; i0++) {
                                        const _errs8 = errors;
                                        if (typeof data2[i0] !== 'string') {
                                            validate22$1.errors = [
                                                {
                                                    instancePath: instancePath + '/scripts/' + i0,
                                                    schemaPath: '#/properties/scripts/items/type',
                                                    keyword: 'type',
                                                    params: { type: 'string' },
                                                    message: 'must be string',
                                                },
                                            ];
                                            return false;
                                        }
                                        var valid1 = _errs8 === errors;
                                        if (!valid1) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate22$1.errors = [
                                        {
                                            instancePath: instancePath + '/scripts',
                                            schemaPath: '#/properties/scripts/type',
                                            keyword: 'type',
                                            params: { type: 'array' },
                                            message: 'must be array',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs6 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.variables !== undefined) {
                                let data4 = data.variables;
                                const _errs10 = errors;
                                if (errors === _errs10) {
                                    if (data4 &&
                                        typeof data4 == 'object' &&
                                        !Array.isArray(data4)) {
                                        for (const key1 in data4) {
                                            const _errs13 = errors;
                                            if (!validate23$1(data4[key1], {
                                                instancePath: instancePath +
                                                    '/variables/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                parentData: data4,
                                                parentDataProperty: key1,
                                                rootData,
                                            })) {
                                                vErrors =
                                                    vErrors === null
                                                        ? validate23$1.errors
                                                        : vErrors.concat(validate23$1.errors);
                                                errors = vErrors.length;
                                            }
                                            var valid2 = _errs13 === errors;
                                            if (!valid2) {
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        validate22$1.errors = [
                                            {
                                                instancePath: instancePath + '/variables',
                                                schemaPath: '#/properties/variables/type',
                                                keyword: 'type',
                                                params: { type: 'object' },
                                                message: 'must be object',
                                            },
                                        ];
                                        return false;
                                    }
                                }
                                var valid0 = _errs10 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                        }
                    }
                }
            }
        }
        else {
            validate22$1.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate22$1.errors = vErrors;
    return errors === 0;
}
const schema32 = {
    properties: {
        token: {
            properties: {
                amount: {
                    type: ['number', 'string'],
                },
                nft: {
                    properties: {
                        capability: {
                            enum: ['minting', 'mutable', 'none']}}},
            }},
        valueSatoshis: {
            type: ['number', 'string'],
        },
    }};
function validate28$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    const _errs1 = errors;
    if (typeof data !== 'string') {
        const err0 = {
            instancePath,
            schemaPath: '#/anyOf/0/type',
            keyword: 'type',
            params: { type: 'string' },
            message: 'must be string',
        };
        if (vErrors === null) {
            vErrors = [err0];
        }
        else {
            vErrors.push(err0);
        }
        errors++;
    }
    var _valid0 = _errs1 === errors;
    valid0 = valid0 || _valid0;
    if (!valid0) {
        const _errs3 = errors;
        if (errors === _errs3) {
            if (data && typeof data == 'object' && !Array.isArray(data)) {
                const _errs5 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'overrides' || key0 === 'script')) {
                        const err1 = {
                            instancePath,
                            schemaPath: '#/anyOf/1/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        };
                        if (vErrors === null) {
                            vErrors = [err1];
                        }
                        else {
                            vErrors.push(err1);
                        }
                        errors++;
                        break;
                    }
                }
                if (_errs5 === errors) {
                    if (data.overrides !== undefined) {
                        let data0 = data.overrides;
                        const _errs6 = errors;
                        const _errs7 = errors;
                        if (errors === _errs7) {
                            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
                                const _errs9 = errors;
                                for (const key1 in data0) {
                                    if (!(key1 === 'bytecode' ||
                                        key1 === 'currentBlockHeight' ||
                                        key1 === 'currentBlockTime' ||
                                        key1 === 'hdKeys' ||
                                        key1 === 'keys')) {
                                        const err2 = {
                                            instancePath: instancePath + '/overrides',
                                            schemaPath: '#/definitions/WalletTemplateScenarioData/additionalProperties',
                                            keyword: 'additionalProperties',
                                            params: { additionalProperty: key1 },
                                            message: 'must NOT have additional properties',
                                        };
                                        if (vErrors === null) {
                                            vErrors = [err2];
                                        }
                                        else {
                                            vErrors.push(err2);
                                        }
                                        errors++;
                                        break;
                                    }
                                }
                                if (_errs9 === errors) {
                                    if (data0.bytecode !== undefined) {
                                        let data1 = data0.bytecode;
                                        const _errs10 = errors;
                                        if (errors === _errs10) {
                                            if (data1 &&
                                                typeof data1 == 'object' &&
                                                !Array.isArray(data1)) {
                                                for (const key2 in data1) {
                                                    const _errs13 = errors;
                                                    if (typeof data1[key2] !== 'string') {
                                                        const err3 = {
                                                            instancePath: instancePath +
                                                                '/overrides/bytecode/' +
                                                                key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/bytecode/additionalProperties/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err3];
                                                        }
                                                        else {
                                                            vErrors.push(err3);
                                                        }
                                                        errors++;
                                                    }
                                                    var valid4 = _errs13 === errors;
                                                    if (!valid4) {
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                const err4 = {
                                                    instancePath: instancePath + '/overrides/bytecode',
                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/bytecode/type',
                                                    keyword: 'type',
                                                    params: { type: 'object' },
                                                    message: 'must be object',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err4];
                                                }
                                                else {
                                                    vErrors.push(err4);
                                                }
                                                errors++;
                                            }
                                        }
                                        var valid3 = _errs10 === errors;
                                    }
                                    else {
                                        var valid3 = true;
                                    }
                                    if (valid3) {
                                        if (data0.currentBlockHeight !== undefined) {
                                            let data3 = data0.currentBlockHeight;
                                            const _errs15 = errors;
                                            if (!(typeof data3 == 'number' && isFinite(data3))) {
                                                const err5 = {
                                                    instancePath: instancePath + '/overrides/currentBlockHeight',
                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/currentBlockHeight/type',
                                                    keyword: 'type',
                                                    params: { type: 'number' },
                                                    message: 'must be number',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err5];
                                                }
                                                else {
                                                    vErrors.push(err5);
                                                }
                                                errors++;
                                            }
                                            var valid3 = _errs15 === errors;
                                        }
                                        else {
                                            var valid3 = true;
                                        }
                                        if (valid3) {
                                            if (data0.currentBlockTime !== undefined) {
                                                let data4 = data0.currentBlockTime;
                                                const _errs17 = errors;
                                                if (!(typeof data4 == 'number' && isFinite(data4))) {
                                                    const err6 = {
                                                        instancePath: instancePath + '/overrides/currentBlockTime',
                                                        schemaPath: '#/definitions/WalletTemplateScenarioData/properties/currentBlockTime/type',
                                                        keyword: 'type',
                                                        params: { type: 'number' },
                                                        message: 'must be number',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err6];
                                                    }
                                                    else {
                                                        vErrors.push(err6);
                                                    }
                                                    errors++;
                                                }
                                                var valid3 = _errs17 === errors;
                                            }
                                            else {
                                                var valid3 = true;
                                            }
                                            if (valid3) {
                                                if (data0.hdKeys !== undefined) {
                                                    let data5 = data0.hdKeys;
                                                    const _errs19 = errors;
                                                    if (errors === _errs19) {
                                                        if (data5 &&
                                                            typeof data5 == 'object' &&
                                                            !Array.isArray(data5)) {
                                                            const _errs21 = errors;
                                                            for (const key3 in data5) {
                                                                if (!(key3 === 'addressIndex' ||
                                                                    key3 === 'hdPrivateKeys' ||
                                                                    key3 === 'hdPublicKeys')) {
                                                                    const err7 = {
                                                                        instancePath: instancePath + '/overrides/hdKeys',
                                                                        schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/additionalProperties',
                                                                        keyword: 'additionalProperties',
                                                                        params: { additionalProperty: key3 },
                                                                        message: 'must NOT have additional properties',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err7];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err7);
                                                                    }
                                                                    errors++;
                                                                    break;
                                                                }
                                                            }
                                                            if (_errs21 === errors) {
                                                                if (data5.addressIndex !== undefined) {
                                                                    let data6 = data5.addressIndex;
                                                                    const _errs22 = errors;
                                                                    if (!(typeof data6 == 'number' &&
                                                                        isFinite(data6))) {
                                                                        const err8 = {
                                                                            instancePath: instancePath +
                                                                                '/overrides/hdKeys/addressIndex',
                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/addressIndex/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'number' },
                                                                            message: 'must be number',
                                                                        };
                                                                        if (vErrors === null) {
                                                                            vErrors = [err8];
                                                                        }
                                                                        else {
                                                                            vErrors.push(err8);
                                                                        }
                                                                        errors++;
                                                                    }
                                                                    var valid5 = _errs22 === errors;
                                                                }
                                                                else {
                                                                    var valid5 = true;
                                                                }
                                                                if (valid5) {
                                                                    if (data5.hdPrivateKeys !== undefined) {
                                                                        let data7 = data5.hdPrivateKeys;
                                                                        const _errs24 = errors;
                                                                        if (errors === _errs24) {
                                                                            if (data7 &&
                                                                                typeof data7 == 'object' &&
                                                                                !Array.isArray(data7)) {
                                                                                for (const key4 in data7) {
                                                                                    const _errs27 = errors;
                                                                                    if (typeof data7[key4] !== 'string') {
                                                                                        const err9 = {
                                                                                            instancePath: instancePath +
                                                                                                '/overrides/hdKeys/hdPrivateKeys/' +
                                                                                                key4
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1'),
                                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/additionalProperties/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'string' },
                                                                                            message: 'must be string',
                                                                                        };
                                                                                        if (vErrors === null) {
                                                                                            vErrors = [err9];
                                                                                        }
                                                                                        else {
                                                                                            vErrors.push(err9);
                                                                                        }
                                                                                        errors++;
                                                                                    }
                                                                                    var valid6 = _errs27 === errors;
                                                                                    if (!valid6) {
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            else {
                                                                                const err10 = {
                                                                                    instancePath: instancePath +
                                                                                        '/overrides/hdKeys/hdPrivateKeys',
                                                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'object' },
                                                                                    message: 'must be object',
                                                                                };
                                                                                if (vErrors === null) {
                                                                                    vErrors = [err10];
                                                                                }
                                                                                else {
                                                                                    vErrors.push(err10);
                                                                                }
                                                                                errors++;
                                                                            }
                                                                        }
                                                                        var valid5 = _errs24 === errors;
                                                                    }
                                                                    else {
                                                                        var valid5 = true;
                                                                    }
                                                                    if (valid5) {
                                                                        if (data5.hdPublicKeys !== undefined) {
                                                                            let data9 = data5.hdPublicKeys;
                                                                            const _errs29 = errors;
                                                                            if (errors === _errs29) {
                                                                                if (data9 &&
                                                                                    typeof data9 == 'object' &&
                                                                                    !Array.isArray(data9)) {
                                                                                    for (const key5 in data9) {
                                                                                        const _errs32 = errors;
                                                                                        if (typeof data9[key5] !== 'string') {
                                                                                            const err11 = {
                                                                                                instancePath: instancePath +
                                                                                                    '/overrides/hdKeys/hdPublicKeys/' +
                                                                                                    key5
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1'),
                                                                                                schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/additionalProperties/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'string' },
                                                                                                message: 'must be string',
                                                                                            };
                                                                                            if (vErrors === null) {
                                                                                                vErrors = [err11];
                                                                                            }
                                                                                            else {
                                                                                                vErrors.push(err11);
                                                                                            }
                                                                                            errors++;
                                                                                        }
                                                                                        var valid7 = _errs32 === errors;
                                                                                        if (!valid7) {
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                else {
                                                                                    const err12 = {
                                                                                        instancePath: instancePath +
                                                                                            '/overrides/hdKeys/hdPublicKeys',
                                                                                        schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'object' },
                                                                                        message: 'must be object',
                                                                                    };
                                                                                    if (vErrors === null) {
                                                                                        vErrors = [err12];
                                                                                    }
                                                                                    else {
                                                                                        vErrors.push(err12);
                                                                                    }
                                                                                    errors++;
                                                                                }
                                                                            }
                                                                            var valid5 = _errs29 === errors;
                                                                        }
                                                                        else {
                                                                            var valid5 = true;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else {
                                                            const err13 = {
                                                                instancePath: instancePath + '/overrides/hdKeys',
                                                                schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err13];
                                                            }
                                                            else {
                                                                vErrors.push(err13);
                                                            }
                                                            errors++;
                                                        }
                                                    }
                                                    var valid3 = _errs19 === errors;
                                                }
                                                else {
                                                    var valid3 = true;
                                                }
                                                if (valid3) {
                                                    if (data0.keys !== undefined) {
                                                        let data11 = data0.keys;
                                                        const _errs34 = errors;
                                                        if (errors === _errs34) {
                                                            if (data11 &&
                                                                typeof data11 == 'object' &&
                                                                !Array.isArray(data11)) {
                                                                const _errs36 = errors;
                                                                for (const key6 in data11) {
                                                                    if (!(key6 === 'privateKeys')) {
                                                                        const err14 = {
                                                                            instancePath: instancePath + '/overrides/keys',
                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/additionalProperties',
                                                                            keyword: 'additionalProperties',
                                                                            params: { additionalProperty: key6 },
                                                                            message: 'must NOT have additional properties',
                                                                        };
                                                                        if (vErrors === null) {
                                                                            vErrors = [err14];
                                                                        }
                                                                        else {
                                                                            vErrors.push(err14);
                                                                        }
                                                                        errors++;
                                                                        break;
                                                                    }
                                                                }
                                                                if (_errs36 === errors) {
                                                                    if (data11.privateKeys !== undefined) {
                                                                        let data12 = data11.privateKeys;
                                                                        const _errs37 = errors;
                                                                        if (errors === _errs37) {
                                                                            if (data12 &&
                                                                                typeof data12 == 'object' &&
                                                                                !Array.isArray(data12)) {
                                                                                for (const key7 in data12) {
                                                                                    const _errs40 = errors;
                                                                                    if (typeof data12[key7] !== 'string') {
                                                                                        const err15 = {
                                                                                            instancePath: instancePath +
                                                                                                '/overrides/keys/privateKeys/' +
                                                                                                key7
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1'),
                                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/properties/privateKeys/additionalProperties/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'string' },
                                                                                            message: 'must be string',
                                                                                        };
                                                                                        if (vErrors === null) {
                                                                                            vErrors = [err15];
                                                                                        }
                                                                                        else {
                                                                                            vErrors.push(err15);
                                                                                        }
                                                                                        errors++;
                                                                                    }
                                                                                    var valid9 = _errs40 === errors;
                                                                                    if (!valid9) {
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            else {
                                                                                const err16 = {
                                                                                    instancePath: instancePath +
                                                                                        '/overrides/keys/privateKeys',
                                                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/properties/privateKeys/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'object' },
                                                                                    message: 'must be object',
                                                                                };
                                                                                if (vErrors === null) {
                                                                                    vErrors = [err16];
                                                                                }
                                                                                else {
                                                                                    vErrors.push(err16);
                                                                                }
                                                                                errors++;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                const err17 = {
                                                                    instancePath: instancePath + '/overrides/keys',
                                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'object' },
                                                                    message: 'must be object',
                                                                };
                                                                if (vErrors === null) {
                                                                    vErrors = [err17];
                                                                }
                                                                else {
                                                                    vErrors.push(err17);
                                                                }
                                                                errors++;
                                                            }
                                                        }
                                                        var valid3 = _errs34 === errors;
                                                    }
                                                    else {
                                                        var valid3 = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                const err18 = {
                                    instancePath: instancePath + '/overrides',
                                    schemaPath: '#/definitions/WalletTemplateScenarioData/type',
                                    keyword: 'type',
                                    params: { type: 'object' },
                                    message: 'must be object',
                                };
                                if (vErrors === null) {
                                    vErrors = [err18];
                                }
                                else {
                                    vErrors.push(err18);
                                }
                                errors++;
                            }
                        }
                        var valid1 = _errs6 === errors;
                    }
                    else {
                        var valid1 = true;
                    }
                    if (valid1) {
                        if (data.script !== undefined) {
                            let data14 = data.script;
                            const _errs42 = errors;
                            const _errs43 = errors;
                            let valid10 = false;
                            const _errs44 = errors;
                            if (typeof data14 !== 'string') {
                                const err19 = {
                                    instancePath: instancePath + '/script',
                                    schemaPath: '#/anyOf/1/properties/script/anyOf/0/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                };
                                if (vErrors === null) {
                                    vErrors = [err19];
                                }
                                else {
                                    vErrors.push(err19);
                                }
                                errors++;
                            }
                            var _valid1 = _errs44 === errors;
                            valid10 = valid10 || _valid1;
                            if (!valid10) {
                                const _errs46 = errors;
                                if (errors === _errs46) {
                                    if (Array.isArray(data14)) {
                                        if (data14.length > 1) {
                                            const err20 = {
                                                instancePath: instancePath + '/script',
                                                schemaPath: '#/anyOf/1/properties/script/anyOf/1/maxItems',
                                                keyword: 'maxItems',
                                                params: { limit: 1 },
                                                message: 'must NOT have more than 1 items',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err20];
                                            }
                                            else {
                                                vErrors.push(err20);
                                            }
                                            errors++;
                                        }
                                        else {
                                            if (data14.length < 1) {
                                                const err21 = {
                                                    instancePath: instancePath + '/script',
                                                    schemaPath: '#/anyOf/1/properties/script/anyOf/1/minItems',
                                                    keyword: 'minItems',
                                                    params: { limit: 1 },
                                                    message: 'must NOT have fewer than 1 items',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err21];
                                                }
                                                else {
                                                    vErrors.push(err21);
                                                }
                                                errors++;
                                            }
                                            else {
                                                var valid11 = true;
                                                const len0 = data14.length;
                                                for (let i0 = 0; i0 < len0; i0++) {
                                                    let data15 = data14[i0];
                                                    const _errs48 = errors;
                                                    if (typeof data15 !== 'string') {
                                                        const err22 = {
                                                            instancePath: instancePath + '/script/' + i0,
                                                            schemaPath: '#/anyOf/1/properties/script/anyOf/1/items/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err22];
                                                        }
                                                        else {
                                                            vErrors.push(err22);
                                                        }
                                                        errors++;
                                                    }
                                                    if ('copy' !== data15) {
                                                        const err23 = {
                                                            instancePath: instancePath + '/script/' + i0,
                                                            schemaPath: '#/anyOf/1/properties/script/anyOf/1/items/const',
                                                            keyword: 'const',
                                                            params: { allowedValue: 'copy' },
                                                            message: 'must be equal to constant',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err23];
                                                        }
                                                        else {
                                                            vErrors.push(err23);
                                                        }
                                                        errors++;
                                                    }
                                                    var valid11 = _errs48 === errors;
                                                    if (!valid11) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        const err24 = {
                                            instancePath: instancePath + '/script',
                                            schemaPath: '#/anyOf/1/properties/script/anyOf/1/type',
                                            keyword: 'type',
                                            params: { type: 'array' },
                                            message: 'must be array',
                                        };
                                        if (vErrors === null) {
                                            vErrors = [err24];
                                        }
                                        else {
                                            vErrors.push(err24);
                                        }
                                        errors++;
                                    }
                                }
                                var _valid1 = _errs46 === errors;
                                valid10 = valid10 || _valid1;
                            }
                            if (!valid10) {
                                const err25 = {
                                    instancePath: instancePath + '/script',
                                    schemaPath: '#/anyOf/1/properties/script/anyOf',
                                    keyword: 'anyOf',
                                    params: {},
                                    message: 'must match a schema in anyOf',
                                };
                                if (vErrors === null) {
                                    vErrors = [err25];
                                }
                                else {
                                    vErrors.push(err25);
                                }
                                errors++;
                            }
                            else {
                                errors = _errs43;
                                if (vErrors !== null) {
                                    if (_errs43) {
                                        vErrors.length = _errs43;
                                    }
                                    else {
                                        vErrors = null;
                                    }
                                }
                            }
                            var valid1 = _errs42 === errors;
                        }
                        else {
                            var valid1 = true;
                        }
                    }
                }
            }
            else {
                const err26 = {
                    instancePath,
                    schemaPath: '#/anyOf/1/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                };
                if (vErrors === null) {
                    vErrors = [err26];
                }
                else {
                    vErrors.push(err26);
                }
                errors++;
            }
        }
        var _valid0 = _errs3 === errors;
        valid0 = valid0 || _valid0;
    }
    if (!valid0) {
        const err27 = {
            instancePath,
            schemaPath: '#/anyOf',
            keyword: 'anyOf',
            params: {},
            message: 'must match a schema in anyOf',
        };
        if (vErrors === null) {
            vErrors = [err27];
        }
        else {
            vErrors.push(err27);
        }
        errors++;
        validate28$1.errors = vErrors;
        return false;
    }
    else {
        errors = _errs0;
        if (vErrors !== null) {
            if (_errs0) {
                vErrors.length = _errs0;
            }
            else {
                vErrors = null;
            }
        }
    }
    validate28$1.errors = vErrors;
    return errors === 0;
}
function validate27$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            const _errs1 = errors;
            for (const key0 in data) {
                if (!(key0 === 'lockingBytecode' ||
                    key0 === 'token' ||
                    key0 === 'valueSatoshis')) {
                    validate27$1.errors = [
                        {
                            instancePath,
                            schemaPath: '#/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        },
                    ];
                    return false;
                }
            }
            if (_errs1 === errors) {
                if (data.lockingBytecode !== undefined) {
                    let data0 = data.lockingBytecode;
                    const _errs2 = errors;
                    const _errs3 = errors;
                    let valid1 = false;
                    const _errs4 = errors;
                    if (!validate28$1(data0, {
                        instancePath: instancePath + '/lockingBytecode',
                        parentData: data,
                        parentDataProperty: 'lockingBytecode',
                        rootData,
                    })) {
                        vErrors =
                            vErrors === null
                                ? validate28$1.errors
                                : vErrors.concat(validate28$1.errors);
                        errors = vErrors.length;
                    }
                    var _valid0 = _errs4 === errors;
                    valid1 = valid1 || _valid0;
                    if (!valid1) {
                        const _errs5 = errors;
                        if (errors === _errs5) {
                            if (Array.isArray(data0)) {
                                if (data0.length > 1) {
                                    const err0 = {
                                        instancePath: instancePath + '/lockingBytecode',
                                        schemaPath: '#/properties/lockingBytecode/anyOf/1/maxItems',
                                        keyword: 'maxItems',
                                        params: { limit: 1 },
                                        message: 'must NOT have more than 1 items',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err0];
                                    }
                                    else {
                                        vErrors.push(err0);
                                    }
                                    errors++;
                                }
                                else {
                                    if (data0.length < 1) {
                                        const err1 = {
                                            instancePath: instancePath + '/lockingBytecode',
                                            schemaPath: '#/properties/lockingBytecode/anyOf/1/minItems',
                                            keyword: 'minItems',
                                            params: { limit: 1 },
                                            message: 'must NOT have fewer than 1 items',
                                        };
                                        if (vErrors === null) {
                                            vErrors = [err1];
                                        }
                                        else {
                                            vErrors.push(err1);
                                        }
                                        errors++;
                                    }
                                    else {
                                        var valid2 = true;
                                        const len0 = data0.length;
                                        for (let i0 = 0; i0 < len0; i0++) {
                                            let data1 = data0[i0];
                                            const _errs7 = errors;
                                            if (typeof data1 !== 'string') {
                                                const err2 = {
                                                    instancePath: instancePath + '/lockingBytecode/' + i0,
                                                    schemaPath: '#/properties/lockingBytecode/anyOf/1/items/type',
                                                    keyword: 'type',
                                                    params: { type: 'string' },
                                                    message: 'must be string',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err2];
                                                }
                                                else {
                                                    vErrors.push(err2);
                                                }
                                                errors++;
                                            }
                                            if ('slot' !== data1) {
                                                const err3 = {
                                                    instancePath: instancePath + '/lockingBytecode/' + i0,
                                                    schemaPath: '#/properties/lockingBytecode/anyOf/1/items/const',
                                                    keyword: 'const',
                                                    params: { allowedValue: 'slot' },
                                                    message: 'must be equal to constant',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err3];
                                                }
                                                else {
                                                    vErrors.push(err3);
                                                }
                                                errors++;
                                            }
                                            var valid2 = _errs7 === errors;
                                            if (!valid2) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                const err4 = {
                                    instancePath: instancePath + '/lockingBytecode',
                                    schemaPath: '#/properties/lockingBytecode/anyOf/1/type',
                                    keyword: 'type',
                                    params: { type: 'array' },
                                    message: 'must be array',
                                };
                                if (vErrors === null) {
                                    vErrors = [err4];
                                }
                                else {
                                    vErrors.push(err4);
                                }
                                errors++;
                            }
                        }
                        var _valid0 = _errs5 === errors;
                        valid1 = valid1 || _valid0;
                    }
                    if (!valid1) {
                        const err5 = {
                            instancePath: instancePath + '/lockingBytecode',
                            schemaPath: '#/properties/lockingBytecode/anyOf',
                            keyword: 'anyOf',
                            params: {},
                            message: 'must match a schema in anyOf',
                        };
                        if (vErrors === null) {
                            vErrors = [err5];
                        }
                        else {
                            vErrors.push(err5);
                        }
                        errors++;
                        validate27$1.errors = vErrors;
                        return false;
                    }
                    else {
                        errors = _errs3;
                        if (vErrors !== null) {
                            if (_errs3) {
                                vErrors.length = _errs3;
                            }
                            else {
                                vErrors = null;
                            }
                        }
                    }
                    var valid0 = _errs2 === errors;
                }
                else {
                    var valid0 = true;
                }
                if (valid0) {
                    if (data.token !== undefined) {
                        let data2 = data.token;
                        const _errs9 = errors;
                        if (errors === _errs9) {
                            if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
                                const _errs11 = errors;
                                for (const key1 in data2) {
                                    if (!(key1 === 'amount' ||
                                        key1 === 'category' ||
                                        key1 === 'nft')) {
                                        validate27$1.errors = [
                                            {
                                                instancePath: instancePath + '/token',
                                                schemaPath: '#/properties/token/additionalProperties',
                                                keyword: 'additionalProperties',
                                                params: { additionalProperty: key1 },
                                                message: 'must NOT have additional properties',
                                            },
                                        ];
                                        return false;
                                    }
                                }
                                if (_errs11 === errors) {
                                    if (data2.amount !== undefined) {
                                        let data3 = data2.amount;
                                        const _errs12 = errors;
                                        if (!(typeof data3 == 'number' && isFinite(data3)) &&
                                            typeof data3 !== 'string') {
                                            validate27$1.errors = [
                                                {
                                                    instancePath: instancePath + '/token/amount',
                                                    schemaPath: '#/properties/token/properties/amount/type',
                                                    keyword: 'type',
                                                    params: {
                                                        type: schema32.properties.token.properties.amount
                                                            .type,
                                                    },
                                                    message: 'must be number,string',
                                                },
                                            ];
                                            return false;
                                        }
                                        var valid3 = _errs12 === errors;
                                    }
                                    else {
                                        var valid3 = true;
                                    }
                                    if (valid3) {
                                        if (data2.category !== undefined) {
                                            const _errs14 = errors;
                                            if (typeof data2.category !== 'string') {
                                                validate27$1.errors = [
                                                    {
                                                        instancePath: instancePath + '/token/category',
                                                        schemaPath: '#/properties/token/properties/category/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    },
                                                ];
                                                return false;
                                            }
                                            var valid3 = _errs14 === errors;
                                        }
                                        else {
                                            var valid3 = true;
                                        }
                                        if (valid3) {
                                            if (data2.nft !== undefined) {
                                                let data5 = data2.nft;
                                                const _errs16 = errors;
                                                if (errors === _errs16) {
                                                    if (data5 &&
                                                        typeof data5 == 'object' &&
                                                        !Array.isArray(data5)) {
                                                        const _errs18 = errors;
                                                        for (const key2 in data5) {
                                                            if (!(key2 === 'capability' || key2 === 'commitment')) {
                                                                validate27$1.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/token/nft',
                                                                        schemaPath: '#/properties/token/properties/nft/additionalProperties',
                                                                        keyword: 'additionalProperties',
                                                                        params: { additionalProperty: key2 },
                                                                        message: 'must NOT have additional properties',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                        }
                                                        if (_errs18 === errors) {
                                                            if (data5.capability !== undefined) {
                                                                let data6 = data5.capability;
                                                                const _errs19 = errors;
                                                                if (typeof data6 !== 'string') {
                                                                    validate27$1.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/token/nft/capability',
                                                                            schemaPath: '#/properties/token/properties/nft/properties/capability/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'string' },
                                                                            message: 'must be string',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                if (!(data6 === 'minting' ||
                                                                    data6 === 'mutable' ||
                                                                    data6 === 'none')) {
                                                                    validate27$1.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/token/nft/capability',
                                                                            schemaPath: '#/properties/token/properties/nft/properties/capability/enum',
                                                                            keyword: 'enum',
                                                                            params: {
                                                                                allowedValues: schema32.properties.token.properties
                                                                                    .nft.properties.capability.enum,
                                                                            },
                                                                            message: 'must be equal to one of the allowed values',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                var valid4 = _errs19 === errors;
                                                            }
                                                            else {
                                                                var valid4 = true;
                                                            }
                                                            if (valid4) {
                                                                if (data5.commitment !== undefined) {
                                                                    const _errs21 = errors;
                                                                    if (typeof data5.commitment !== 'string') {
                                                                        validate27$1.errors = [
                                                                            {
                                                                                instancePath: instancePath +
                                                                                    '/token/nft/commitment',
                                                                                schemaPath: '#/properties/token/properties/nft/properties/commitment/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    var valid4 = _errs21 === errors;
                                                                }
                                                                else {
                                                                    var valid4 = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate27$1.errors = [
                                                            {
                                                                instancePath: instancePath + '/token/nft',
                                                                schemaPath: '#/properties/token/properties/nft/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid3 = _errs16 === errors;
                                            }
                                            else {
                                                var valid3 = true;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                validate27$1.errors = [
                                    {
                                        instancePath: instancePath + '/token',
                                        schemaPath: '#/properties/token/type',
                                        keyword: 'type',
                                        params: { type: 'object' },
                                        message: 'must be object',
                                    },
                                ];
                                return false;
                            }
                        }
                        var valid0 = _errs9 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.valueSatoshis !== undefined) {
                            let data8 = data.valueSatoshis;
                            const _errs23 = errors;
                            if (!(typeof data8 == 'number' && isFinite(data8)) &&
                                typeof data8 !== 'string') {
                                validate27$1.errors = [
                                    {
                                        instancePath: instancePath + '/valueSatoshis',
                                        schemaPath: '#/properties/valueSatoshis/type',
                                        keyword: 'type',
                                        params: { type: schema32.properties.valueSatoshis.type },
                                        message: 'must be number,string',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs23 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                    }
                }
            }
        }
        else {
            validate27$1.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate27$1.errors = vErrors;
    return errors === 0;
}
function validate31(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            const _errs1 = errors;
            for (const key0 in data) {
                if (!(key0 === 'outpointIndex' ||
                    key0 === 'outpointTransactionHash' ||
                    key0 === 'sequenceNumber' ||
                    key0 === 'unlockingBytecode')) {
                    validate31.errors = [
                        {
                            instancePath,
                            schemaPath: '#/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        },
                    ];
                    return false;
                }
            }
            if (_errs1 === errors) {
                if (data.outpointIndex !== undefined) {
                    let data0 = data.outpointIndex;
                    const _errs2 = errors;
                    if (!(typeof data0 == 'number' && isFinite(data0))) {
                        validate31.errors = [
                            {
                                instancePath: instancePath + '/outpointIndex',
                                schemaPath: '#/properties/outpointIndex/type',
                                keyword: 'type',
                                params: { type: 'number' },
                                message: 'must be number',
                            },
                        ];
                        return false;
                    }
                    var valid0 = _errs2 === errors;
                }
                else {
                    var valid0 = true;
                }
                if (valid0) {
                    if (data.outpointTransactionHash !== undefined) {
                        const _errs4 = errors;
                        if (typeof data.outpointTransactionHash !== 'string') {
                            validate31.errors = [
                                {
                                    instancePath: instancePath + '/outpointTransactionHash',
                                    schemaPath: '#/properties/outpointTransactionHash/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs4 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.sequenceNumber !== undefined) {
                            let data2 = data.sequenceNumber;
                            const _errs6 = errors;
                            if (!(typeof data2 == 'number' && isFinite(data2))) {
                                validate31.errors = [
                                    {
                                        instancePath: instancePath + '/sequenceNumber',
                                        schemaPath: '#/properties/sequenceNumber/type',
                                        keyword: 'type',
                                        params: { type: 'number' },
                                        message: 'must be number',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs6 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.unlockingBytecode !== undefined) {
                                let data3 = data.unlockingBytecode;
                                const _errs8 = errors;
                                const _errs9 = errors;
                                let valid1 = false;
                                const _errs10 = errors;
                                if (!validate28$1(data3, {
                                    instancePath: instancePath + '/unlockingBytecode',
                                    parentData: data,
                                    parentDataProperty: 'unlockingBytecode',
                                    rootData,
                                })) {
                                    vErrors =
                                        vErrors === null
                                            ? validate28$1.errors
                                            : vErrors.concat(validate28$1.errors);
                                    errors = vErrors.length;
                                }
                                var _valid0 = _errs10 === errors;
                                valid1 = valid1 || _valid0;
                                if (!valid1) {
                                    const _errs11 = errors;
                                    if (errors === _errs11) {
                                        if (Array.isArray(data3)) {
                                            if (data3.length > 1) {
                                                const err0 = {
                                                    instancePath: instancePath + '/unlockingBytecode',
                                                    schemaPath: '#/properties/unlockingBytecode/anyOf/1/maxItems',
                                                    keyword: 'maxItems',
                                                    params: { limit: 1 },
                                                    message: 'must NOT have more than 1 items',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err0];
                                                }
                                                else {
                                                    vErrors.push(err0);
                                                }
                                                errors++;
                                            }
                                            else {
                                                if (data3.length < 1) {
                                                    const err1 = {
                                                        instancePath: instancePath + '/unlockingBytecode',
                                                        schemaPath: '#/properties/unlockingBytecode/anyOf/1/minItems',
                                                        keyword: 'minItems',
                                                        params: { limit: 1 },
                                                        message: 'must NOT have fewer than 1 items',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err1];
                                                    }
                                                    else {
                                                        vErrors.push(err1);
                                                    }
                                                    errors++;
                                                }
                                                else {
                                                    var valid2 = true;
                                                    const len0 = data3.length;
                                                    for (let i0 = 0; i0 < len0; i0++) {
                                                        let data4 = data3[i0];
                                                        const _errs13 = errors;
                                                        if (typeof data4 !== 'string') {
                                                            const err2 = {
                                                                instancePath: instancePath + '/unlockingBytecode/' + i0,
                                                                schemaPath: '#/properties/unlockingBytecode/anyOf/1/items/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err2];
                                                            }
                                                            else {
                                                                vErrors.push(err2);
                                                            }
                                                            errors++;
                                                        }
                                                        if ('slot' !== data4) {
                                                            const err3 = {
                                                                instancePath: instancePath + '/unlockingBytecode/' + i0,
                                                                schemaPath: '#/properties/unlockingBytecode/anyOf/1/items/const',
                                                                keyword: 'const',
                                                                params: { allowedValue: 'slot' },
                                                                message: 'must be equal to constant',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err3];
                                                            }
                                                            else {
                                                                vErrors.push(err3);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid2 = _errs13 === errors;
                                                        if (!valid2) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            const err4 = {
                                                instancePath: instancePath + '/unlockingBytecode',
                                                schemaPath: '#/properties/unlockingBytecode/anyOf/1/type',
                                                keyword: 'type',
                                                params: { type: 'array' },
                                                message: 'must be array',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err4];
                                            }
                                            else {
                                                vErrors.push(err4);
                                            }
                                            errors++;
                                        }
                                    }
                                    var _valid0 = _errs11 === errors;
                                    valid1 = valid1 || _valid0;
                                }
                                if (!valid1) {
                                    const err5 = {
                                        instancePath: instancePath + '/unlockingBytecode',
                                        schemaPath: '#/properties/unlockingBytecode/anyOf',
                                        keyword: 'anyOf',
                                        params: {},
                                        message: 'must match a schema in anyOf',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err5];
                                    }
                                    else {
                                        vErrors.push(err5);
                                    }
                                    errors++;
                                    validate31.errors = vErrors;
                                    return false;
                                }
                                else {
                                    errors = _errs9;
                                    if (vErrors !== null) {
                                        if (_errs9) {
                                            vErrors.length = _errs9;
                                        }
                                        else {
                                            vErrors = null;
                                        }
                                    }
                                }
                                var valid0 = _errs8 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                        }
                    }
                }
            }
        }
        else {
            validate31.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate31.errors = vErrors;
    return errors === 0;
}
const schema36 = {
    properties: {
        token: {
            properties: {
                amount: {
                    type: ['number', 'string'],
                },
                nft: {
                    properties: {
                        capability: {
                            enum: ['minting', 'mutable', 'none']}}},
            }},
        valueSatoshis: {
            type: ['number', 'string'],
        },
    }};
function validate34(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            const _errs1 = errors;
            for (const key0 in data) {
                if (!(key0 === 'lockingBytecode' ||
                    key0 === 'token' ||
                    key0 === 'valueSatoshis')) {
                    validate34.errors = [
                        {
                            instancePath,
                            schemaPath: '#/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        },
                    ];
                    return false;
                }
            }
            if (_errs1 === errors) {
                if (data.lockingBytecode !== undefined) {
                    const _errs2 = errors;
                    if (!validate28$1(data.lockingBytecode, {
                        instancePath: instancePath + '/lockingBytecode',
                        parentData: data,
                        parentDataProperty: 'lockingBytecode',
                        rootData,
                    })) {
                        vErrors =
                            vErrors === null
                                ? validate28$1.errors
                                : vErrors.concat(validate28$1.errors);
                        errors = vErrors.length;
                    }
                    var valid0 = _errs2 === errors;
                }
                else {
                    var valid0 = true;
                }
                if (valid0) {
                    if (data.token !== undefined) {
                        let data1 = data.token;
                        const _errs3 = errors;
                        if (errors === _errs3) {
                            if (data1 && typeof data1 == 'object' && !Array.isArray(data1)) {
                                const _errs5 = errors;
                                for (const key1 in data1) {
                                    if (!(key1 === 'amount' ||
                                        key1 === 'category' ||
                                        key1 === 'nft')) {
                                        validate34.errors = [
                                            {
                                                instancePath: instancePath + '/token',
                                                schemaPath: '#/properties/token/additionalProperties',
                                                keyword: 'additionalProperties',
                                                params: { additionalProperty: key1 },
                                                message: 'must NOT have additional properties',
                                            },
                                        ];
                                        return false;
                                    }
                                }
                                if (_errs5 === errors) {
                                    if (data1.amount !== undefined) {
                                        let data2 = data1.amount;
                                        const _errs6 = errors;
                                        if (!(typeof data2 == 'number' && isFinite(data2)) &&
                                            typeof data2 !== 'string') {
                                            validate34.errors = [
                                                {
                                                    instancePath: instancePath + '/token/amount',
                                                    schemaPath: '#/properties/token/properties/amount/type',
                                                    keyword: 'type',
                                                    params: {
                                                        type: schema36.properties.token.properties.amount
                                                            .type,
                                                    },
                                                    message: 'must be number,string',
                                                },
                                            ];
                                            return false;
                                        }
                                        var valid1 = _errs6 === errors;
                                    }
                                    else {
                                        var valid1 = true;
                                    }
                                    if (valid1) {
                                        if (data1.category !== undefined) {
                                            const _errs8 = errors;
                                            if (typeof data1.category !== 'string') {
                                                validate34.errors = [
                                                    {
                                                        instancePath: instancePath + '/token/category',
                                                        schemaPath: '#/properties/token/properties/category/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    },
                                                ];
                                                return false;
                                            }
                                            var valid1 = _errs8 === errors;
                                        }
                                        else {
                                            var valid1 = true;
                                        }
                                        if (valid1) {
                                            if (data1.nft !== undefined) {
                                                let data4 = data1.nft;
                                                const _errs10 = errors;
                                                if (errors === _errs10) {
                                                    if (data4 &&
                                                        typeof data4 == 'object' &&
                                                        !Array.isArray(data4)) {
                                                        const _errs12 = errors;
                                                        for (const key2 in data4) {
                                                            if (!(key2 === 'capability' || key2 === 'commitment')) {
                                                                validate34.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/token/nft',
                                                                        schemaPath: '#/properties/token/properties/nft/additionalProperties',
                                                                        keyword: 'additionalProperties',
                                                                        params: { additionalProperty: key2 },
                                                                        message: 'must NOT have additional properties',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                        }
                                                        if (_errs12 === errors) {
                                                            if (data4.capability !== undefined) {
                                                                let data5 = data4.capability;
                                                                const _errs13 = errors;
                                                                if (typeof data5 !== 'string') {
                                                                    validate34.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/token/nft/capability',
                                                                            schemaPath: '#/properties/token/properties/nft/properties/capability/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'string' },
                                                                            message: 'must be string',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                if (!(data5 === 'minting' ||
                                                                    data5 === 'mutable' ||
                                                                    data5 === 'none')) {
                                                                    validate34.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/token/nft/capability',
                                                                            schemaPath: '#/properties/token/properties/nft/properties/capability/enum',
                                                                            keyword: 'enum',
                                                                            params: {
                                                                                allowedValues: schema36.properties.token.properties
                                                                                    .nft.properties.capability.enum,
                                                                            },
                                                                            message: 'must be equal to one of the allowed values',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                var valid2 = _errs13 === errors;
                                                            }
                                                            else {
                                                                var valid2 = true;
                                                            }
                                                            if (valid2) {
                                                                if (data4.commitment !== undefined) {
                                                                    const _errs15 = errors;
                                                                    if (typeof data4.commitment !== 'string') {
                                                                        validate34.errors = [
                                                                            {
                                                                                instancePath: instancePath +
                                                                                    '/token/nft/commitment',
                                                                                schemaPath: '#/properties/token/properties/nft/properties/commitment/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    var valid2 = _errs15 === errors;
                                                                }
                                                                else {
                                                                    var valid2 = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate34.errors = [
                                                            {
                                                                instancePath: instancePath + '/token/nft',
                                                                schemaPath: '#/properties/token/properties/nft/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid1 = _errs10 === errors;
                                            }
                                            else {
                                                var valid1 = true;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                validate34.errors = [
                                    {
                                        instancePath: instancePath + '/token',
                                        schemaPath: '#/properties/token/type',
                                        keyword: 'type',
                                        params: { type: 'object' },
                                        message: 'must be object',
                                    },
                                ];
                                return false;
                            }
                        }
                        var valid0 = _errs3 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.valueSatoshis !== undefined) {
                            let data7 = data.valueSatoshis;
                            const _errs17 = errors;
                            if (!(typeof data7 == 'number' && isFinite(data7)) &&
                                typeof data7 !== 'string') {
                                validate34.errors = [
                                    {
                                        instancePath: instancePath + '/valueSatoshis',
                                        schemaPath: '#/properties/valueSatoshis/type',
                                        keyword: 'type',
                                        params: { type: schema36.properties.valueSatoshis.type },
                                        message: 'must be number,string',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs17 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                    }
                }
            }
        }
        else {
            validate34.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate34.errors = vErrors;
    return errors === 0;
}
function validate26$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            const _errs1 = errors;
            for (const key0 in data) {
                if (!(key0 === 'data' ||
                    key0 === 'description' ||
                    key0 === 'extends' ||
                    key0 === 'name' ||
                    key0 === 'sourceOutputs' ||
                    key0 === 'transaction')) {
                    validate26$1.errors = [
                        {
                            instancePath,
                            schemaPath: '#/additionalProperties',
                            keyword: 'additionalProperties',
                            params: { additionalProperty: key0 },
                            message: 'must NOT have additional properties',
                        },
                    ];
                    return false;
                }
            }
            if (_errs1 === errors) {
                if (data.data !== undefined) {
                    let data0 = data.data;
                    const _errs2 = errors;
                    const _errs3 = errors;
                    if (errors === _errs3) {
                        if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
                            const _errs5 = errors;
                            for (const key1 in data0) {
                                if (!(key1 === 'bytecode' ||
                                    key1 === 'currentBlockHeight' ||
                                    key1 === 'currentBlockTime' ||
                                    key1 === 'hdKeys' ||
                                    key1 === 'keys')) {
                                    validate26$1.errors = [
                                        {
                                            instancePath: instancePath + '/data',
                                            schemaPath: '#/definitions/WalletTemplateScenarioData/additionalProperties',
                                            keyword: 'additionalProperties',
                                            params: { additionalProperty: key1 },
                                            message: 'must NOT have additional properties',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            if (_errs5 === errors) {
                                if (data0.bytecode !== undefined) {
                                    let data1 = data0.bytecode;
                                    const _errs6 = errors;
                                    if (errors === _errs6) {
                                        if (data1 &&
                                            typeof data1 == 'object' &&
                                            !Array.isArray(data1)) {
                                            for (const key2 in data1) {
                                                const _errs9 = errors;
                                                if (typeof data1[key2] !== 'string') {
                                                    validate26$1.errors = [
                                                        {
                                                            instancePath: instancePath +
                                                                '/data/bytecode/' +
                                                                key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/bytecode/additionalProperties/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                                var valid3 = _errs9 === errors;
                                                if (!valid3) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            validate26$1.errors = [
                                                {
                                                    instancePath: instancePath + '/data/bytecode',
                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/bytecode/type',
                                                    keyword: 'type',
                                                    params: { type: 'object' },
                                                    message: 'must be object',
                                                },
                                            ];
                                            return false;
                                        }
                                    }
                                    var valid2 = _errs6 === errors;
                                }
                                else {
                                    var valid2 = true;
                                }
                                if (valid2) {
                                    if (data0.currentBlockHeight !== undefined) {
                                        let data3 = data0.currentBlockHeight;
                                        const _errs11 = errors;
                                        if (!(typeof data3 == 'number' && isFinite(data3))) {
                                            validate26$1.errors = [
                                                {
                                                    instancePath: instancePath + '/data/currentBlockHeight',
                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/currentBlockHeight/type',
                                                    keyword: 'type',
                                                    params: { type: 'number' },
                                                    message: 'must be number',
                                                },
                                            ];
                                            return false;
                                        }
                                        var valid2 = _errs11 === errors;
                                    }
                                    else {
                                        var valid2 = true;
                                    }
                                    if (valid2) {
                                        if (data0.currentBlockTime !== undefined) {
                                            let data4 = data0.currentBlockTime;
                                            const _errs13 = errors;
                                            if (!(typeof data4 == 'number' && isFinite(data4))) {
                                                validate26$1.errors = [
                                                    {
                                                        instancePath: instancePath + '/data/currentBlockTime',
                                                        schemaPath: '#/definitions/WalletTemplateScenarioData/properties/currentBlockTime/type',
                                                        keyword: 'type',
                                                        params: { type: 'number' },
                                                        message: 'must be number',
                                                    },
                                                ];
                                                return false;
                                            }
                                            var valid2 = _errs13 === errors;
                                        }
                                        else {
                                            var valid2 = true;
                                        }
                                        if (valid2) {
                                            if (data0.hdKeys !== undefined) {
                                                let data5 = data0.hdKeys;
                                                const _errs15 = errors;
                                                if (errors === _errs15) {
                                                    if (data5 &&
                                                        typeof data5 == 'object' &&
                                                        !Array.isArray(data5)) {
                                                        const _errs17 = errors;
                                                        for (const key3 in data5) {
                                                            if (!(key3 === 'addressIndex' ||
                                                                key3 === 'hdPrivateKeys' ||
                                                                key3 === 'hdPublicKeys')) {
                                                                validate26$1.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/data/hdKeys',
                                                                        schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/additionalProperties',
                                                                        keyword: 'additionalProperties',
                                                                        params: { additionalProperty: key3 },
                                                                        message: 'must NOT have additional properties',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                        }
                                                        if (_errs17 === errors) {
                                                            if (data5.addressIndex !== undefined) {
                                                                let data6 = data5.addressIndex;
                                                                const _errs18 = errors;
                                                                if (!(typeof data6 == 'number' && isFinite(data6))) {
                                                                    validate26$1.errors = [
                                                                        {
                                                                            instancePath: instancePath +
                                                                                '/data/hdKeys/addressIndex',
                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/addressIndex/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'number' },
                                                                            message: 'must be number',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                var valid4 = _errs18 === errors;
                                                            }
                                                            else {
                                                                var valid4 = true;
                                                            }
                                                            if (valid4) {
                                                                if (data5.hdPrivateKeys !== undefined) {
                                                                    let data7 = data5.hdPrivateKeys;
                                                                    const _errs20 = errors;
                                                                    if (errors === _errs20) {
                                                                        if (data7 &&
                                                                            typeof data7 == 'object' &&
                                                                            !Array.isArray(data7)) {
                                                                            for (const key4 in data7) {
                                                                                const _errs23 = errors;
                                                                                if (typeof data7[key4] !== 'string') {
                                                                                    validate26$1.errors = [
                                                                                        {
                                                                                            instancePath: instancePath +
                                                                                                '/data/hdKeys/hdPrivateKeys/' +
                                                                                                key4
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1'),
                                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/additionalProperties/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'string' },
                                                                                            message: 'must be string',
                                                                                        },
                                                                                    ];
                                                                                    return false;
                                                                                }
                                                                                var valid5 = _errs23 === errors;
                                                                                if (!valid5) {
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }
                                                                        else {
                                                                            validate26$1.errors = [
                                                                                {
                                                                                    instancePath: instancePath +
                                                                                        '/data/hdKeys/hdPrivateKeys',
                                                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'object' },
                                                                                    message: 'must be object',
                                                                                },
                                                                            ];
                                                                            return false;
                                                                        }
                                                                    }
                                                                    var valid4 = _errs20 === errors;
                                                                }
                                                                else {
                                                                    var valid4 = true;
                                                                }
                                                                if (valid4) {
                                                                    if (data5.hdPublicKeys !== undefined) {
                                                                        let data9 = data5.hdPublicKeys;
                                                                        const _errs25 = errors;
                                                                        if (errors === _errs25) {
                                                                            if (data9 &&
                                                                                typeof data9 == 'object' &&
                                                                                !Array.isArray(data9)) {
                                                                                for (const key5 in data9) {
                                                                                    const _errs28 = errors;
                                                                                    if (typeof data9[key5] !== 'string') {
                                                                                        validate26$1.errors = [
                                                                                            {
                                                                                                instancePath: instancePath +
                                                                                                    '/data/hdKeys/hdPublicKeys/' +
                                                                                                    key5
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1'),
                                                                                                schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/additionalProperties/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'string' },
                                                                                                message: 'must be string',
                                                                                            },
                                                                                        ];
                                                                                        return false;
                                                                                    }
                                                                                    var valid6 = _errs28 === errors;
                                                                                    if (!valid6) {
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            else {
                                                                                validate26$1.errors = [
                                                                                    {
                                                                                        instancePath: instancePath +
                                                                                            '/data/hdKeys/hdPublicKeys',
                                                                                        schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'object' },
                                                                                        message: 'must be object',
                                                                                    },
                                                                                ];
                                                                                return false;
                                                                            }
                                                                        }
                                                                        var valid4 = _errs25 === errors;
                                                                    }
                                                                    else {
                                                                        var valid4 = true;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate26$1.errors = [
                                                            {
                                                                instancePath: instancePath + '/data/hdKeys',
                                                                schemaPath: '#/definitions/WalletTemplateScenarioData/properties/hdKeys/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid2 = _errs15 === errors;
                                            }
                                            else {
                                                var valid2 = true;
                                            }
                                            if (valid2) {
                                                if (data0.keys !== undefined) {
                                                    let data11 = data0.keys;
                                                    const _errs30 = errors;
                                                    if (errors === _errs30) {
                                                        if (data11 &&
                                                            typeof data11 == 'object' &&
                                                            !Array.isArray(data11)) {
                                                            const _errs32 = errors;
                                                            for (const key6 in data11) {
                                                                if (!(key6 === 'privateKeys')) {
                                                                    validate26$1.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/data/keys',
                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/additionalProperties',
                                                                            keyword: 'additionalProperties',
                                                                            params: { additionalProperty: key6 },
                                                                            message: 'must NOT have additional properties',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                            }
                                                            if (_errs32 === errors) {
                                                                if (data11.privateKeys !== undefined) {
                                                                    let data12 = data11.privateKeys;
                                                                    const _errs33 = errors;
                                                                    if (errors === _errs33) {
                                                                        if (data12 &&
                                                                            typeof data12 == 'object' &&
                                                                            !Array.isArray(data12)) {
                                                                            for (const key7 in data12) {
                                                                                const _errs36 = errors;
                                                                                if (typeof data12[key7] !== 'string') {
                                                                                    validate26$1.errors = [
                                                                                        {
                                                                                            instancePath: instancePath +
                                                                                                '/data/keys/privateKeys/' +
                                                                                                key7
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1'),
                                                                                            schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/properties/privateKeys/additionalProperties/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'string' },
                                                                                            message: 'must be string',
                                                                                        },
                                                                                    ];
                                                                                    return false;
                                                                                }
                                                                                var valid8 = _errs36 === errors;
                                                                                if (!valid8) {
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }
                                                                        else {
                                                                            validate26$1.errors = [
                                                                                {
                                                                                    instancePath: instancePath +
                                                                                        '/data/keys/privateKeys',
                                                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/properties/privateKeys/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'object' },
                                                                                    message: 'must be object',
                                                                                },
                                                                            ];
                                                                            return false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else {
                                                            validate26$1.errors = [
                                                                {
                                                                    instancePath: instancePath + '/data/keys',
                                                                    schemaPath: '#/definitions/WalletTemplateScenarioData/properties/keys/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'object' },
                                                                    message: 'must be object',
                                                                },
                                                            ];
                                                            return false;
                                                        }
                                                    }
                                                    var valid2 = _errs30 === errors;
                                                }
                                                else {
                                                    var valid2 = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            validate26$1.errors = [
                                {
                                    instancePath: instancePath + '/data',
                                    schemaPath: '#/definitions/WalletTemplateScenarioData/type',
                                    keyword: 'type',
                                    params: { type: 'object' },
                                    message: 'must be object',
                                },
                            ];
                            return false;
                        }
                    }
                    var valid0 = _errs2 === errors;
                }
                else {
                    var valid0 = true;
                }
                if (valid0) {
                    if (data.description !== undefined) {
                        const _errs38 = errors;
                        if (typeof data.description !== 'string') {
                            validate26$1.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs38 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.extends !== undefined) {
                            const _errs40 = errors;
                            if (typeof data.extends !== 'string') {
                                validate26$1.errors = [
                                    {
                                        instancePath: instancePath + '/extends',
                                        schemaPath: '#/properties/extends/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs40 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.name !== undefined) {
                                const _errs42 = errors;
                                if (typeof data.name !== 'string') {
                                    validate26$1.errors = [
                                        {
                                            instancePath: instancePath + '/name',
                                            schemaPath: '#/properties/name/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs42 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.sourceOutputs !== undefined) {
                                    let data17 = data.sourceOutputs;
                                    const _errs44 = errors;
                                    if (errors === _errs44) {
                                        if (Array.isArray(data17)) {
                                            var valid9 = true;
                                            const len0 = data17.length;
                                            for (let i0 = 0; i0 < len0; i0++) {
                                                const _errs46 = errors;
                                                if (!validate27$1(data17[i0], {
                                                    instancePath: instancePath + '/sourceOutputs/' + i0,
                                                    parentData: data17,
                                                    parentDataProperty: i0,
                                                    rootData,
                                                })) {
                                                    vErrors =
                                                        vErrors === null
                                                            ? validate27$1.errors
                                                            : vErrors.concat(validate27$1.errors);
                                                    errors = vErrors.length;
                                                }
                                                var valid9 = _errs46 === errors;
                                                if (!valid9) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            validate26$1.errors = [
                                                {
                                                    instancePath: instancePath + '/sourceOutputs',
                                                    schemaPath: '#/properties/sourceOutputs/type',
                                                    keyword: 'type',
                                                    params: { type: 'array' },
                                                    message: 'must be array',
                                                },
                                            ];
                                            return false;
                                        }
                                    }
                                    var valid0 = _errs44 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.transaction !== undefined) {
                                        let data19 = data.transaction;
                                        const _errs47 = errors;
                                        if (errors === _errs47) {
                                            if (data19 &&
                                                typeof data19 == 'object' &&
                                                !Array.isArray(data19)) {
                                                const _errs49 = errors;
                                                for (const key8 in data19) {
                                                    if (!(key8 === 'inputs' ||
                                                        key8 === 'locktime' ||
                                                        key8 === 'outputs' ||
                                                        key8 === 'version')) {
                                                        validate26$1.errors = [
                                                            {
                                                                instancePath: instancePath + '/transaction',
                                                                schemaPath: '#/properties/transaction/additionalProperties',
                                                                keyword: 'additionalProperties',
                                                                params: { additionalProperty: key8 },
                                                                message: 'must NOT have additional properties',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                if (_errs49 === errors) {
                                                    if (data19.inputs !== undefined) {
                                                        let data20 = data19.inputs;
                                                        const _errs50 = errors;
                                                        if (errors === _errs50) {
                                                            if (Array.isArray(data20)) {
                                                                var valid11 = true;
                                                                const len1 = data20.length;
                                                                for (let i1 = 0; i1 < len1; i1++) {
                                                                    const _errs52 = errors;
                                                                    if (!validate31(data20[i1], {
                                                                        instancePath: instancePath +
                                                                            '/transaction/inputs/' +
                                                                            i1,
                                                                        parentData: data20,
                                                                        parentDataProperty: i1,
                                                                        rootData,
                                                                    })) {
                                                                        vErrors =
                                                                            vErrors === null
                                                                                ? validate31.errors
                                                                                : vErrors.concat(validate31.errors);
                                                                        errors = vErrors.length;
                                                                    }
                                                                    var valid11 = _errs52 === errors;
                                                                    if (!valid11) {
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                validate26$1.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/transaction/inputs',
                                                                        schemaPath: '#/properties/transaction/properties/inputs/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'array' },
                                                                        message: 'must be array',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                        }
                                                        var valid10 = _errs50 === errors;
                                                    }
                                                    else {
                                                        var valid10 = true;
                                                    }
                                                    if (valid10) {
                                                        if (data19.locktime !== undefined) {
                                                            let data22 = data19.locktime;
                                                            const _errs53 = errors;
                                                            if (!(typeof data22 == 'number' && isFinite(data22))) {
                                                                validate26$1.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/transaction/locktime',
                                                                        schemaPath: '#/properties/transaction/properties/locktime/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'number' },
                                                                        message: 'must be number',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                            var valid10 = _errs53 === errors;
                                                        }
                                                        else {
                                                            var valid10 = true;
                                                        }
                                                        if (valid10) {
                                                            if (data19.outputs !== undefined) {
                                                                let data23 = data19.outputs;
                                                                const _errs55 = errors;
                                                                if (errors === _errs55) {
                                                                    if (Array.isArray(data23)) {
                                                                        var valid12 = true;
                                                                        const len2 = data23.length;
                                                                        for (let i2 = 0; i2 < len2; i2++) {
                                                                            const _errs57 = errors;
                                                                            if (!validate34(data23[i2], {
                                                                                instancePath: instancePath +
                                                                                    '/transaction/outputs/' +
                                                                                    i2,
                                                                                parentData: data23,
                                                                                parentDataProperty: i2,
                                                                                rootData,
                                                                            })) {
                                                                                vErrors =
                                                                                    vErrors === null
                                                                                        ? validate34.errors
                                                                                        : vErrors.concat(validate34.errors);
                                                                                errors = vErrors.length;
                                                                            }
                                                                            var valid12 = _errs57 === errors;
                                                                            if (!valid12) {
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                    else {
                                                                        validate26$1.errors = [
                                                                            {
                                                                                instancePath: instancePath + '/transaction/outputs',
                                                                                schemaPath: '#/properties/transaction/properties/outputs/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'array' },
                                                                                message: 'must be array',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                }
                                                                var valid10 = _errs55 === errors;
                                                            }
                                                            else {
                                                                var valid10 = true;
                                                            }
                                                            if (valid10) {
                                                                if (data19.version !== undefined) {
                                                                    let data25 = data19.version;
                                                                    const _errs58 = errors;
                                                                    if (!(typeof data25 == 'number' &&
                                                                        isFinite(data25))) {
                                                                        validate26$1.errors = [
                                                                            {
                                                                                instancePath: instancePath + '/transaction/version',
                                                                                schemaPath: '#/properties/transaction/properties/version/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'number' },
                                                                                message: 'must be number',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    var valid10 = _errs58 === errors;
                                                                }
                                                                else {
                                                                    var valid10 = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                validate26$1.errors = [
                                                    {
                                                        instancePath: instancePath + '/transaction',
                                                        schemaPath: '#/properties/transaction/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    },
                                                ];
                                                return false;
                                            }
                                        }
                                        var valid0 = _errs47 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate26$1.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate26$1.errors = vErrors;
    return errors === 0;
}
function validate38(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if ((data.script === undefined && (missing0 = 'script')) ||
                (data.tests === undefined && (missing0 = 'tests'))) {
                validate38.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                for (const key0 in data) {
                    if (!(key0 === 'name' ||
                        key0 === 'pushed' ||
                        key0 === 'script' ||
                        key0 === 'tests')) {
                        validate38.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                {
                    if (data.name !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.name !== 'string') {
                            validate38.errors = [
                                {
                                    instancePath: instancePath + '/name',
                                    schemaPath: '#/properties/name/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.pushed !== undefined) {
                            const _errs4 = errors;
                            if (typeof data.pushed !== 'boolean') {
                                validate38.errors = [
                                    {
                                        instancePath: instancePath + '/pushed',
                                        schemaPath: '#/properties/pushed/type',
                                        keyword: 'type',
                                        params: { type: 'boolean' },
                                        message: 'must be boolean',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.script !== undefined) {
                                const _errs6 = errors;
                                if (typeof data.script !== 'string') {
                                    validate38.errors = [
                                        {
                                            instancePath: instancePath + '/script',
                                            schemaPath: '#/properties/script/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs6 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.tests !== undefined) {
                                    let data3 = data.tests;
                                    const _errs8 = errors;
                                    {
                                        if (data3 &&
                                            typeof data3 == 'object' &&
                                            !Array.isArray(data3)) {
                                            for (const key1 in data3) {
                                                let data4 = data3[key1];
                                                const _errs11 = errors;
                                                {
                                                    if (data4 &&
                                                        typeof data4 == 'object' &&
                                                        !Array.isArray(data4)) {
                                                        let missing1;
                                                        if (data4.check === undefined &&
                                                            (missing1 = 'check')) {
                                                            validate38.errors = [
                                                                {
                                                                    instancePath: instancePath +
                                                                        '/tests/' +
                                                                        key1
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1'),
                                                                    schemaPath: '#/definitions/WalletTemplateScriptTest/required',
                                                                    keyword: 'required',
                                                                    params: { missingProperty: missing1 },
                                                                    message: "must have required property '" +
                                                                        missing1 +
                                                                        "'",
                                                                },
                                                            ];
                                                            return false;
                                                        }
                                                        else {
                                                            for (const key2 in data4) {
                                                                if (!(key2 === 'check' ||
                                                                    key2 === 'fails' ||
                                                                    key2 === 'invalid' ||
                                                                    key2 === 'name' ||
                                                                    key2 === 'passes' ||
                                                                    key2 === 'setup')) {
                                                                    validate38.errors = [
                                                                        {
                                                                            instancePath: instancePath +
                                                                                '/tests/' +
                                                                                key1
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1'),
                                                                            schemaPath: '#/definitions/WalletTemplateScriptTest/additionalProperties',
                                                                            keyword: 'additionalProperties',
                                                                            params: { additionalProperty: key2 },
                                                                            message: 'must NOT have additional properties',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                            }
                                                            {
                                                                if (data4.check !== undefined) {
                                                                    const _errs15 = errors;
                                                                    if (typeof data4.check !== 'string') {
                                                                        validate38.errors = [
                                                                            {
                                                                                instancePath: instancePath +
                                                                                    '/tests/' +
                                                                                    key1
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/check',
                                                                                schemaPath: '#/definitions/WalletTemplateScriptTest/properties/check/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    var valid3 = _errs15 === errors;
                                                                }
                                                                else {
                                                                    var valid3 = true;
                                                                }
                                                                if (valid3) {
                                                                    if (data4.fails !== undefined) {
                                                                        let data6 = data4.fails;
                                                                        const _errs17 = errors;
                                                                        {
                                                                            if (Array.isArray(data6)) {
                                                                                var valid4 = true;
                                                                                const len0 = data6.length;
                                                                                for (let i0 = 0; i0 < len0; i0++) {
                                                                                    const _errs19 = errors;
                                                                                    if (typeof data6[i0] !== 'string') {
                                                                                        validate38.errors = [
                                                                                            {
                                                                                                instancePath: instancePath +
                                                                                                    '/tests/' +
                                                                                                    key1
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1') +
                                                                                                    '/fails/' +
                                                                                                    i0,
                                                                                                schemaPath: '#/definitions/WalletTemplateScriptTest/properties/fails/items/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'string' },
                                                                                                message: 'must be string',
                                                                                            },
                                                                                        ];
                                                                                        return false;
                                                                                    }
                                                                                    var valid4 = _errs19 === errors;
                                                                                    if (!valid4) {
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            else {
                                                                                validate38.errors = [
                                                                                    {
                                                                                        instancePath: instancePath +
                                                                                            '/tests/' +
                                                                                            key1
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/fails',
                                                                                        schemaPath: '#/definitions/WalletTemplateScriptTest/properties/fails/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'array' },
                                                                                        message: 'must be array',
                                                                                    },
                                                                                ];
                                                                                return false;
                                                                            }
                                                                        }
                                                                        var valid3 = _errs17 === errors;
                                                                    }
                                                                    else {
                                                                        var valid3 = true;
                                                                    }
                                                                    if (valid3) {
                                                                        if (data4.invalid !== undefined) {
                                                                            let data8 = data4.invalid;
                                                                            const _errs21 = errors;
                                                                            {
                                                                                if (Array.isArray(data8)) {
                                                                                    var valid5 = true;
                                                                                    const len1 = data8.length;
                                                                                    for (let i1 = 0; i1 < len1; i1++) {
                                                                                        const _errs23 = errors;
                                                                                        if (typeof data8[i1] !== 'string') {
                                                                                            validate38.errors = [
                                                                                                {
                                                                                                    instancePath: instancePath +
                                                                                                        '/tests/' +
                                                                                                        key1
                                                                                                            .replace(/~/g, '~0')
                                                                                                            .replace(/\//g, '~1') +
                                                                                                        '/invalid/' +
                                                                                                        i1,
                                                                                                    schemaPath: '#/definitions/WalletTemplateScriptTest/properties/invalid/items/type',
                                                                                                    keyword: 'type',
                                                                                                    params: { type: 'string' },
                                                                                                    message: 'must be string',
                                                                                                },
                                                                                            ];
                                                                                            return false;
                                                                                        }
                                                                                        var valid5 = _errs23 === errors;
                                                                                        if (!valid5) {
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                else {
                                                                                    validate38.errors = [
                                                                                        {
                                                                                            instancePath: instancePath +
                                                                                                '/tests/' +
                                                                                                key1
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1') +
                                                                                                '/invalid',
                                                                                            schemaPath: '#/definitions/WalletTemplateScriptTest/properties/invalid/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'array' },
                                                                                            message: 'must be array',
                                                                                        },
                                                                                    ];
                                                                                    return false;
                                                                                }
                                                                            }
                                                                            var valid3 = _errs21 === errors;
                                                                        }
                                                                        else {
                                                                            var valid3 = true;
                                                                        }
                                                                        if (valid3) {
                                                                            if (data4.name !== undefined) {
                                                                                const _errs25 = errors;
                                                                                if (typeof data4.name !== 'string') {
                                                                                    validate38.errors = [
                                                                                        {
                                                                                            instancePath: instancePath +
                                                                                                '/tests/' +
                                                                                                key1
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1') +
                                                                                                '/name',
                                                                                            schemaPath: '#/definitions/WalletTemplateScriptTest/properties/name/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'string' },
                                                                                            message: 'must be string',
                                                                                        },
                                                                                    ];
                                                                                    return false;
                                                                                }
                                                                                var valid3 = _errs25 === errors;
                                                                            }
                                                                            else {
                                                                                var valid3 = true;
                                                                            }
                                                                            if (valid3) {
                                                                                if (data4.passes !== undefined) {
                                                                                    let data11 = data4.passes;
                                                                                    const _errs27 = errors;
                                                                                    {
                                                                                        if (Array.isArray(data11)) {
                                                                                            var valid6 = true;
                                                                                            const len2 = data11.length;
                                                                                            for (let i2 = 0; i2 < len2; i2++) {
                                                                                                const _errs29 = errors;
                                                                                                if (typeof data11[i2] !== 'string') {
                                                                                                    validate38.errors = [
                                                                                                        {
                                                                                                            instancePath: instancePath +
                                                                                                                '/tests/' +
                                                                                                                key1
                                                                                                                    .replace(/~/g, '~0')
                                                                                                                    .replace(/\//g, '~1') +
                                                                                                                '/passes/' +
                                                                                                                i2,
                                                                                                            schemaPath: '#/definitions/WalletTemplateScriptTest/properties/passes/items/type',
                                                                                                            keyword: 'type',
                                                                                                            params: {
                                                                                                                type: 'string',
                                                                                                            },
                                                                                                            message: 'must be string',
                                                                                                        },
                                                                                                    ];
                                                                                                    return false;
                                                                                                }
                                                                                                var valid6 = _errs29 === errors;
                                                                                                if (!valid6) {
                                                                                                    break;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        else {
                                                                                            validate38.errors = [
                                                                                                {
                                                                                                    instancePath: instancePath +
                                                                                                        '/tests/' +
                                                                                                        key1
                                                                                                            .replace(/~/g, '~0')
                                                                                                            .replace(/\//g, '~1') +
                                                                                                        '/passes',
                                                                                                    schemaPath: '#/definitions/WalletTemplateScriptTest/properties/passes/type',
                                                                                                    keyword: 'type',
                                                                                                    params: { type: 'array' },
                                                                                                    message: 'must be array',
                                                                                                },
                                                                                            ];
                                                                                            return false;
                                                                                        }
                                                                                    }
                                                                                    var valid3 = _errs27 === errors;
                                                                                }
                                                                                else {
                                                                                    var valid3 = true;
                                                                                }
                                                                                if (valid3) {
                                                                                    if (data4.setup !== undefined) {
                                                                                        const _errs31 = errors;
                                                                                        if (typeof data4.setup !== 'string') {
                                                                                            validate38.errors = [
                                                                                                {
                                                                                                    instancePath: instancePath +
                                                                                                        '/tests/' +
                                                                                                        key1
                                                                                                            .replace(/~/g, '~0')
                                                                                                            .replace(/\//g, '~1') +
                                                                                                        '/setup',
                                                                                                    schemaPath: '#/definitions/WalletTemplateScriptTest/properties/setup/type',
                                                                                                    keyword: 'type',
                                                                                                    params: { type: 'string' },
                                                                                                    message: 'must be string',
                                                                                                },
                                                                                            ];
                                                                                            return false;
                                                                                        }
                                                                                        var valid3 = _errs31 === errors;
                                                                                    }
                                                                                    else {
                                                                                        var valid3 = true;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate38.errors = [
                                                            {
                                                                instancePath: instancePath +
                                                                    '/tests/' +
                                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/WalletTemplateScriptTest/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid1 = _errs11 === errors;
                                                if (!valid1) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            validate38.errors = [
                                                {
                                                    instancePath: instancePath + '/tests',
                                                    schemaPath: '#/properties/tests/type',
                                                    keyword: 'type',
                                                    params: { type: 'object' },
                                                    message: 'must be object',
                                                },
                                            ];
                                            return false;
                                        }
                                    }
                                    var valid0 = _errs8 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate38.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate38.errors = vErrors;
    return errors === 0;
}
const func4$1 = Object.prototype.hasOwnProperty;
function validate21$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if ((data.entities === undefined && (missing0 = 'entities')) ||
                (data.scripts === undefined && (missing0 = 'scripts')) ||
                (data.supported === undefined && (missing0 = 'supported'))) {
                validate21$1.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === '$schema' ||
                        key0 === 'description' ||
                        key0 === 'entities' ||
                        key0 === 'name' ||
                        key0 === 'scenarios' ||
                        key0 === 'scripts' ||
                        key0 === 'supported' ||
                        key0 === 'version')) {
                        validate21$1.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.$schema !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.$schema !== 'string') {
                            validate21$1.errors = [
                                {
                                    instancePath: instancePath + '/$schema',
                                    schemaPath: '#/properties/%24schema/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.description !== undefined) {
                            const _errs4 = errors;
                            if (typeof data.description !== 'string') {
                                validate21$1.errors = [
                                    {
                                        instancePath: instancePath + '/description',
                                        schemaPath: '#/properties/description/type',
                                        keyword: 'type',
                                        params: { type: 'string' },
                                        message: 'must be string',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.entities !== undefined) {
                                let data2 = data.entities;
                                const _errs6 = errors;
                                if (errors === _errs6) {
                                    if (data2 &&
                                        typeof data2 == 'object' &&
                                        !Array.isArray(data2)) {
                                        for (const key1 in data2) {
                                            const _errs9 = errors;
                                            if (!validate22$1(data2[key1], {
                                                instancePath: instancePath +
                                                    '/entities/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                parentData: data2,
                                                parentDataProperty: key1,
                                                rootData,
                                            })) {
                                                vErrors =
                                                    vErrors === null
                                                        ? validate22$1.errors
                                                        : vErrors.concat(validate22$1.errors);
                                                errors = vErrors.length;
                                            }
                                            var valid1 = _errs9 === errors;
                                            if (!valid1) {
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        validate21$1.errors = [
                                            {
                                                instancePath: instancePath + '/entities',
                                                schemaPath: '#/properties/entities/type',
                                                keyword: 'type',
                                                params: { type: 'object' },
                                                message: 'must be object',
                                            },
                                        ];
                                        return false;
                                    }
                                }
                                var valid0 = _errs6 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.name !== undefined) {
                                    const _errs10 = errors;
                                    if (typeof data.name !== 'string') {
                                        validate21$1.errors = [
                                            {
                                                instancePath: instancePath + '/name',
                                                schemaPath: '#/properties/name/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            },
                                        ];
                                        return false;
                                    }
                                    var valid0 = _errs10 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.scenarios !== undefined) {
                                        let data5 = data.scenarios;
                                        const _errs12 = errors;
                                        if (errors === _errs12) {
                                            if (data5 &&
                                                typeof data5 == 'object' &&
                                                !Array.isArray(data5)) {
                                                for (const key2 in data5) {
                                                    const _errs15 = errors;
                                                    if (!validate26$1(data5[key2], {
                                                        instancePath: instancePath +
                                                            '/scenarios/' +
                                                            key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        parentData: data5,
                                                        parentDataProperty: key2,
                                                        rootData,
                                                    })) {
                                                        vErrors =
                                                            vErrors === null
                                                                ? validate26$1.errors
                                                                : vErrors.concat(validate26$1.errors);
                                                        errors = vErrors.length;
                                                    }
                                                    var valid2 = _errs15 === errors;
                                                    if (!valid2) {
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                validate21$1.errors = [
                                                    {
                                                        instancePath: instancePath + '/scenarios',
                                                        schemaPath: '#/properties/scenarios/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    },
                                                ];
                                                return false;
                                            }
                                        }
                                        var valid0 = _errs12 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                    if (valid0) {
                                        if (data.scripts !== undefined) {
                                            let data7 = data.scripts;
                                            const _errs16 = errors;
                                            if (errors === _errs16) {
                                                if (data7 &&
                                                    typeof data7 == 'object' &&
                                                    !Array.isArray(data7)) {
                                                    for (const key3 in data7) {
                                                        let data8 = data7[key3];
                                                        const _errs19 = errors;
                                                        const _errs20 = errors;
                                                        let valid4 = false;
                                                        const _errs21 = errors;
                                                        const _errs22 = errors;
                                                        if (errors === _errs22) {
                                                            if (data8 &&
                                                                typeof data8 == 'object' &&
                                                                !Array.isArray(data8)) {
                                                                let missing1;
                                                                if (data8.script === undefined &&
                                                                    (missing1 = 'script')) {
                                                                    const err0 = {
                                                                        instancePath: instancePath +
                                                                            '/scripts/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/WalletTemplateScript/required',
                                                                        keyword: 'required',
                                                                        params: { missingProperty: missing1 },
                                                                        message: "must have required property '" +
                                                                            missing1 +
                                                                            "'",
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err0];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err0);
                                                                    }
                                                                    errors++;
                                                                }
                                                                else {
                                                                    const _errs24 = errors;
                                                                    for (const key4 in data8) {
                                                                        if (!(key4 === 'name' || key4 === 'script')) {
                                                                            const err1 = {
                                                                                instancePath: instancePath +
                                                                                    '/scripts/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/WalletTemplateScript/additionalProperties',
                                                                                keyword: 'additionalProperties',
                                                                                params: { additionalProperty: key4 },
                                                                                message: 'must NOT have additional properties',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err1];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err1);
                                                                            }
                                                                            errors++;
                                                                            break;
                                                                        }
                                                                    }
                                                                    if (_errs24 === errors) {
                                                                        if (data8.name !== undefined) {
                                                                            const _errs25 = errors;
                                                                            if (typeof data8.name !== 'string') {
                                                                                const err2 = {
                                                                                    instancePath: instancePath +
                                                                                        '/scripts/' +
                                                                                        key3
                                                                                            .replace(/~/g, '~0')
                                                                                            .replace(/\//g, '~1') +
                                                                                        '/name',
                                                                                    schemaPath: '#/definitions/WalletTemplateScript/properties/name/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'string' },
                                                                                    message: 'must be string',
                                                                                };
                                                                                if (vErrors === null) {
                                                                                    vErrors = [err2];
                                                                                }
                                                                                else {
                                                                                    vErrors.push(err2);
                                                                                }
                                                                                errors++;
                                                                            }
                                                                            var valid6 = _errs25 === errors;
                                                                        }
                                                                        else {
                                                                            var valid6 = true;
                                                                        }
                                                                        if (valid6) {
                                                                            if (data8.script !== undefined) {
                                                                                const _errs27 = errors;
                                                                                if (typeof data8.script !== 'string') {
                                                                                    const err3 = {
                                                                                        instancePath: instancePath +
                                                                                            '/scripts/' +
                                                                                            key3
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/script',
                                                                                        schemaPath: '#/definitions/WalletTemplateScript/properties/script/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'string' },
                                                                                        message: 'must be string',
                                                                                    };
                                                                                    if (vErrors === null) {
                                                                                        vErrors = [err3];
                                                                                    }
                                                                                    else {
                                                                                        vErrors.push(err3);
                                                                                    }
                                                                                    errors++;
                                                                                }
                                                                                var valid6 = _errs27 === errors;
                                                                            }
                                                                            else {
                                                                                var valid6 = true;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                const err4 = {
                                                                    instancePath: instancePath +
                                                                        '/scripts/' +
                                                                        key3
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1'),
                                                                    schemaPath: '#/definitions/WalletTemplateScript/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'object' },
                                                                    message: 'must be object',
                                                                };
                                                                if (vErrors === null) {
                                                                    vErrors = [err4];
                                                                }
                                                                else {
                                                                    vErrors.push(err4);
                                                                }
                                                                errors++;
                                                            }
                                                        }
                                                        var _valid0 = _errs21 === errors;
                                                        valid4 = valid4 || _valid0;
                                                        if (!valid4) {
                                                            const _errs29 = errors;
                                                            const _errs30 = errors;
                                                            if (errors === _errs30) {
                                                                if (data8 &&
                                                                    typeof data8 == 'object' &&
                                                                    !Array.isArray(data8)) {
                                                                    let missing2;
                                                                    if ((data8.lockingType === undefined &&
                                                                        (missing2 = 'lockingType')) ||
                                                                        (data8.script === undefined &&
                                                                            (missing2 = 'script'))) {
                                                                        const err5 = {
                                                                            instancePath: instancePath +
                                                                                '/scripts/' +
                                                                                key3
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1'),
                                                                            schemaPath: '#/definitions/WalletTemplateScriptLocking/required',
                                                                            keyword: 'required',
                                                                            params: { missingProperty: missing2 },
                                                                            message: "must have required property '" +
                                                                                missing2 +
                                                                                "'",
                                                                        };
                                                                        if (vErrors === null) {
                                                                            vErrors = [err5];
                                                                        }
                                                                        else {
                                                                            vErrors.push(err5);
                                                                        }
                                                                        errors++;
                                                                    }
                                                                    else {
                                                                        const _errs32 = errors;
                                                                        for (const key5 in data8) {
                                                                            if (!(key5 === 'lockingType' ||
                                                                                key5 === 'name' ||
                                                                                key5 === 'script')) {
                                                                                const err6 = {
                                                                                    instancePath: instancePath +
                                                                                        '/scripts/' +
                                                                                        key3
                                                                                            .replace(/~/g, '~0')
                                                                                            .replace(/\//g, '~1'),
                                                                                    schemaPath: '#/definitions/WalletTemplateScriptLocking/additionalProperties',
                                                                                    keyword: 'additionalProperties',
                                                                                    params: { additionalProperty: key5 },
                                                                                    message: 'must NOT have additional properties',
                                                                                };
                                                                                if (vErrors === null) {
                                                                                    vErrors = [err6];
                                                                                }
                                                                                else {
                                                                                    vErrors.push(err6);
                                                                                }
                                                                                errors++;
                                                                                break;
                                                                            }
                                                                        }
                                                                        if (_errs32 === errors) {
                                                                            if (data8.lockingType !== undefined) {
                                                                                let data11 = data8.lockingType;
                                                                                const _errs33 = errors;
                                                                                if (typeof data11 !== 'string') {
                                                                                    const err7 = {
                                                                                        instancePath: instancePath +
                                                                                            '/scripts/' +
                                                                                            key3
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/lockingType',
                                                                                        schemaPath: '#/definitions/WalletTemplateScriptLocking/properties/lockingType/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'string' },
                                                                                        message: 'must be string',
                                                                                    };
                                                                                    if (vErrors === null) {
                                                                                        vErrors = [err7];
                                                                                    }
                                                                                    else {
                                                                                        vErrors.push(err7);
                                                                                    }
                                                                                    errors++;
                                                                                }
                                                                                if (!(data11 === 'p2sh20' ||
                                                                                    data11 === 'p2sh32' ||
                                                                                    data11 === 'standard')) {
                                                                                    const err8 = {
                                                                                        instancePath: instancePath +
                                                                                            '/scripts/' +
                                                                                            key3
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/lockingType',
                                                                                        schemaPath: '#/definitions/WalletTemplateScriptLocking/properties/lockingType/enum',
                                                                                        keyword: 'enum',
                                                                                        params: {
                                                                                            allowedValues: schema38.properties.lockingType
                                                                                                .enum,
                                                                                        },
                                                                                        message: 'must be equal to one of the allowed values',
                                                                                    };
                                                                                    if (vErrors === null) {
                                                                                        vErrors = [err8];
                                                                                    }
                                                                                    else {
                                                                                        vErrors.push(err8);
                                                                                    }
                                                                                    errors++;
                                                                                }
                                                                                var valid8 = _errs33 === errors;
                                                                            }
                                                                            else {
                                                                                var valid8 = true;
                                                                            }
                                                                            if (valid8) {
                                                                                if (data8.name !== undefined) {
                                                                                    const _errs35 = errors;
                                                                                    if (typeof data8.name !== 'string') {
                                                                                        const err9 = {
                                                                                            instancePath: instancePath +
                                                                                                '/scripts/' +
                                                                                                key3
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1') +
                                                                                                '/name',
                                                                                            schemaPath: '#/definitions/WalletTemplateScriptLocking/properties/name/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'string' },
                                                                                            message: 'must be string',
                                                                                        };
                                                                                        if (vErrors === null) {
                                                                                            vErrors = [err9];
                                                                                        }
                                                                                        else {
                                                                                            vErrors.push(err9);
                                                                                        }
                                                                                        errors++;
                                                                                    }
                                                                                    var valid8 = _errs35 === errors;
                                                                                }
                                                                                else {
                                                                                    var valid8 = true;
                                                                                }
                                                                                if (valid8) {
                                                                                    if (data8.script !== undefined) {
                                                                                        const _errs37 = errors;
                                                                                        if (typeof data8.script !== 'string') {
                                                                                            const err10 = {
                                                                                                instancePath: instancePath +
                                                                                                    '/scripts/' +
                                                                                                    key3
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1') +
                                                                                                    '/script',
                                                                                                schemaPath: '#/definitions/WalletTemplateScriptLocking/properties/script/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'string' },
                                                                                                message: 'must be string',
                                                                                            };
                                                                                            if (vErrors === null) {
                                                                                                vErrors = [err10];
                                                                                            }
                                                                                            else {
                                                                                                vErrors.push(err10);
                                                                                            }
                                                                                            errors++;
                                                                                        }
                                                                                        var valid8 = _errs37 === errors;
                                                                                    }
                                                                                    else {
                                                                                        var valid8 = true;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err11 = {
                                                                        instancePath: instancePath +
                                                                            '/scripts/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/WalletTemplateScriptLocking/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err11];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err11);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var _valid0 = _errs29 === errors;
                                                            valid4 = valid4 || _valid0;
                                                            if (!valid4) {
                                                                const _errs39 = errors;
                                                                if (!validate38(data8, {
                                                                    instancePath: instancePath +
                                                                        '/scripts/' +
                                                                        key3
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1'),
                                                                    parentData: data7,
                                                                    parentDataProperty: key3,
                                                                    rootData,
                                                                })) {
                                                                    vErrors =
                                                                        vErrors === null
                                                                            ? validate38.errors
                                                                            : vErrors.concat(validate38.errors);
                                                                    errors = vErrors.length;
                                                                }
                                                                var _valid0 = _errs39 === errors;
                                                                valid4 = valid4 || _valid0;
                                                                if (!valid4) {
                                                                    const _errs40 = errors;
                                                                    const _errs41 = errors;
                                                                    if (errors === _errs41) {
                                                                        if (data8 &&
                                                                            typeof data8 == 'object' &&
                                                                            !Array.isArray(data8)) {
                                                                            let missing3;
                                                                            if ((data8.script === undefined &&
                                                                                (missing3 = 'script')) ||
                                                                                (data8.unlocks === undefined &&
                                                                                    (missing3 = 'unlocks'))) {
                                                                                const err12 = {
                                                                                    instancePath: instancePath +
                                                                                        '/scripts/' +
                                                                                        key3
                                                                                            .replace(/~/g, '~0')
                                                                                            .replace(/\//g, '~1'),
                                                                                    schemaPath: '#/definitions/WalletTemplateScriptUnlocking/required',
                                                                                    keyword: 'required',
                                                                                    params: { missingProperty: missing3 },
                                                                                    message: "must have required property '" +
                                                                                        missing3 +
                                                                                        "'",
                                                                                };
                                                                                if (vErrors === null) {
                                                                                    vErrors = [err12];
                                                                                }
                                                                                else {
                                                                                    vErrors.push(err12);
                                                                                }
                                                                                errors++;
                                                                            }
                                                                            else {
                                                                                const _errs43 = errors;
                                                                                for (const key6 in data8) {
                                                                                    if (!func4$1.call(schema41.properties, key6)) {
                                                                                        const err13 = {
                                                                                            instancePath: instancePath +
                                                                                                '/scripts/' +
                                                                                                key3
                                                                                                    .replace(/~/g, '~0')
                                                                                                    .replace(/\//g, '~1'),
                                                                                            schemaPath: '#/definitions/WalletTemplateScriptUnlocking/additionalProperties',
                                                                                            keyword: 'additionalProperties',
                                                                                            params: {
                                                                                                additionalProperty: key6,
                                                                                            },
                                                                                            message: 'must NOT have additional properties',
                                                                                        };
                                                                                        if (vErrors === null) {
                                                                                            vErrors = [err13];
                                                                                        }
                                                                                        else {
                                                                                            vErrors.push(err13);
                                                                                        }
                                                                                        errors++;
                                                                                        break;
                                                                                    }
                                                                                }
                                                                                if (_errs43 === errors) {
                                                                                    if (data8.ageLock !== undefined) {
                                                                                        const _errs44 = errors;
                                                                                        if (typeof data8.ageLock !== 'string') {
                                                                                            const err14 = {
                                                                                                instancePath: instancePath +
                                                                                                    '/scripts/' +
                                                                                                    key3
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1') +
                                                                                                    '/ageLock',
                                                                                                schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/ageLock/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'string' },
                                                                                                message: 'must be string',
                                                                                            };
                                                                                            if (vErrors === null) {
                                                                                                vErrors = [err14];
                                                                                            }
                                                                                            else {
                                                                                                vErrors.push(err14);
                                                                                            }
                                                                                            errors++;
                                                                                        }
                                                                                        var valid10 = _errs44 === errors;
                                                                                    }
                                                                                    else {
                                                                                        var valid10 = true;
                                                                                    }
                                                                                    if (valid10) {
                                                                                        if (data8.estimate !== undefined) {
                                                                                            const _errs46 = errors;
                                                                                            if (typeof data8.estimate !==
                                                                                                'string') {
                                                                                                const err15 = {
                                                                                                    instancePath: instancePath +
                                                                                                        '/scripts/' +
                                                                                                        key3
                                                                                                            .replace(/~/g, '~0')
                                                                                                            .replace(/\//g, '~1') +
                                                                                                        '/estimate',
                                                                                                    schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/estimate/type',
                                                                                                    keyword: 'type',
                                                                                                    params: { type: 'string' },
                                                                                                    message: 'must be string',
                                                                                                };
                                                                                                if (vErrors === null) {
                                                                                                    vErrors = [err15];
                                                                                                }
                                                                                                else {
                                                                                                    vErrors.push(err15);
                                                                                                }
                                                                                                errors++;
                                                                                            }
                                                                                            var valid10 = _errs46 === errors;
                                                                                        }
                                                                                        else {
                                                                                            var valid10 = true;
                                                                                        }
                                                                                        if (valid10) {
                                                                                            if (data8.fails !== undefined) {
                                                                                                let data16 = data8.fails;
                                                                                                const _errs48 = errors;
                                                                                                if (errors === _errs48) {
                                                                                                    if (Array.isArray(data16)) {
                                                                                                        var valid11 = true;
                                                                                                        const len0 = data16.length;
                                                                                                        for (let i0 = 0; i0 < len0; i0++) {
                                                                                                            const _errs50 = errors;
                                                                                                            if (typeof data16[i0] !==
                                                                                                                'string') {
                                                                                                                const err16 = {
                                                                                                                    instancePath: instancePath +
                                                                                                                        '/scripts/' +
                                                                                                                        key3
                                                                                                                            .replace(/~/g, '~0')
                                                                                                                            .replace(/\//g, '~1') +
                                                                                                                        '/fails/' +
                                                                                                                        i0,
                                                                                                                    schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/fails/items/type',
                                                                                                                    keyword: 'type',
                                                                                                                    params: {
                                                                                                                        type: 'string',
                                                                                                                    },
                                                                                                                    message: 'must be string',
                                                                                                                };
                                                                                                                if (vErrors === null) {
                                                                                                                    vErrors = [err16];
                                                                                                                }
                                                                                                                else {
                                                                                                                    vErrors.push(err16);
                                                                                                                }
                                                                                                                errors++;
                                                                                                            }
                                                                                                            var valid11 = _errs50 === errors;
                                                                                                            if (!valid11) {
                                                                                                                break;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    else {
                                                                                                        const err17 = {
                                                                                                            instancePath: instancePath +
                                                                                                                '/scripts/' +
                                                                                                                key3
                                                                                                                    .replace(/~/g, '~0')
                                                                                                                    .replace(/\//g, '~1') +
                                                                                                                '/fails',
                                                                                                            schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/fails/type',
                                                                                                            keyword: 'type',
                                                                                                            params: { type: 'array' },
                                                                                                            message: 'must be array',
                                                                                                        };
                                                                                                        if (vErrors === null) {
                                                                                                            vErrors = [err17];
                                                                                                        }
                                                                                                        else {
                                                                                                            vErrors.push(err17);
                                                                                                        }
                                                                                                        errors++;
                                                                                                    }
                                                                                                }
                                                                                                var valid10 = _errs48 === errors;
                                                                                            }
                                                                                            else {
                                                                                                var valid10 = true;
                                                                                            }
                                                                                            if (valid10) {
                                                                                                if (data8.invalid !== undefined) {
                                                                                                    let data18 = data8.invalid;
                                                                                                    const _errs52 = errors;
                                                                                                    if (errors === _errs52) {
                                                                                                        if (Array.isArray(data18)) {
                                                                                                            var valid12 = true;
                                                                                                            const len1 = data18.length;
                                                                                                            for (let i1 = 0; i1 < len1; i1++) {
                                                                                                                const _errs54 = errors;
                                                                                                                if (typeof data18[i1] !==
                                                                                                                    'string') {
                                                                                                                    const err18 = {
                                                                                                                        instancePath: instancePath +
                                                                                                                            '/scripts/' +
                                                                                                                            key3
                                                                                                                                .replace(/~/g, '~0')
                                                                                                                                .replace(/\//g, '~1') +
                                                                                                                            '/invalid/' +
                                                                                                                            i1,
                                                                                                                        schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/invalid/items/type',
                                                                                                                        keyword: 'type',
                                                                                                                        params: {
                                                                                                                            type: 'string',
                                                                                                                        },
                                                                                                                        message: 'must be string',
                                                                                                                    };
                                                                                                                    if (vErrors === null) {
                                                                                                                        vErrors = [err18];
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        vErrors.push(err18);
                                                                                                                    }
                                                                                                                    errors++;
                                                                                                                }
                                                                                                                var valid12 = _errs54 === errors;
                                                                                                                if (!valid12) {
                                                                                                                    break;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        else {
                                                                                                            const err19 = {
                                                                                                                instancePath: instancePath +
                                                                                                                    '/scripts/' +
                                                                                                                    key3
                                                                                                                        .replace(/~/g, '~0')
                                                                                                                        .replace(/\//g, '~1') +
                                                                                                                    '/invalid',
                                                                                                                schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/invalid/type',
                                                                                                                keyword: 'type',
                                                                                                                params: {
                                                                                                                    type: 'array',
                                                                                                                },
                                                                                                                message: 'must be array',
                                                                                                            };
                                                                                                            if (vErrors === null) {
                                                                                                                vErrors = [err19];
                                                                                                            }
                                                                                                            else {
                                                                                                                vErrors.push(err19);
                                                                                                            }
                                                                                                            errors++;
                                                                                                        }
                                                                                                    }
                                                                                                    var valid10 = _errs52 === errors;
                                                                                                }
                                                                                                else {
                                                                                                    var valid10 = true;
                                                                                                }
                                                                                                if (valid10) {
                                                                                                    if (data8.name !== undefined) {
                                                                                                        const _errs56 = errors;
                                                                                                        if (typeof data8.name !==
                                                                                                            'string') {
                                                                                                            const err20 = {
                                                                                                                instancePath: instancePath +
                                                                                                                    '/scripts/' +
                                                                                                                    key3
                                                                                                                        .replace(/~/g, '~0')
                                                                                                                        .replace(/\//g, '~1') +
                                                                                                                    '/name',
                                                                                                                schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/name/type',
                                                                                                                keyword: 'type',
                                                                                                                params: {
                                                                                                                    type: 'string',
                                                                                                                },
                                                                                                                message: 'must be string',
                                                                                                            };
                                                                                                            if (vErrors === null) {
                                                                                                                vErrors = [err20];
                                                                                                            }
                                                                                                            else {
                                                                                                                vErrors.push(err20);
                                                                                                            }
                                                                                                            errors++;
                                                                                                        }
                                                                                                        var valid10 = _errs56 === errors;
                                                                                                    }
                                                                                                    else {
                                                                                                        var valid10 = true;
                                                                                                    }
                                                                                                    if (valid10) {
                                                                                                        if (data8.passes !== undefined) {
                                                                                                            let data21 = data8.passes;
                                                                                                            const _errs58 = errors;
                                                                                                            if (errors === _errs58) {
                                                                                                                if (Array.isArray(data21)) {
                                                                                                                    var valid13 = true;
                                                                                                                    const len2 = data21.length;
                                                                                                                    for (let i2 = 0; i2 < len2; i2++) {
                                                                                                                        const _errs60 = errors;
                                                                                                                        if (typeof data21[i2] !== 'string') {
                                                                                                                            const err21 = {
                                                                                                                                instancePath: instancePath +
                                                                                                                                    '/scripts/' +
                                                                                                                                    key3
                                                                                                                                        .replace(/~/g, '~0')
                                                                                                                                        .replace(/\//g, '~1') +
                                                                                                                                    '/passes/' +
                                                                                                                                    i2,
                                                                                                                                schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/passes/items/type',
                                                                                                                                keyword: 'type',
                                                                                                                                params: {
                                                                                                                                    type: 'string',
                                                                                                                                },
                                                                                                                                message: 'must be string',
                                                                                                                            };
                                                                                                                            if (vErrors === null) {
                                                                                                                                vErrors = [
                                                                                                                                    err21,
                                                                                                                                ];
                                                                                                                            }
                                                                                                                            else {
                                                                                                                                vErrors.push(err21);
                                                                                                                            }
                                                                                                                            errors++;
                                                                                                                        }
                                                                                                                        var valid13 = _errs60 ===
                                                                                                                            errors;
                                                                                                                        if (!valid13) {
                                                                                                                            break;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                else {
                                                                                                                    const err22 = {
                                                                                                                        instancePath: instancePath +
                                                                                                                            '/scripts/' +
                                                                                                                            key3
                                                                                                                                .replace(/~/g, '~0')
                                                                                                                                .replace(/\//g, '~1') +
                                                                                                                            '/passes',
                                                                                                                        schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/passes/type',
                                                                                                                        keyword: 'type',
                                                                                                                        params: {
                                                                                                                            type: 'array',
                                                                                                                        },
                                                                                                                        message: 'must be array',
                                                                                                                    };
                                                                                                                    if (vErrors === null) {
                                                                                                                        vErrors = [err22];
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        vErrors.push(err22);
                                                                                                                    }
                                                                                                                    errors++;
                                                                                                                }
                                                                                                            }
                                                                                                            var valid10 = _errs58 === errors;
                                                                                                        }
                                                                                                        else {
                                                                                                            var valid10 = true;
                                                                                                        }
                                                                                                        if (valid10) {
                                                                                                            if (data8.script !==
                                                                                                                undefined) {
                                                                                                                const _errs62 = errors;
                                                                                                                if (typeof data8.script !==
                                                                                                                    'string') {
                                                                                                                    const err23 = {
                                                                                                                        instancePath: instancePath +
                                                                                                                            '/scripts/' +
                                                                                                                            key3
                                                                                                                                .replace(/~/g, '~0')
                                                                                                                                .replace(/\//g, '~1') +
                                                                                                                            '/script',
                                                                                                                        schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/script/type',
                                                                                                                        keyword: 'type',
                                                                                                                        params: {
                                                                                                                            type: 'string',
                                                                                                                        },
                                                                                                                        message: 'must be string',
                                                                                                                    };
                                                                                                                    if (vErrors === null) {
                                                                                                                        vErrors = [err23];
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        vErrors.push(err23);
                                                                                                                    }
                                                                                                                    errors++;
                                                                                                                }
                                                                                                                var valid10 = _errs62 === errors;
                                                                                                            }
                                                                                                            else {
                                                                                                                var valid10 = true;
                                                                                                            }
                                                                                                            if (valid10) {
                                                                                                                if (data8.timeLockType !==
                                                                                                                    undefined) {
                                                                                                                    let data24 = data8.timeLockType;
                                                                                                                    const _errs64 = errors;
                                                                                                                    if (typeof data24 !==
                                                                                                                        'string') {
                                                                                                                        const err24 = {
                                                                                                                            instancePath: instancePath +
                                                                                                                                '/scripts/' +
                                                                                                                                key3
                                                                                                                                    .replace(/~/g, '~0')
                                                                                                                                    .replace(/\//g, '~1') +
                                                                                                                                '/timeLockType',
                                                                                                                            schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/timeLockType/type',
                                                                                                                            keyword: 'type',
                                                                                                                            params: {
                                                                                                                                type: 'string',
                                                                                                                            },
                                                                                                                            message: 'must be string',
                                                                                                                        };
                                                                                                                        if (vErrors === null) {
                                                                                                                            vErrors = [err24];
                                                                                                                        }
                                                                                                                        else {
                                                                                                                            vErrors.push(err24);
                                                                                                                        }
                                                                                                                        errors++;
                                                                                                                    }
                                                                                                                    if (!(data24 ===
                                                                                                                        'height' ||
                                                                                                                        data24 ===
                                                                                                                            'timestamp')) {
                                                                                                                        const err25 = {
                                                                                                                            instancePath: instancePath +
                                                                                                                                '/scripts/' +
                                                                                                                                key3
                                                                                                                                    .replace(/~/g, '~0')
                                                                                                                                    .replace(/\//g, '~1') +
                                                                                                                                '/timeLockType',
                                                                                                                            schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/timeLockType/enum',
                                                                                                                            keyword: 'enum',
                                                                                                                            params: {
                                                                                                                                allowedValues: schema41
                                                                                                                                    .properties
                                                                                                                                    .timeLockType
                                                                                                                                    .enum,
                                                                                                                            },
                                                                                                                            message: 'must be equal to one of the allowed values',
                                                                                                                        };
                                                                                                                        if (vErrors === null) {
                                                                                                                            vErrors = [err25];
                                                                                                                        }
                                                                                                                        else {
                                                                                                                            vErrors.push(err25);
                                                                                                                        }
                                                                                                                        errors++;
                                                                                                                    }
                                                                                                                    var valid10 = _errs64 === errors;
                                                                                                                }
                                                                                                                else {
                                                                                                                    var valid10 = true;
                                                                                                                }
                                                                                                                if (valid10) {
                                                                                                                    if (data8.unlocks !==
                                                                                                                        undefined) {
                                                                                                                        const _errs66 = errors;
                                                                                                                        if (typeof data8.unlocks !==
                                                                                                                            'string') {
                                                                                                                            const err26 = {
                                                                                                                                instancePath: instancePath +
                                                                                                                                    '/scripts/' +
                                                                                                                                    key3
                                                                                                                                        .replace(/~/g, '~0')
                                                                                                                                        .replace(/\//g, '~1') +
                                                                                                                                    '/unlocks',
                                                                                                                                schemaPath: '#/definitions/WalletTemplateScriptUnlocking/properties/unlocks/type',
                                                                                                                                keyword: 'type',
                                                                                                                                params: {
                                                                                                                                    type: 'string',
                                                                                                                                },
                                                                                                                                message: 'must be string',
                                                                                                                            };
                                                                                                                            if (vErrors === null) {
                                                                                                                                vErrors = [
                                                                                                                                    err26,
                                                                                                                                ];
                                                                                                                            }
                                                                                                                            else {
                                                                                                                                vErrors.push(err26);
                                                                                                                            }
                                                                                                                            errors++;
                                                                                                                        }
                                                                                                                        var valid10 = _errs66 ===
                                                                                                                            errors;
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        var valid10 = true;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        else {
                                                                            const err27 = {
                                                                                instancePath: instancePath +
                                                                                    '/scripts/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/WalletTemplateScriptUnlocking/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'object' },
                                                                                message: 'must be object',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err27];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err27);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                    }
                                                                    var _valid0 = _errs40 === errors;
                                                                    valid4 = valid4 || _valid0;
                                                                }
                                                            }
                                                        }
                                                        if (!valid4) {
                                                            const err28 = {
                                                                instancePath: instancePath +
                                                                    '/scripts/' +
                                                                    key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/properties/scripts/additionalProperties/anyOf',
                                                                keyword: 'anyOf',
                                                                params: {},
                                                                message: 'must match a schema in anyOf',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err28];
                                                            }
                                                            else {
                                                                vErrors.push(err28);
                                                            }
                                                            errors++;
                                                            validate21$1.errors = vErrors;
                                                            return false;
                                                        }
                                                        else {
                                                            errors = _errs20;
                                                            if (vErrors !== null) {
                                                                if (_errs20) {
                                                                    vErrors.length = _errs20;
                                                                }
                                                                else {
                                                                    vErrors = null;
                                                                }
                                                            }
                                                        }
                                                        var valid3 = _errs19 === errors;
                                                        if (!valid3) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    validate21$1.errors = [
                                                        {
                                                            instancePath: instancePath + '/scripts',
                                                            schemaPath: '#/properties/scripts/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                            }
                                            var valid0 = _errs16 === errors;
                                        }
                                        else {
                                            var valid0 = true;
                                        }
                                        if (valid0) {
                                            if (data.supported !== undefined) {
                                                let data26 = data.supported;
                                                const _errs68 = errors;
                                                if (errors === _errs68) {
                                                    if (Array.isArray(data26)) {
                                                        var valid14 = true;
                                                        const len3 = data26.length;
                                                        for (let i3 = 0; i3 < len3; i3++) {
                                                            let data27 = data26[i3];
                                                            const _errs70 = errors;
                                                            if (typeof data27 !== 'string') {
                                                                validate21$1.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/supported/' + i3,
                                                                        schemaPath: '#/definitions/AuthenticationVirtualMachineIdentifier/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'string' },
                                                                        message: 'must be string',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                            if (!(data27 === 'BCH_2020_05' ||
                                                                data27 === 'BCH_2021_05' ||
                                                                data27 === 'BCH_2022_05' ||
                                                                data27 === 'BCH_2023_05' ||
                                                                data27 === 'BCH_SPEC' ||
                                                                data27 === 'BSV_2020_02' ||
                                                                data27 === 'BSV_SPEC' ||
                                                                data27 === 'BTC_2017_08' ||
                                                                data27 === 'BTC_SPEC' ||
                                                                data27 === 'XEC_2020_05' ||
                                                                data27 === 'XEC_SPEC')) {
                                                                validate21$1.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/supported/' + i3,
                                                                        schemaPath: '#/definitions/AuthenticationVirtualMachineIdentifier/enum',
                                                                        keyword: 'enum',
                                                                        params: { allowedValues: schema42.enum },
                                                                        message: 'must be equal to one of the allowed values',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                            var valid14 = _errs70 === errors;
                                                            if (!valid14) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate21$1.errors = [
                                                            {
                                                                instancePath: instancePath + '/supported',
                                                                schemaPath: '#/properties/supported/type',
                                                                keyword: 'type',
                                                                params: { type: 'array' },
                                                                message: 'must be array',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid0 = _errs68 === errors;
                                            }
                                            else {
                                                var valid0 = true;
                                            }
                                            if (valid0) {
                                                if (data.version !== undefined) {
                                                    let data28 = data.version;
                                                    const _errs73 = errors;
                                                    if (!(typeof data28 == 'number' && isFinite(data28))) {
                                                        validate21$1.errors = [
                                                            {
                                                                instancePath: instancePath + '/version',
                                                                schemaPath: '#/properties/version/type',
                                                                keyword: 'type',
                                                                params: { type: 'number' },
                                                                message: 'must be number',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                    if (0 !== data28) {
                                                        validate21$1.errors = [
                                                            {
                                                                instancePath: instancePath + '/version',
                                                                schemaPath: '#/properties/version/const',
                                                                keyword: 'const',
                                                                params: { allowedValue: 0 },
                                                                message: 'must be equal to constant',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                    var valid0 = _errs73 === errors;
                                                }
                                                else {
                                                    var valid0 = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate21$1.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate21$1.errors = vErrors;
    return errors === 0;
}
function validate20$1(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (!validate21$1(data, {
        instancePath,
        parentData,
        parentDataProperty,
        rootData,
    })) {
        vErrors =
            vErrors === null ? validate21$1.errors : vErrors.concat(validate21$1.errors);
        errors = vErrors.length;
    }
    validate20$1.errors = vErrors;
    return errors === 0;
}

const avjErrorsToDescription = (errors) => 
// TODO: translate instancePath
errors.map((error) => `${error.instancePath}: ${error.message}`).join(',');
/**
 * Given an untrusted JSON string or object and an AJV validator, verify that
 * the untrusted value is of the expected shape. Note, this method first
 * normalizes all characters in the input using `Normalization Form KC`
 * (Compatibility Decomposition, followed by Canonical Composition).
 */
const ajvStandaloneJsonParse = (untrustedJsonOrObject, validator) => {
    // eslint-disable-next-line functional/no-try-statements
    try {
        const stringified = typeof untrustedJsonOrObject === 'string'
            ? untrustedJsonOrObject
            : JSON.stringify(untrustedJsonOrObject);
        const normalized = lossyNormalize(stringified);
        const parsed = JSON.parse(normalized);
        if (validator(parsed)) {
            return parsed;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return avjErrorsToDescription(validate20$1.errors);
    }
    catch (e) {
        return `Invalid JSON. ${String(e)}`;
    }
};

const schema23 = {
    properties: {
        $schema: {
            description: 'The schema used by this registry. Many JSON editors can automatically provide inline documentation and autocomplete support using the `$schema` property, so it is recommended that registries include it. E.g.: `https://cashtokens.org/bcmr-v2.schema.json`',
            type: 'string',
        },
        chains: {
            additionalProperties: { $ref: '#/definitions/ChainHistory' },
            description: 'A map of split IDs tracked by this registry to the  {@link  ChainHistory }  for that chain/network.\n\nThe split ID of a chain is the block header hash (A.K.A. block ID) of the first unique block after the most recent tracked split – a split after which both resulting chains are considered notable or tracked by the registry. (For chains with no such splits, this is the ID of the genesis block.)\n\nNote, split ID is inherently a "relative" identifier. After a tracked split, both resulting chains will have a new split ID. However, if a wallet has not yet heard about a particular split, that wallet will continue to reference one of the resulting chains by its previous split ID, and the split-unaware wallet may create transactions that are valid on both chains (losing claimable value if the receivers of their transactions don\'t acknowledge transfers on both chains). When a registry trusted by the wallet notes the split in it\'s `chains` map, the wallet can represent the split in the user interface using the the latest  {@link  ChainSnapshot }  for each chain and splitting coins prior to spending (by introducing post-split coins in each transaction).\n\nThis map may exclude the following well-known split IDs (all clients supporting any of these chains should build-in  {@link  ChainHistory }  for those chains):\n\n- `0000000000000000029e471c41818d24b8b74c911071c4ef0b4a0509f9b5a8ce`:   A.K.A. mainnet – the BCH side of the BCH/XEC split.\n- `00000000ae25e85d9e22cd6c8d72c2f5d4b0222289d801b7f633aeae3f8c6367`:   A.K.A testnet4 – the test network on which CHIPs are activated   simultaneously with mainnet (May 15 at 12 UTC).\n- `00000000040ba9641ba98a37b2e5ceead38e4e2930ac8f145c8094f94c708727`:   A.K.A. chipnet – the test network on which CHIPs are activated 6 months   before mainnet (November 15 at 12 UTC).\n\nAll other split IDs referenced by this registry should be included in this map.',
            type: 'object',
        },
        defaultChain: {
            description: 'The split ID of the chain/network considered the "default" chain for this registry. Identities that do not specify a  {@link  IdentitySnapshot.splitId }  are assumed to be set to this split ID. For a description of split IDs, see  {@link  MetadataRegistry.chains } .\n\nIf not provided, the `defaultChain` is `0000000000000000029e471c41818d24b8b74c911071c4ef0b4a0509f9b5a8ce`, the BCH side of the BCH/XEC split (mainnet). Common values include:\n- `00000000ae25e85d9e22cd6c8d72c2f5d4b0222289d801b7f633aeae3f8c6367` (testnet4)\n- `00000000040ba9641ba98a37b2e5ceead38e4e2930ac8f145c8094f94c708727` (chipnet)',
            type: 'string',
        },
        extensions: {
            $ref: '#/definitions/Extensions',
            description: 'A mapping of `Registry` extension identifiers to extension definitions.  {@link  Extensions }  may be widely standardized or application-specific.\n\nStandardized extensions for `Registry`s include the `locale` extension. See https://github.com/bitjson/chip-bcmr#locales-extension for details.',
        },
        identities: {
            additionalProperties: { $ref: '#/definitions/IdentityHistory' },
            description: "A mapping of authbases to the `IdentityHistory` for that identity.\n\nAn authbase is a 32-byte, hex-encoded transaction hash (A.K.A. TXID) for which the zeroth-descendant transaction chain (ZDTC) authenticates and publishes an identity's claimed metadata.\n\nIdentities may represent metadata registries, specific types of tokens, companies, organizations, individuals, or other on-chain entities.",
            type: 'object',
        },
        latestRevision: {
            description: 'The timestamp of the latest revision made to this registry version. The timestamp must be provided in simplified extended ISO 8601 format, a 24-character string of format `YYYY-MM-DDTHH:mm:ss.sssZ` where timezone is zero UTC (denoted by `Z`). Note, this is the format returned by ECMAScript `Date.toISOString()`.',
            type: 'string',
        },
        license: {
            description: 'The license under which this registry is published. This may be specified as either a SPDX short identifier (https://spdx.org/licenses/) or by including the full text of the license.\n\nCommon values include:  - `CC0-1.0`: https://creativecommons.org/publicdomain/zero/1.0/  - `MIT`: https://opensource.org/licenses/MIT',
            type: 'string',
        },
        registryIdentity: {
            anyOf: [
                { $ref: '#/definitions/OffChainRegistryIdentity' },
                { type: 'string' },
            ],
            description: "The identity information of this particular registry, provided as either an authbase (recommended) or an `IdentitySnapshot`.\n\nAn authbase is a 32-byte, hex-encoded transaction hash (A.K.A. TXID) for which the zeroth-descendant transaction chain (ZDTC) authenticates and publishes all registry updates. If an authbase is provided, the registry's identity information can be found in `identities[authbase]`, and clients should immediately attempt to verify the registry's identity on-chain. (See https://github.com/bitjson/chip-bcmr#chain-resolved-registries)\n\nIf an `IdentitySnapshot` is provided directly, this registry does not support on-chain resolution/authentication, and the contained `IdentitySnapshot` can only be authenticated via DNS/HTTPS.",
        },
        tags: {
            additionalProperties: { $ref: '#/definitions/Tag' },
            description: 'A map of registry-specific `Tag`s used by this registry to convey information about identities it tracks.\n\nTags allow registries to group identities into collections of related identities, marking characteristics or those identities. Tags are standardized within a registry and may represent either labels applied by that registry (e.g. `individual`, `organization`, `token`, `wallet`, `exchange`, `staking`, `utility-token`, `security-token`, `stablecoin`, `wrapped`, `collectable`, `deflationary`, `governance`, `decentralized-exchange`, `liquidity-provider`, `sidechain`, `sidechain-bridge`, etc.) or designations by external authorities (certification, membership, ownership, etc.) that are tracked by that registry.\n\nTags may be used by clients in search, discover, and filtering of identities, and they can also convey information like accreditation from investor protection organizations, public certifications by security or financial auditors, and other designations that signal legitimacy and value to users.',
            type: 'object',
        },
        version: {
            additionalProperties: false,
            description: 'The version of this registry. Versioning adheres to Semantic Versioning (https://semver.org/).',
            properties: {
                major: {
                    description: 'The major version is incremented when an identity is removed.',
                    type: 'number',
                },
                minor: {
                    description: 'The minor version is incremented when an identity is added or a new identity snapshot is added.',
                    type: 'number',
                },
                patch: {
                    description: 'The patch version is incremented when an existing identity or identity snapshot is modified (e.g. to correct an error or add a missing piece of information) or when other registry properties (e.g. registry `name`, `description`, `uris`, etc.) are modified.\n\nGenerally, substantive changes to an existing identity should be made using a new identity snapshot in a minor version upgrade – this allows clients to provide a better user experience by noting the change in relevant user interfaces.\n\nFor example, patch upgrades might include spelling corrections in an existing snapshot or the addition of an `icon` containing a higher-resolution version of an existing `icon` image. On the other hand, a rebranding in which the icon is substantially changed may warrant a new identity snapshot to be added in a minor version upgrade.',
                    type: 'number',
                },
            },
            required: ['major', 'minor', 'patch'],
            type: 'object',
        },
    }};
const func4 = Object.prototype.hasOwnProperty;
const schema25 = {
    properties: {
        status: {
            enum: ['active', 'burned', 'inactive']}}};
function validate23(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if ((data.name === undefined && (missing0 = 'name')) ||
                (data.token === undefined && (missing0 = 'token'))) {
                validate23.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'description' ||
                        key0 === 'extensions' ||
                        key0 === 'name' ||
                        key0 === 'splitId' ||
                        key0 === 'status' ||
                        key0 === 'tags' ||
                        key0 === 'token' ||
                        key0 === 'uris')) {
                        validate23.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.description !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.description !== 'string') {
                            validate23.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.extensions !== undefined) {
                            let data1 = data.extensions;
                            const _errs4 = errors;
                            const _errs5 = errors;
                            if (errors === _errs5) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        let data2 = data1[key1];
                                        const _errs8 = errors;
                                        const _errs9 = errors;
                                        let valid3 = false;
                                        const _errs10 = errors;
                                        if (typeof data2 !== 'string') {
                                            const err0 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err0];
                                            }
                                            else {
                                                vErrors.push(err0);
                                            }
                                            errors++;
                                        }
                                        var _valid0 = _errs10 === errors;
                                        valid3 = valid3 || _valid0;
                                        if (!valid3) {
                                            const _errs12 = errors;
                                            if (errors === _errs12) {
                                                if (data2 &&
                                                    typeof data2 == 'object' &&
                                                    !Array.isArray(data2)) {
                                                    for (const key2 in data2) {
                                                        const _errs15 = errors;
                                                        if (typeof data2[key2] !== 'string') {
                                                            const err1 = {
                                                                instancePath: instancePath +
                                                                    '/extensions/' +
                                                                    key1
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/' +
                                                                    key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err1];
                                                            }
                                                            else {
                                                                vErrors.push(err1);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid4 = _errs15 === errors;
                                                        if (!valid4) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    const err2 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err2];
                                                    }
                                                    else {
                                                        vErrors.push(err2);
                                                    }
                                                    errors++;
                                                }
                                            }
                                            var _valid0 = _errs12 === errors;
                                            valid3 = valid3 || _valid0;
                                            if (!valid3) {
                                                const _errs17 = errors;
                                                if (errors === _errs17) {
                                                    if (data2 &&
                                                        typeof data2 == 'object' &&
                                                        !Array.isArray(data2)) {
                                                        for (const key3 in data2) {
                                                            let data4 = data2[key3];
                                                            const _errs20 = errors;
                                                            if (errors === _errs20) {
                                                                if (data4 &&
                                                                    typeof data4 == 'object' &&
                                                                    !Array.isArray(data4)) {
                                                                    for (const key4 in data4) {
                                                                        const _errs23 = errors;
                                                                        if (typeof data4[key4] !== 'string') {
                                                                            const err3 = {
                                                                                instancePath: instancePath +
                                                                                    '/extensions/' +
                                                                                    key1
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err3];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err3);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid6 = _errs23 === errors;
                                                                        if (!valid6) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err4 = {
                                                                        instancePath: instancePath +
                                                                            '/extensions/' +
                                                                            key1
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err4];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err4);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var valid5 = _errs20 === errors;
                                                            if (!valid5) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        const err5 = {
                                                            instancePath: instancePath +
                                                                '/extensions/' +
                                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err5];
                                                        }
                                                        else {
                                                            vErrors.push(err5);
                                                        }
                                                        errors++;
                                                    }
                                                }
                                                var _valid0 = _errs17 === errors;
                                                valid3 = valid3 || _valid0;
                                            }
                                        }
                                        if (!valid3) {
                                            const err6 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                keyword: 'anyOf',
                                                params: {},
                                                message: 'must match a schema in anyOf',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err6];
                                            }
                                            else {
                                                vErrors.push(err6);
                                            }
                                            errors++;
                                            validate23.errors = vErrors;
                                            return false;
                                        }
                                        else {
                                            errors = _errs9;
                                            if (vErrors !== null) {
                                                if (_errs9) {
                                                    vErrors.length = _errs9;
                                                }
                                                else {
                                                    vErrors = null;
                                                }
                                            }
                                        }
                                        var valid2 = _errs8 === errors;
                                        if (!valid2) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate23.errors = [
                                        {
                                            instancePath: instancePath + '/extensions',
                                            schemaPath: '#/definitions/Extensions/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.name !== undefined) {
                                const _errs25 = errors;
                                if (typeof data.name !== 'string') {
                                    validate23.errors = [
                                        {
                                            instancePath: instancePath + '/name',
                                            schemaPath: '#/properties/name/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs25 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.splitId !== undefined) {
                                    const _errs27 = errors;
                                    if (typeof data.splitId !== 'string') {
                                        validate23.errors = [
                                            {
                                                instancePath: instancePath + '/splitId',
                                                schemaPath: '#/properties/splitId/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            },
                                        ];
                                        return false;
                                    }
                                    var valid0 = _errs27 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.status !== undefined) {
                                        let data8 = data.status;
                                        const _errs29 = errors;
                                        if (typeof data8 !== 'string') {
                                            validate23.errors = [
                                                {
                                                    instancePath: instancePath + '/status',
                                                    schemaPath: '#/properties/status/type',
                                                    keyword: 'type',
                                                    params: { type: 'string' },
                                                    message: 'must be string',
                                                },
                                            ];
                                            return false;
                                        }
                                        if (!(data8 === 'active' ||
                                            data8 === 'burned' ||
                                            data8 === 'inactive')) {
                                            validate23.errors = [
                                                {
                                                    instancePath: instancePath + '/status',
                                                    schemaPath: '#/properties/status/enum',
                                                    keyword: 'enum',
                                                    params: {
                                                        allowedValues: schema25.properties.status.enum,
                                                    },
                                                    message: 'must be equal to one of the allowed values',
                                                },
                                            ];
                                            return false;
                                        }
                                        var valid0 = _errs29 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                    if (valid0) {
                                        if (data.tags !== undefined) {
                                            let data9 = data.tags;
                                            const _errs31 = errors;
                                            if (errors === _errs31) {
                                                if (Array.isArray(data9)) {
                                                    var valid7 = true;
                                                    const len0 = data9.length;
                                                    for (let i0 = 0; i0 < len0; i0++) {
                                                        const _errs33 = errors;
                                                        if (typeof data9[i0] !== 'string') {
                                                            validate23.errors = [
                                                                {
                                                                    instancePath: instancePath + '/tags/' + i0,
                                                                    schemaPath: '#/properties/tags/items/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'string' },
                                                                    message: 'must be string',
                                                                },
                                                            ];
                                                            return false;
                                                        }
                                                        var valid7 = _errs33 === errors;
                                                        if (!valid7) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    validate23.errors = [
                                                        {
                                                            instancePath: instancePath + '/tags',
                                                            schemaPath: '#/properties/tags/type',
                                                            keyword: 'type',
                                                            params: { type: 'array' },
                                                            message: 'must be array',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                            }
                                            var valid0 = _errs31 === errors;
                                        }
                                        else {
                                            var valid0 = true;
                                        }
                                        if (valid0) {
                                            if (data.token !== undefined) {
                                                let data11 = data.token;
                                                const _errs35 = errors;
                                                if (errors === _errs35) {
                                                    if (data11 &&
                                                        typeof data11 == 'object' &&
                                                        !Array.isArray(data11)) {
                                                        let missing1;
                                                        if (data11.symbol === undefined &&
                                                            (missing1 = 'symbol')) {
                                                            validate23.errors = [
                                                                {
                                                                    instancePath: instancePath + '/token',
                                                                    schemaPath: '#/properties/token/required',
                                                                    keyword: 'required',
                                                                    params: { missingProperty: missing1 },
                                                                    message: "must have required property '" +
                                                                        missing1 +
                                                                        "'",
                                                                },
                                                            ];
                                                            return false;
                                                        }
                                                        else {
                                                            const _errs37 = errors;
                                                            for (const key5 in data11) {
                                                                if (!(key5 === 'decimals' || key5 === 'symbol')) {
                                                                    validate23.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/token',
                                                                            schemaPath: '#/properties/token/additionalProperties',
                                                                            keyword: 'additionalProperties',
                                                                            params: { additionalProperty: key5 },
                                                                            message: 'must NOT have additional properties',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                            }
                                                            if (_errs37 === errors) {
                                                                if (data11.decimals !== undefined) {
                                                                    let data12 = data11.decimals;
                                                                    const _errs38 = errors;
                                                                    if (!(typeof data12 == 'number' &&
                                                                        isFinite(data12))) {
                                                                        validate23.errors = [
                                                                            {
                                                                                instancePath: instancePath + '/token/decimals',
                                                                                schemaPath: '#/properties/token/properties/decimals/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'number' },
                                                                                message: 'must be number',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    var valid8 = _errs38 === errors;
                                                                }
                                                                else {
                                                                    var valid8 = true;
                                                                }
                                                                if (valid8) {
                                                                    if (data11.symbol !== undefined) {
                                                                        const _errs40 = errors;
                                                                        if (typeof data11.symbol !== 'string') {
                                                                            validate23.errors = [
                                                                                {
                                                                                    instancePath: instancePath + '/token/symbol',
                                                                                    schemaPath: '#/properties/token/properties/symbol/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'string' },
                                                                                    message: 'must be string',
                                                                                },
                                                                            ];
                                                                            return false;
                                                                        }
                                                                        var valid8 = _errs40 === errors;
                                                                    }
                                                                    else {
                                                                        var valid8 = true;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate23.errors = [
                                                            {
                                                                instancePath: instancePath + '/token',
                                                                schemaPath: '#/properties/token/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid0 = _errs35 === errors;
                                            }
                                            else {
                                                var valid0 = true;
                                            }
                                            if (valid0) {
                                                if (data.uris !== undefined) {
                                                    let data14 = data.uris;
                                                    const _errs42 = errors;
                                                    const _errs43 = errors;
                                                    if (errors === _errs43) {
                                                        if (data14 &&
                                                            typeof data14 == 'object' &&
                                                            !Array.isArray(data14)) {
                                                            for (const key6 in data14) {
                                                                const _errs46 = errors;
                                                                if (typeof data14[key6] !== 'string') {
                                                                    validate23.errors = [
                                                                        {
                                                                            instancePath: instancePath +
                                                                                '/uris/' +
                                                                                key6
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1'),
                                                                            schemaPath: '#/definitions/URIs/additionalProperties/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'string' },
                                                                            message: 'must be string',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                var valid10 = _errs46 === errors;
                                                                if (!valid10) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        else {
                                                            validate23.errors = [
                                                                {
                                                                    instancePath: instancePath + '/uris',
                                                                    schemaPath: '#/definitions/URIs/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'object' },
                                                                    message: 'must be object',
                                                                },
                                                            ];
                                                            return false;
                                                        }
                                                    }
                                                    var valid0 = _errs42 === errors;
                                                }
                                                else {
                                                    var valid0 = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate23.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate23.errors = vErrors;
    return errors === 0;
}
function validate22(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            for (const key0 in data) {
                const _errs2 = errors;
                if (!validate23(data[key0], {
                    instancePath: instancePath +
                        '/' +
                        key0.replace(/~/g, '~0').replace(/\//g, '~1'),
                    parentData: data,
                    parentDataProperty: key0,
                    rootData,
                })) {
                    vErrors =
                        vErrors === null
                            ? validate23.errors
                            : vErrors.concat(validate23.errors);
                    errors = vErrors.length;
                }
                var valid0 = _errs2 === errors;
                if (!valid0) {
                    break;
                }
            }
        }
        else {
            validate22.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate22.errors = vErrors;
    return errors === 0;
}
const schema30 = {
    properties: {
        description: {
            description: 'A string describing this identity for use in user interfaces.\n\nIn user interfaces with limited space, descriptions should be hidden beyond the first newline character or `140` characters until revealed by the user.\n\nE.g.:\n- `The common stock issued by ACME, Inc.`\n- `A metadata registry maintained by Company Name, the embedded registry for Wallet Name.`\n- `Software developer and lead maintainer of Wallet Name.`',
            type: 'string',
        },
        extensions: {
            $ref: '#/definitions/Extensions',
            description: 'A mapping of `IdentitySnapshot` extension identifiers to extension definitions.  {@link  Extensions }  may be widely standardized or application-specific.\n\nStandardized extensions for `IdentitySnapshot`s include the `authchain` extension. See https://github.com/bitjson/chip-bcmr#authchain-extension for details.',
        },
        migrated: {
            description: "The timestamp at which this identity snapshot is fully in effect. This value should only be provided if the snapshot takes effect over a period of time (e.g. an in-circulation token identity is gradually migrating to a new category). In these cases, clients should gradually migrate to using the new information beginning after the identity snapshot's timestamp and the `migrated` time.\n\nThis timestamp must be provided in simplified extended ISO 8601 format, a 24-character string of format `YYYY-MM-DDTHH:mm:ss.sssZ` where timezone is zero UTC (denoted by `Z`). Note, this is the format returned by ECMAScript `Date.toISOString()`.",
            type: 'string',
        },
        name: {
            description: 'The name of this identity for use in interfaces.\n\nIn user interfaces with limited space, names should be hidden beyond the first newline character or `20` characters until revealed by the user.\n\nE.g. `ACME Class A Shares`, `ACME Registry`, `Satoshi Nakamoto`, etc.',
            type: 'string',
        },
        splitId: {
            description: "The split ID of this identity's chain of record.\n\nIf undefined, defaults to  {@link  MetadataRegistry.defaultChain } .",
            type: 'string',
        },
        status: {
            description: 'The status of this identity, must be `active`, `inactive`, or `burned`. If omitted, defaults to `active`.\n- Identities with an `active` status should be actively tracked by clients.\n- Identities with an `inactive` status may be considered for archival by clients and may be removed in future registry versions.\n- Identities with a `burned` status have been destroyed by setting the latest identity output to a data-carrier output (`OP_RETURN`), permanently terminating the authchain. Clients should archive burned identities and – if the burned identity represented a token type – consider burning any remaining tokens of that category to reclaim funds from those outputs.',
            enum: ['active', 'burned', 'inactive'],
            type: 'string',
        },
        tags: {
            description: "An array of `Tag` identifiers marking the `Tag`s associated with this identity. All specified tag identifiers must be defined in the registry's `tags` mapping.",
            items: { type: 'string' },
            type: 'array',
        },
        token: {
            $ref: '#/definitions/TokenCategory',
            description: 'If this identity is a type of token, a data structure indicating how tokens should be understood and displayed in user interfaces. Omitted for non-token identities.',
        },
        uris: {
            $ref: '#/definitions/URIs',
            description: 'A mapping of identifiers to URIs associated with this identity. URI identifiers may be widely-standardized or registry-specific. Values must be valid URIs, including a protocol prefix (e.g. `https://` or `ipfs://`). Clients are only required to support `https` and `ipfs` URIs, but any scheme may be specified.\n\nThe following identifiers are recommended for all identities:\n- `icon`\n- `web`\n\nThe following optional identifiers are standardized:\n- `blog`\n- `chat`\n- `forum`\n- `icon-intro`\n- `image`\n- `migrate`\n- `registry`\n- `support`\n\nFor details on these standard identifiers, see: https://github.com/bitjson/chip-bcmr#uri-identifiers\n\nCustom URI identifiers allow for sharing social networking profiles, p2p connection information, and other application-specific URIs. Identifiers must be lowercase, alphanumeric strings, with no whitespace or special characters other than dashes (as a regular expression: `/^[-a-z0-9]+$/`).\n\nFor example, some common identifiers include: `discord`, `docker`, `facebook`, `git`, `github`, `gitter`, `instagram`, `linkedin`, `matrix`, `npm`, `reddit`, `slack`, `substack`, `telegram`, `twitter`, `wechat`, `youtube`.',
        },
    }};
const schema34 = {
    additionalProperties: {
        properties: {
            encoding: {
                anyOf: [
                    {
                        additionalProperties: false,
                        properties: {
                            type: {
                                enum: [
                                    'binary',
                                    'boolean',
                                    'hex',
                                    'https-url',
                                    'ipfs-cid',
                                    'utf8',
                                    'locktime',
                                ],
                                type: 'string',
                            },
                        },
                        required: ['type'],
                        type: 'object',
                    },
                    {
                        additionalProperties: false,
                        properties: {
                            aggregate: {
                                const: 'add',
                                description: "The `aggregate` property indicates that aggregating this field from multiple NFTs is desirable in user interfaces. For example, for a field named `BCH Pledged` where `aggregate` is `add`, the client can display a `Total BCH Pledged` in any user interface listing more than one NFT.\n\nIf specified, clients should aggregate the field from all NFTs, of all NFT types within the category, within a particular view (e.g. NFTs held by a single wallet, NFTs existing in a single transaction's outputs, etc.) using the specified operation.\n\nNote, while aggregation could be performed using any commutative operation – multiplication, bitwise AND, bitwise OR, bitwise XOR, etc. – only `add` is currently supported.",
                                type: 'string',
                            },
                            decimals: {
                                description: 'An integer between `0` and `18` (inclusive) indicating the divisibility of the primary unit of this token field.\n\nThis is the number of digits that can appear after the decimal separator in amounts. For a field with a `decimals` of `2`, a value of `123456` should be displayed as `1234.56`.\n\nIf omitted, defaults to `0`.',
                                type: 'number',
                            },
                            type: { const: 'number', type: 'string' },
                            unit: {
                                description: "The unit in which this field is denominated, taking the `decimals` value into account. If representing fungible token amount, this will often be the symbol of the represented token category.\n\nE.g. `BCH`, `sats`, `AcmeUSD`, etc.\n\nIf not provided, clients should not represent this field as having a unit beyond the field's `name`.",
                                type: 'string',
                            },
                        },
                        required: ['type'],
                        type: 'object',
                    },
                ]}}}};
function validate30(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            for (const key0 in data) {
                let data0 = data[key0];
                const _errs2 = errors;
                if (errors === _errs2) {
                    if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
                        let missing0;
                        if (data0.encoding === undefined && (missing0 = 'encoding')) {
                            validate30.errors = [
                                {
                                    instancePath: instancePath +
                                        '/' +
                                        key0.replace(/~/g, '~0').replace(/\//g, '~1'),
                                    schemaPath: '#/additionalProperties/required',
                                    keyword: 'required',
                                    params: { missingProperty: missing0 },
                                    message: "must have required property '" + missing0 + "'",
                                },
                            ];
                            return false;
                        }
                        else {
                            const _errs4 = errors;
                            for (const key1 in data0) {
                                if (!(key1 === 'description' ||
                                    key1 === 'encoding' ||
                                    key1 === 'extensions' ||
                                    key1 === 'name' ||
                                    key1 === 'uris')) {
                                    validate30.errors = [
                                        {
                                            instancePath: instancePath +
                                                '/' +
                                                key0.replace(/~/g, '~0').replace(/\//g, '~1'),
                                            schemaPath: '#/additionalProperties/additionalProperties',
                                            keyword: 'additionalProperties',
                                            params: { additionalProperty: key1 },
                                            message: 'must NOT have additional properties',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            if (_errs4 === errors) {
                                if (data0.description !== undefined) {
                                    const _errs5 = errors;
                                    if (typeof data0.description !== 'string') {
                                        validate30.errors = [
                                            {
                                                instancePath: instancePath +
                                                    '/' +
                                                    key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                    '/description',
                                                schemaPath: '#/additionalProperties/properties/description/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            },
                                        ];
                                        return false;
                                    }
                                    var valid1 = _errs5 === errors;
                                }
                                else {
                                    var valid1 = true;
                                }
                                if (valid1) {
                                    if (data0.encoding !== undefined) {
                                        let data2 = data0.encoding;
                                        const _errs7 = errors;
                                        const _errs8 = errors;
                                        let valid2 = false;
                                        const _errs9 = errors;
                                        if (errors === _errs9) {
                                            if (data2 &&
                                                typeof data2 == 'object' &&
                                                !Array.isArray(data2)) {
                                                let missing1;
                                                if (data2.type === undefined && (missing1 = 'type')) {
                                                    const err0 = {
                                                        instancePath: instancePath +
                                                            '/' +
                                                            key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                            '/encoding',
                                                        schemaPath: '#/additionalProperties/properties/encoding/anyOf/0/required',
                                                        keyword: 'required',
                                                        params: { missingProperty: missing1 },
                                                        message: "must have required property '" + missing1 + "'",
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err0];
                                                    }
                                                    else {
                                                        vErrors.push(err0);
                                                    }
                                                    errors++;
                                                }
                                                else {
                                                    const _errs11 = errors;
                                                    for (const key2 in data2) {
                                                        if (!(key2 === 'type')) {
                                                            const err1 = {
                                                                instancePath: instancePath +
                                                                    '/' +
                                                                    key0
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/encoding',
                                                                schemaPath: '#/additionalProperties/properties/encoding/anyOf/0/additionalProperties',
                                                                keyword: 'additionalProperties',
                                                                params: { additionalProperty: key2 },
                                                                message: 'must NOT have additional properties',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err1];
                                                            }
                                                            else {
                                                                vErrors.push(err1);
                                                            }
                                                            errors++;
                                                            break;
                                                        }
                                                    }
                                                    if (_errs11 === errors) {
                                                        if (data2.type !== undefined) {
                                                            let data3 = data2.type;
                                                            if (typeof data3 !== 'string') {
                                                                const err2 = {
                                                                    instancePath: instancePath +
                                                                        '/' +
                                                                        key0
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1') +
                                                                        '/encoding/type',
                                                                    schemaPath: '#/additionalProperties/properties/encoding/anyOf/0/properties/type/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'string' },
                                                                    message: 'must be string',
                                                                };
                                                                if (vErrors === null) {
                                                                    vErrors = [err2];
                                                                }
                                                                else {
                                                                    vErrors.push(err2);
                                                                }
                                                                errors++;
                                                            }
                                                            if (!(data3 === 'binary' ||
                                                                data3 === 'boolean' ||
                                                                data3 === 'hex' ||
                                                                data3 === 'https-url' ||
                                                                data3 === 'ipfs-cid' ||
                                                                data3 === 'utf8' ||
                                                                data3 === 'locktime')) {
                                                                const err3 = {
                                                                    instancePath: instancePath +
                                                                        '/' +
                                                                        key0
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1') +
                                                                        '/encoding/type',
                                                                    schemaPath: '#/additionalProperties/properties/encoding/anyOf/0/properties/type/enum',
                                                                    keyword: 'enum',
                                                                    params: {
                                                                        allowedValues: schema34.additionalProperties.properties
                                                                            .encoding.anyOf[0].properties.type.enum,
                                                                    },
                                                                    message: 'must be equal to one of the allowed values',
                                                                };
                                                                if (vErrors === null) {
                                                                    vErrors = [err3];
                                                                }
                                                                else {
                                                                    vErrors.push(err3);
                                                                }
                                                                errors++;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                const err4 = {
                                                    instancePath: instancePath +
                                                        '/' +
                                                        key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                        '/encoding',
                                                    schemaPath: '#/additionalProperties/properties/encoding/anyOf/0/type',
                                                    keyword: 'type',
                                                    params: { type: 'object' },
                                                    message: 'must be object',
                                                };
                                                if (vErrors === null) {
                                                    vErrors = [err4];
                                                }
                                                else {
                                                    vErrors.push(err4);
                                                }
                                                errors++;
                                            }
                                        }
                                        var _valid0 = _errs9 === errors;
                                        valid2 = valid2 || _valid0;
                                        if (!valid2) {
                                            const _errs14 = errors;
                                            if (errors === _errs14) {
                                                if (data2 &&
                                                    typeof data2 == 'object' &&
                                                    !Array.isArray(data2)) {
                                                    let missing2;
                                                    if (data2.type === undefined && (missing2 = 'type')) {
                                                        const err5 = {
                                                            instancePath: instancePath +
                                                                '/' +
                                                                key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                                '/encoding',
                                                            schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/required',
                                                            keyword: 'required',
                                                            params: { missingProperty: missing2 },
                                                            message: "must have required property '" +
                                                                missing2 +
                                                                "'",
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err5];
                                                        }
                                                        else {
                                                            vErrors.push(err5);
                                                        }
                                                        errors++;
                                                    }
                                                    else {
                                                        const _errs16 = errors;
                                                        for (const key3 in data2) {
                                                            if (!(key3 === 'aggregate' ||
                                                                key3 === 'decimals' ||
                                                                key3 === 'type' ||
                                                                key3 === 'unit')) {
                                                                const err6 = {
                                                                    instancePath: instancePath +
                                                                        '/' +
                                                                        key0
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1') +
                                                                        '/encoding',
                                                                    schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/additionalProperties',
                                                                    keyword: 'additionalProperties',
                                                                    params: { additionalProperty: key3 },
                                                                    message: 'must NOT have additional properties',
                                                                };
                                                                if (vErrors === null) {
                                                                    vErrors = [err6];
                                                                }
                                                                else {
                                                                    vErrors.push(err6);
                                                                }
                                                                errors++;
                                                                break;
                                                            }
                                                        }
                                                        if (_errs16 === errors) {
                                                            if (data2.aggregate !== undefined) {
                                                                let data4 = data2.aggregate;
                                                                const _errs17 = errors;
                                                                if (typeof data4 !== 'string') {
                                                                    const err7 = {
                                                                        instancePath: instancePath +
                                                                            '/' +
                                                                            key0
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/encoding/aggregate',
                                                                        schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/properties/aggregate/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'string' },
                                                                        message: 'must be string',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err7];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err7);
                                                                    }
                                                                    errors++;
                                                                }
                                                                if ('add' !== data4) {
                                                                    const err8 = {
                                                                        instancePath: instancePath +
                                                                            '/' +
                                                                            key0
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/encoding/aggregate',
                                                                        schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/properties/aggregate/const',
                                                                        keyword: 'const',
                                                                        params: { allowedValue: 'add' },
                                                                        message: 'must be equal to constant',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err8];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err8);
                                                                    }
                                                                    errors++;
                                                                }
                                                                var valid4 = _errs17 === errors;
                                                            }
                                                            else {
                                                                var valid4 = true;
                                                            }
                                                            if (valid4) {
                                                                if (data2.decimals !== undefined) {
                                                                    let data5 = data2.decimals;
                                                                    const _errs19 = errors;
                                                                    if (!(typeof data5 == 'number' &&
                                                                        isFinite(data5))) {
                                                                        const err9 = {
                                                                            instancePath: instancePath +
                                                                                '/' +
                                                                                key0
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1') +
                                                                                '/encoding/decimals',
                                                                            schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/properties/decimals/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'number' },
                                                                            message: 'must be number',
                                                                        };
                                                                        if (vErrors === null) {
                                                                            vErrors = [err9];
                                                                        }
                                                                        else {
                                                                            vErrors.push(err9);
                                                                        }
                                                                        errors++;
                                                                    }
                                                                    var valid4 = _errs19 === errors;
                                                                }
                                                                else {
                                                                    var valid4 = true;
                                                                }
                                                                if (valid4) {
                                                                    if (data2.type !== undefined) {
                                                                        let data6 = data2.type;
                                                                        const _errs21 = errors;
                                                                        if (typeof data6 !== 'string') {
                                                                            const err10 = {
                                                                                instancePath: instancePath +
                                                                                    '/' +
                                                                                    key0
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/encoding/type',
                                                                                schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/properties/type/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err10];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err10);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        if ('number' !== data6) {
                                                                            const err11 = {
                                                                                instancePath: instancePath +
                                                                                    '/' +
                                                                                    key0
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/encoding/type',
                                                                                schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/properties/type/const',
                                                                                keyword: 'const',
                                                                                params: { allowedValue: 'number' },
                                                                                message: 'must be equal to constant',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err11];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err11);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid4 = _errs21 === errors;
                                                                    }
                                                                    else {
                                                                        var valid4 = true;
                                                                    }
                                                                    if (valid4) {
                                                                        if (data2.unit !== undefined) {
                                                                            const _errs23 = errors;
                                                                            if (typeof data2.unit !== 'string') {
                                                                                const err12 = {
                                                                                    instancePath: instancePath +
                                                                                        '/' +
                                                                                        key0
                                                                                            .replace(/~/g, '~0')
                                                                                            .replace(/\//g, '~1') +
                                                                                        '/encoding/unit',
                                                                                    schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/properties/unit/type',
                                                                                    keyword: 'type',
                                                                                    params: { type: 'string' },
                                                                                    message: 'must be string',
                                                                                };
                                                                                if (vErrors === null) {
                                                                                    vErrors = [err12];
                                                                                }
                                                                                else {
                                                                                    vErrors.push(err12);
                                                                                }
                                                                                errors++;
                                                                            }
                                                                            var valid4 = _errs23 === errors;
                                                                        }
                                                                        else {
                                                                            var valid4 = true;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else {
                                                    const err13 = {
                                                        instancePath: instancePath +
                                                            '/' +
                                                            key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                            '/encoding',
                                                        schemaPath: '#/additionalProperties/properties/encoding/anyOf/1/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err13];
                                                    }
                                                    else {
                                                        vErrors.push(err13);
                                                    }
                                                    errors++;
                                                }
                                            }
                                            var _valid0 = _errs14 === errors;
                                            valid2 = valid2 || _valid0;
                                        }
                                        if (!valid2) {
                                            const err14 = {
                                                instancePath: instancePath +
                                                    '/' +
                                                    key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                    '/encoding',
                                                schemaPath: '#/additionalProperties/properties/encoding/anyOf',
                                                keyword: 'anyOf',
                                                params: {},
                                                message: 'must match a schema in anyOf',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err14];
                                            }
                                            else {
                                                vErrors.push(err14);
                                            }
                                            errors++;
                                            validate30.errors = vErrors;
                                            return false;
                                        }
                                        else {
                                            errors = _errs8;
                                            if (vErrors !== null) {
                                                if (_errs8) {
                                                    vErrors.length = _errs8;
                                                }
                                                else {
                                                    vErrors = null;
                                                }
                                            }
                                        }
                                        var valid1 = _errs7 === errors;
                                    }
                                    else {
                                        var valid1 = true;
                                    }
                                    if (valid1) {
                                        if (data0.extensions !== undefined) {
                                            let data8 = data0.extensions;
                                            const _errs25 = errors;
                                            const _errs26 = errors;
                                            if (errors === _errs26) {
                                                if (data8 &&
                                                    typeof data8 == 'object' &&
                                                    !Array.isArray(data8)) {
                                                    for (const key4 in data8) {
                                                        let data9 = data8[key4];
                                                        const _errs29 = errors;
                                                        const _errs30 = errors;
                                                        let valid7 = false;
                                                        const _errs31 = errors;
                                                        if (typeof data9 !== 'string') {
                                                            const err15 = {
                                                                instancePath: instancePath +
                                                                    '/' +
                                                                    key0
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/extensions/' +
                                                                    key4.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err15];
                                                            }
                                                            else {
                                                                vErrors.push(err15);
                                                            }
                                                            errors++;
                                                        }
                                                        var _valid1 = _errs31 === errors;
                                                        valid7 = valid7 || _valid1;
                                                        if (!valid7) {
                                                            const _errs33 = errors;
                                                            if (errors === _errs33) {
                                                                if (data9 &&
                                                                    typeof data9 == 'object' &&
                                                                    !Array.isArray(data9)) {
                                                                    for (const key5 in data9) {
                                                                        const _errs36 = errors;
                                                                        if (typeof data9[key5] !== 'string') {
                                                                            const err16 = {
                                                                                instancePath: instancePath +
                                                                                    '/' +
                                                                                    key0
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/extensions/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key5
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err16];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err16);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid8 = _errs36 === errors;
                                                                        if (!valid8) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err17 = {
                                                                        instancePath: instancePath +
                                                                            '/' +
                                                                            key0
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/extensions/' +
                                                                            key4
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err17];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err17);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var _valid1 = _errs33 === errors;
                                                            valid7 = valid7 || _valid1;
                                                            if (!valid7) {
                                                                const _errs38 = errors;
                                                                if (errors === _errs38) {
                                                                    if (data9 &&
                                                                        typeof data9 == 'object' &&
                                                                        !Array.isArray(data9)) {
                                                                        for (const key6 in data9) {
                                                                            let data11 = data9[key6];
                                                                            const _errs41 = errors;
                                                                            if (errors === _errs41) {
                                                                                if (data11 &&
                                                                                    typeof data11 == 'object' &&
                                                                                    !Array.isArray(data11)) {
                                                                                    for (const key7 in data11) {
                                                                                        const _errs44 = errors;
                                                                                        if (typeof data11[key7] !== 'string') {
                                                                                            const err18 = {
                                                                                                instancePath: instancePath +
                                                                                                    '/' +
                                                                                                    key0
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1') +
                                                                                                    '/extensions/' +
                                                                                                    key4
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1') +
                                                                                                    '/' +
                                                                                                    key6
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1') +
                                                                                                    '/' +
                                                                                                    key7
                                                                                                        .replace(/~/g, '~0')
                                                                                                        .replace(/\//g, '~1'),
                                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'string' },
                                                                                                message: 'must be string',
                                                                                            };
                                                                                            if (vErrors === null) {
                                                                                                vErrors = [err18];
                                                                                            }
                                                                                            else {
                                                                                                vErrors.push(err18);
                                                                                            }
                                                                                            errors++;
                                                                                        }
                                                                                        var valid10 = _errs44 === errors;
                                                                                        if (!valid10) {
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                else {
                                                                                    const err19 = {
                                                                                        instancePath: instancePath +
                                                                                            '/' +
                                                                                            key0
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/extensions/' +
                                                                                            key4
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/' +
                                                                                            key6
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1'),
                                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'object' },
                                                                                        message: 'must be object',
                                                                                    };
                                                                                    if (vErrors === null) {
                                                                                        vErrors = [err19];
                                                                                    }
                                                                                    else {
                                                                                        vErrors.push(err19);
                                                                                    }
                                                                                    errors++;
                                                                                }
                                                                            }
                                                                            var valid9 = _errs41 === errors;
                                                                            if (!valid9) {
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                    else {
                                                                        const err20 = {
                                                                            instancePath: instancePath +
                                                                                '/' +
                                                                                key0
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1') +
                                                                                '/extensions/' +
                                                                                key4
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1'),
                                                                            schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'object' },
                                                                            message: 'must be object',
                                                                        };
                                                                        if (vErrors === null) {
                                                                            vErrors = [err20];
                                                                        }
                                                                        else {
                                                                            vErrors.push(err20);
                                                                        }
                                                                        errors++;
                                                                    }
                                                                }
                                                                var _valid1 = _errs38 === errors;
                                                                valid7 = valid7 || _valid1;
                                                            }
                                                        }
                                                        if (!valid7) {
                                                            const err21 = {
                                                                instancePath: instancePath +
                                                                    '/' +
                                                                    key0
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/extensions/' +
                                                                    key4.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                                keyword: 'anyOf',
                                                                params: {},
                                                                message: 'must match a schema in anyOf',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err21];
                                                            }
                                                            else {
                                                                vErrors.push(err21);
                                                            }
                                                            errors++;
                                                            validate30.errors = vErrors;
                                                            return false;
                                                        }
                                                        else {
                                                            errors = _errs30;
                                                            if (vErrors !== null) {
                                                                if (_errs30) {
                                                                    vErrors.length = _errs30;
                                                                }
                                                                else {
                                                                    vErrors = null;
                                                                }
                                                            }
                                                        }
                                                        var valid6 = _errs29 === errors;
                                                        if (!valid6) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    validate30.errors = [
                                                        {
                                                            instancePath: instancePath +
                                                                '/' +
                                                                key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                                '/extensions',
                                                            schemaPath: '#/definitions/Extensions/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                            }
                                            var valid1 = _errs25 === errors;
                                        }
                                        else {
                                            var valid1 = true;
                                        }
                                        if (valid1) {
                                            if (data0.name !== undefined) {
                                                const _errs46 = errors;
                                                if (typeof data0.name !== 'string') {
                                                    validate30.errors = [
                                                        {
                                                            instancePath: instancePath +
                                                                '/' +
                                                                key0.replace(/~/g, '~0').replace(/\//g, '~1') +
                                                                '/name',
                                                            schemaPath: '#/additionalProperties/properties/name/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                                var valid1 = _errs46 === errors;
                                            }
                                            else {
                                                var valid1 = true;
                                            }
                                            if (valid1) {
                                                if (data0.uris !== undefined) {
                                                    let data14 = data0.uris;
                                                    const _errs48 = errors;
                                                    const _errs49 = errors;
                                                    if (errors === _errs49) {
                                                        if (data14 &&
                                                            typeof data14 == 'object' &&
                                                            !Array.isArray(data14)) {
                                                            for (const key8 in data14) {
                                                                const _errs52 = errors;
                                                                if (typeof data14[key8] !== 'string') {
                                                                    validate30.errors = [
                                                                        {
                                                                            instancePath: instancePath +
                                                                                '/' +
                                                                                key0
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1') +
                                                                                '/uris/' +
                                                                                key8
                                                                                    .replace(/~/g, '~0')
                                                                                    .replace(/\//g, '~1'),
                                                                            schemaPath: '#/definitions/URIs/additionalProperties/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'string' },
                                                                            message: 'must be string',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                                var valid12 = _errs52 === errors;
                                                                if (!valid12) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        else {
                                                            validate30.errors = [
                                                                {
                                                                    instancePath: instancePath +
                                                                        '/' +
                                                                        key0
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1') +
                                                                        '/uris',
                                                                    schemaPath: '#/definitions/URIs/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'object' },
                                                                    message: 'must be object',
                                                                },
                                                            ];
                                                            return false;
                                                        }
                                                    }
                                                    var valid1 = _errs48 === errors;
                                                }
                                                else {
                                                    var valid1 = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        validate30.errors = [
                            {
                                instancePath: instancePath +
                                    '/' +
                                    key0.replace(/~/g, '~0').replace(/\//g, '~1'),
                                schemaPath: '#/additionalProperties/type',
                                keyword: 'type',
                                params: { type: 'object' },
                                message: 'must be object',
                            },
                        ];
                        return false;
                    }
                }
                var valid0 = _errs2 === errors;
                if (!valid0) {
                    break;
                }
            }
        }
        else {
            validate30.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate30.errors = vErrors;
    return errors === 0;
}
function validate33(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.name === undefined && (missing0 = 'name')) {
                validate33.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'description' ||
                        key0 === 'extensions' ||
                        key0 === 'fields' ||
                        key0 === 'name' ||
                        key0 === 'uris')) {
                        validate33.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.description !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.description !== 'string') {
                            validate33.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.extensions !== undefined) {
                            let data1 = data.extensions;
                            const _errs4 = errors;
                            const _errs5 = errors;
                            if (errors === _errs5) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        let data2 = data1[key1];
                                        const _errs8 = errors;
                                        const _errs9 = errors;
                                        let valid3 = false;
                                        const _errs10 = errors;
                                        if (typeof data2 !== 'string') {
                                            const err0 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err0];
                                            }
                                            else {
                                                vErrors.push(err0);
                                            }
                                            errors++;
                                        }
                                        var _valid0 = _errs10 === errors;
                                        valid3 = valid3 || _valid0;
                                        if (!valid3) {
                                            const _errs12 = errors;
                                            if (errors === _errs12) {
                                                if (data2 &&
                                                    typeof data2 == 'object' &&
                                                    !Array.isArray(data2)) {
                                                    for (const key2 in data2) {
                                                        const _errs15 = errors;
                                                        if (typeof data2[key2] !== 'string') {
                                                            const err1 = {
                                                                instancePath: instancePath +
                                                                    '/extensions/' +
                                                                    key1
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/' +
                                                                    key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err1];
                                                            }
                                                            else {
                                                                vErrors.push(err1);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid4 = _errs15 === errors;
                                                        if (!valid4) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    const err2 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err2];
                                                    }
                                                    else {
                                                        vErrors.push(err2);
                                                    }
                                                    errors++;
                                                }
                                            }
                                            var _valid0 = _errs12 === errors;
                                            valid3 = valid3 || _valid0;
                                            if (!valid3) {
                                                const _errs17 = errors;
                                                if (errors === _errs17) {
                                                    if (data2 &&
                                                        typeof data2 == 'object' &&
                                                        !Array.isArray(data2)) {
                                                        for (const key3 in data2) {
                                                            let data4 = data2[key3];
                                                            const _errs20 = errors;
                                                            if (errors === _errs20) {
                                                                if (data4 &&
                                                                    typeof data4 == 'object' &&
                                                                    !Array.isArray(data4)) {
                                                                    for (const key4 in data4) {
                                                                        const _errs23 = errors;
                                                                        if (typeof data4[key4] !== 'string') {
                                                                            const err3 = {
                                                                                instancePath: instancePath +
                                                                                    '/extensions/' +
                                                                                    key1
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err3];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err3);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid6 = _errs23 === errors;
                                                                        if (!valid6) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err4 = {
                                                                        instancePath: instancePath +
                                                                            '/extensions/' +
                                                                            key1
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err4];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err4);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var valid5 = _errs20 === errors;
                                                            if (!valid5) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        const err5 = {
                                                            instancePath: instancePath +
                                                                '/extensions/' +
                                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err5];
                                                        }
                                                        else {
                                                            vErrors.push(err5);
                                                        }
                                                        errors++;
                                                    }
                                                }
                                                var _valid0 = _errs17 === errors;
                                                valid3 = valid3 || _valid0;
                                            }
                                        }
                                        if (!valid3) {
                                            const err6 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                keyword: 'anyOf',
                                                params: {},
                                                message: 'must match a schema in anyOf',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err6];
                                            }
                                            else {
                                                vErrors.push(err6);
                                            }
                                            errors++;
                                            validate33.errors = vErrors;
                                            return false;
                                        }
                                        else {
                                            errors = _errs9;
                                            if (vErrors !== null) {
                                                if (_errs9) {
                                                    vErrors.length = _errs9;
                                                }
                                                else {
                                                    vErrors = null;
                                                }
                                            }
                                        }
                                        var valid2 = _errs8 === errors;
                                        if (!valid2) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate33.errors = [
                                        {
                                            instancePath: instancePath + '/extensions',
                                            schemaPath: '#/definitions/Extensions/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.fields !== undefined) {
                                let data6 = data.fields;
                                const _errs25 = errors;
                                if (errors === _errs25) {
                                    if (Array.isArray(data6)) {
                                        var valid7 = true;
                                        const len0 = data6.length;
                                        for (let i0 = 0; i0 < len0; i0++) {
                                            const _errs27 = errors;
                                            if (typeof data6[i0] !== 'string') {
                                                validate33.errors = [
                                                    {
                                                        instancePath: instancePath + '/fields/' + i0,
                                                        schemaPath: '#/properties/fields/items/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    },
                                                ];
                                                return false;
                                            }
                                            var valid7 = _errs27 === errors;
                                            if (!valid7) {
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        validate33.errors = [
                                            {
                                                instancePath: instancePath + '/fields',
                                                schemaPath: '#/properties/fields/type',
                                                keyword: 'type',
                                                params: { type: 'array' },
                                                message: 'must be array',
                                            },
                                        ];
                                        return false;
                                    }
                                }
                                var valid0 = _errs25 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.name !== undefined) {
                                    const _errs29 = errors;
                                    if (typeof data.name !== 'string') {
                                        validate33.errors = [
                                            {
                                                instancePath: instancePath + '/name',
                                                schemaPath: '#/properties/name/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            },
                                        ];
                                        return false;
                                    }
                                    var valid0 = _errs29 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.uris !== undefined) {
                                        let data9 = data.uris;
                                        const _errs31 = errors;
                                        const _errs32 = errors;
                                        if (errors === _errs32) {
                                            if (data9 &&
                                                typeof data9 == 'object' &&
                                                !Array.isArray(data9)) {
                                                for (const key5 in data9) {
                                                    const _errs35 = errors;
                                                    if (typeof data9[key5] !== 'string') {
                                                        validate33.errors = [
                                                            {
                                                                instancePath: instancePath +
                                                                    '/uris/' +
                                                                    key5.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/URIs/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                    var valid9 = _errs35 === errors;
                                                    if (!valid9) {
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                validate33.errors = [
                                                    {
                                                        instancePath: instancePath + '/uris',
                                                        schemaPath: '#/definitions/URIs/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    },
                                                ];
                                                return false;
                                            }
                                        }
                                        var valid0 = _errs31 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate33.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate33.errors = vErrors;
    return errors === 0;
}
function validate32(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if ((data.bytecode === undefined && (missing0 = 'bytecode')) ||
                (data.types === undefined && (missing0 = 'types'))) {
                validate32.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'bytecode' || key0 === 'types')) {
                        validate32.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.bytecode !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.bytecode !== 'string') {
                            validate32.errors = [
                                {
                                    instancePath: instancePath + '/bytecode',
                                    schemaPath: '#/properties/bytecode/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.types !== undefined) {
                            let data1 = data.types;
                            const _errs4 = errors;
                            if (errors === _errs4) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        const _errs7 = errors;
                                        if (!validate33(data1[key1], {
                                            instancePath: instancePath +
                                                '/types/' +
                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                            parentData: data1,
                                            parentDataProperty: key1,
                                            rootData,
                                        })) {
                                            vErrors =
                                                vErrors === null
                                                    ? validate33.errors
                                                    : vErrors.concat(validate33.errors);
                                            errors = vErrors.length;
                                        }
                                        var valid1 = _errs7 === errors;
                                        if (!valid1) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate32.errors = [
                                        {
                                            instancePath: instancePath + '/types',
                                            schemaPath: '#/properties/types/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                    }
                }
            }
        }
        else {
            validate32.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate32.errors = vErrors;
    return errors === 0;
}
function validate36(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.types === undefined && (missing0 = 'types')) {
                validate36.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'types')) {
                        validate36.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.types !== undefined) {
                        let data0 = data.types;
                        const _errs2 = errors;
                        if (errors === _errs2) {
                            if (data0 && typeof data0 == 'object' && !Array.isArray(data0)) {
                                for (const key1 in data0) {
                                    const _errs5 = errors;
                                    if (!validate33(data0[key1], {
                                        instancePath: instancePath +
                                            '/types/' +
                                            key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                        parentData: data0,
                                        parentDataProperty: key1,
                                        rootData,
                                    })) {
                                        vErrors =
                                            vErrors === null
                                                ? validate33.errors
                                                : vErrors.concat(validate33.errors);
                                        errors = vErrors.length;
                                    }
                                    var valid1 = _errs5 === errors;
                                    if (!valid1) {
                                        break;
                                    }
                                }
                            }
                            else {
                                validate36.errors = [
                                    {
                                        instancePath: instancePath + '/types',
                                        schemaPath: '#/properties/types/type',
                                        keyword: 'type',
                                        params: { type: 'object' },
                                        message: 'must be object',
                                    },
                                ];
                                return false;
                            }
                        }
                    }
                }
            }
        }
        else {
            validate36.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate36.errors = vErrors;
    return errors === 0;
}
function validate29(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.parse === undefined && (missing0 = 'parse')) {
                validate29.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'description' || key0 === 'fields' || key0 === 'parse')) {
                        validate29.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.description !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.description !== 'string') {
                            validate29.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.fields !== undefined) {
                            const _errs4 = errors;
                            if (!validate30(data.fields, {
                                instancePath: instancePath + '/fields',
                                parentData: data,
                                parentDataProperty: 'fields',
                                rootData,
                            })) {
                                vErrors =
                                    vErrors === null
                                        ? validate30.errors
                                        : vErrors.concat(validate30.errors);
                                errors = vErrors.length;
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.parse !== undefined) {
                                let data2 = data.parse;
                                const _errs5 = errors;
                                const _errs6 = errors;
                                let valid1 = false;
                                const _errs7 = errors;
                                if (!validate32(data2, {
                                    instancePath: instancePath + '/parse',
                                    parentData: data,
                                    parentDataProperty: 'parse',
                                    rootData,
                                })) {
                                    vErrors =
                                        vErrors === null
                                            ? validate32.errors
                                            : vErrors.concat(validate32.errors);
                                    errors = vErrors.length;
                                }
                                var _valid0 = _errs7 === errors;
                                valid1 = valid1 || _valid0;
                                if (!valid1) {
                                    const _errs8 = errors;
                                    if (!validate36(data2, {
                                        instancePath: instancePath + '/parse',
                                        parentData: data,
                                        parentDataProperty: 'parse',
                                        rootData,
                                    })) {
                                        vErrors =
                                            vErrors === null
                                                ? validate36.errors
                                                : vErrors.concat(validate36.errors);
                                        errors = vErrors.length;
                                    }
                                    var _valid0 = _errs8 === errors;
                                    valid1 = valid1 || _valid0;
                                }
                                if (!valid1) {
                                    const err0 = {
                                        instancePath: instancePath + '/parse',
                                        schemaPath: '#/properties/parse/anyOf',
                                        keyword: 'anyOf',
                                        params: {},
                                        message: 'must match a schema in anyOf',
                                    };
                                    if (vErrors === null) {
                                        vErrors = [err0];
                                    }
                                    else {
                                        vErrors.push(err0);
                                    }
                                    errors++;
                                    validate29.errors = vErrors;
                                    return false;
                                }
                                else {
                                    errors = _errs6;
                                    if (vErrors !== null) {
                                        if (_errs6) {
                                            vErrors.length = _errs6;
                                        }
                                        else {
                                            vErrors = null;
                                        }
                                    }
                                }
                                var valid0 = _errs5 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                        }
                    }
                }
            }
        }
        else {
            validate29.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate29.errors = vErrors;
    return errors === 0;
}
function validate28(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if ((data.category === undefined && (missing0 = 'category')) ||
                (data.symbol === undefined && (missing0 = 'symbol'))) {
                validate28.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'category' ||
                        key0 === 'decimals' ||
                        key0 === 'nfts' ||
                        key0 === 'symbol')) {
                        validate28.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.category !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.category !== 'string') {
                            validate28.errors = [
                                {
                                    instancePath: instancePath + '/category',
                                    schemaPath: '#/properties/category/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.decimals !== undefined) {
                            let data1 = data.decimals;
                            const _errs4 = errors;
                            if (!(typeof data1 == 'number' && isFinite(data1))) {
                                validate28.errors = [
                                    {
                                        instancePath: instancePath + '/decimals',
                                        schemaPath: '#/properties/decimals/type',
                                        keyword: 'type',
                                        params: { type: 'number' },
                                        message: 'must be number',
                                    },
                                ];
                                return false;
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.nfts !== undefined) {
                                const _errs6 = errors;
                                if (!validate29(data.nfts, {
                                    instancePath: instancePath + '/nfts',
                                    parentData: data,
                                    parentDataProperty: 'nfts',
                                    rootData,
                                })) {
                                    vErrors =
                                        vErrors === null
                                            ? validate29.errors
                                            : vErrors.concat(validate29.errors);
                                    errors = vErrors.length;
                                }
                                var valid0 = _errs6 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.symbol !== undefined) {
                                    const _errs7 = errors;
                                    if (typeof data.symbol !== 'string') {
                                        validate28.errors = [
                                            {
                                                instancePath: instancePath + '/symbol',
                                                schemaPath: '#/properties/symbol/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            },
                                        ];
                                        return false;
                                    }
                                    var valid0 = _errs7 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate28.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate28.errors = vErrors;
    return errors === 0;
}
function validate27(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.name === undefined && (missing0 = 'name')) {
                validate27.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!func4.call(schema30.properties, key0)) {
                        validate27.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.description !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.description !== 'string') {
                            validate27.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.extensions !== undefined) {
                            let data1 = data.extensions;
                            const _errs4 = errors;
                            const _errs5 = errors;
                            if (errors === _errs5) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        let data2 = data1[key1];
                                        const _errs8 = errors;
                                        const _errs9 = errors;
                                        let valid3 = false;
                                        const _errs10 = errors;
                                        if (typeof data2 !== 'string') {
                                            const err0 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err0];
                                            }
                                            else {
                                                vErrors.push(err0);
                                            }
                                            errors++;
                                        }
                                        var _valid0 = _errs10 === errors;
                                        valid3 = valid3 || _valid0;
                                        if (!valid3) {
                                            const _errs12 = errors;
                                            if (errors === _errs12) {
                                                if (data2 &&
                                                    typeof data2 == 'object' &&
                                                    !Array.isArray(data2)) {
                                                    for (const key2 in data2) {
                                                        const _errs15 = errors;
                                                        if (typeof data2[key2] !== 'string') {
                                                            const err1 = {
                                                                instancePath: instancePath +
                                                                    '/extensions/' +
                                                                    key1
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/' +
                                                                    key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err1];
                                                            }
                                                            else {
                                                                vErrors.push(err1);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid4 = _errs15 === errors;
                                                        if (!valid4) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    const err2 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err2];
                                                    }
                                                    else {
                                                        vErrors.push(err2);
                                                    }
                                                    errors++;
                                                }
                                            }
                                            var _valid0 = _errs12 === errors;
                                            valid3 = valid3 || _valid0;
                                            if (!valid3) {
                                                const _errs17 = errors;
                                                if (errors === _errs17) {
                                                    if (data2 &&
                                                        typeof data2 == 'object' &&
                                                        !Array.isArray(data2)) {
                                                        for (const key3 in data2) {
                                                            let data4 = data2[key3];
                                                            const _errs20 = errors;
                                                            if (errors === _errs20) {
                                                                if (data4 &&
                                                                    typeof data4 == 'object' &&
                                                                    !Array.isArray(data4)) {
                                                                    for (const key4 in data4) {
                                                                        const _errs23 = errors;
                                                                        if (typeof data4[key4] !== 'string') {
                                                                            const err3 = {
                                                                                instancePath: instancePath +
                                                                                    '/extensions/' +
                                                                                    key1
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err3];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err3);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid6 = _errs23 === errors;
                                                                        if (!valid6) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err4 = {
                                                                        instancePath: instancePath +
                                                                            '/extensions/' +
                                                                            key1
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err4];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err4);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var valid5 = _errs20 === errors;
                                                            if (!valid5) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        const err5 = {
                                                            instancePath: instancePath +
                                                                '/extensions/' +
                                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err5];
                                                        }
                                                        else {
                                                            vErrors.push(err5);
                                                        }
                                                        errors++;
                                                    }
                                                }
                                                var _valid0 = _errs17 === errors;
                                                valid3 = valid3 || _valid0;
                                            }
                                        }
                                        if (!valid3) {
                                            const err6 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                keyword: 'anyOf',
                                                params: {},
                                                message: 'must match a schema in anyOf',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err6];
                                            }
                                            else {
                                                vErrors.push(err6);
                                            }
                                            errors++;
                                            validate27.errors = vErrors;
                                            return false;
                                        }
                                        else {
                                            errors = _errs9;
                                            if (vErrors !== null) {
                                                if (_errs9) {
                                                    vErrors.length = _errs9;
                                                }
                                                else {
                                                    vErrors = null;
                                                }
                                            }
                                        }
                                        var valid2 = _errs8 === errors;
                                        if (!valid2) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate27.errors = [
                                        {
                                            instancePath: instancePath + '/extensions',
                                            schemaPath: '#/definitions/Extensions/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.migrated !== undefined) {
                                const _errs25 = errors;
                                if (typeof data.migrated !== 'string') {
                                    validate27.errors = [
                                        {
                                            instancePath: instancePath + '/migrated',
                                            schemaPath: '#/properties/migrated/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs25 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.name !== undefined) {
                                    const _errs27 = errors;
                                    if (typeof data.name !== 'string') {
                                        validate27.errors = [
                                            {
                                                instancePath: instancePath + '/name',
                                                schemaPath: '#/properties/name/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            },
                                        ];
                                        return false;
                                    }
                                    var valid0 = _errs27 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.splitId !== undefined) {
                                        const _errs29 = errors;
                                        if (typeof data.splitId !== 'string') {
                                            validate27.errors = [
                                                {
                                                    instancePath: instancePath + '/splitId',
                                                    schemaPath: '#/properties/splitId/type',
                                                    keyword: 'type',
                                                    params: { type: 'string' },
                                                    message: 'must be string',
                                                },
                                            ];
                                            return false;
                                        }
                                        var valid0 = _errs29 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                    if (valid0) {
                                        if (data.status !== undefined) {
                                            let data9 = data.status;
                                            const _errs31 = errors;
                                            if (typeof data9 !== 'string') {
                                                validate27.errors = [
                                                    {
                                                        instancePath: instancePath + '/status',
                                                        schemaPath: '#/properties/status/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    },
                                                ];
                                                return false;
                                            }
                                            if (!(data9 === 'active' ||
                                                data9 === 'burned' ||
                                                data9 === 'inactive')) {
                                                validate27.errors = [
                                                    {
                                                        instancePath: instancePath + '/status',
                                                        schemaPath: '#/properties/status/enum',
                                                        keyword: 'enum',
                                                        params: {
                                                            allowedValues: schema30.properties.status.enum,
                                                        },
                                                        message: 'must be equal to one of the allowed values',
                                                    },
                                                ];
                                                return false;
                                            }
                                            var valid0 = _errs31 === errors;
                                        }
                                        else {
                                            var valid0 = true;
                                        }
                                        if (valid0) {
                                            if (data.tags !== undefined) {
                                                let data10 = data.tags;
                                                const _errs33 = errors;
                                                if (errors === _errs33) {
                                                    if (Array.isArray(data10)) {
                                                        var valid7 = true;
                                                        const len0 = data10.length;
                                                        for (let i0 = 0; i0 < len0; i0++) {
                                                            const _errs35 = errors;
                                                            if (typeof data10[i0] !== 'string') {
                                                                validate27.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/tags/' + i0,
                                                                        schemaPath: '#/properties/tags/items/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'string' },
                                                                        message: 'must be string',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                            var valid7 = _errs35 === errors;
                                                            if (!valid7) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        validate27.errors = [
                                                            {
                                                                instancePath: instancePath + '/tags',
                                                                schemaPath: '#/properties/tags/type',
                                                                keyword: 'type',
                                                                params: { type: 'array' },
                                                                message: 'must be array',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                }
                                                var valid0 = _errs33 === errors;
                                            }
                                            else {
                                                var valid0 = true;
                                            }
                                            if (valid0) {
                                                if (data.token !== undefined) {
                                                    const _errs37 = errors;
                                                    if (!validate28(data.token, {
                                                        instancePath: instancePath + '/token',
                                                        parentData: data,
                                                        parentDataProperty: 'token',
                                                        rootData,
                                                    })) {
                                                        vErrors =
                                                            vErrors === null
                                                                ? validate28.errors
                                                                : vErrors.concat(validate28.errors);
                                                        errors = vErrors.length;
                                                    }
                                                    var valid0 = _errs37 === errors;
                                                }
                                                else {
                                                    var valid0 = true;
                                                }
                                                if (valid0) {
                                                    if (data.uris !== undefined) {
                                                        let data13 = data.uris;
                                                        const _errs38 = errors;
                                                        const _errs39 = errors;
                                                        if (errors === _errs39) {
                                                            if (data13 &&
                                                                typeof data13 == 'object' &&
                                                                !Array.isArray(data13)) {
                                                                for (const key5 in data13) {
                                                                    const _errs42 = errors;
                                                                    if (typeof data13[key5] !== 'string') {
                                                                        validate27.errors = [
                                                                            {
                                                                                instancePath: instancePath +
                                                                                    '/uris/' +
                                                                                    key5
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/URIs/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    var valid9 = _errs42 === errors;
                                                                    if (!valid9) {
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                validate27.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/uris',
                                                                        schemaPath: '#/definitions/URIs/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                        }
                                                        var valid0 = _errs38 === errors;
                                                    }
                                                    else {
                                                        var valid0 = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate27.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate27.errors = vErrors;
    return errors === 0;
}
function validate26(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            for (const key0 in data) {
                const _errs2 = errors;
                if (!validate27(data[key0], {
                    instancePath: instancePath +
                        '/' +
                        key0.replace(/~/g, '~0').replace(/\//g, '~1'),
                    parentData: data,
                    parentDataProperty: key0,
                    rootData,
                })) {
                    vErrors =
                        vErrors === null
                            ? validate27.errors
                            : vErrors.concat(validate27.errors);
                    errors = vErrors.length;
                }
                var valid0 = _errs2 === errors;
                if (!valid0) {
                    break;
                }
            }
        }
        else {
            validate26.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate26.errors = vErrors;
    return errors === 0;
}
function validate43(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.name === undefined && (missing0 = 'name')) {
                validate43.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'description' ||
                        key0 === 'extensions' ||
                        key0 === 'name' ||
                        key0 === 'tags' ||
                        key0 === 'uris')) {
                        validate43.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.description !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.description !== 'string') {
                            validate43.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.extensions !== undefined) {
                            let data1 = data.extensions;
                            const _errs4 = errors;
                            const _errs5 = errors;
                            if (errors === _errs5) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        let data2 = data1[key1];
                                        const _errs8 = errors;
                                        const _errs9 = errors;
                                        let valid3 = false;
                                        const _errs10 = errors;
                                        if (typeof data2 !== 'string') {
                                            const err0 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err0];
                                            }
                                            else {
                                                vErrors.push(err0);
                                            }
                                            errors++;
                                        }
                                        var _valid0 = _errs10 === errors;
                                        valid3 = valid3 || _valid0;
                                        if (!valid3) {
                                            const _errs12 = errors;
                                            if (errors === _errs12) {
                                                if (data2 &&
                                                    typeof data2 == 'object' &&
                                                    !Array.isArray(data2)) {
                                                    for (const key2 in data2) {
                                                        const _errs15 = errors;
                                                        if (typeof data2[key2] !== 'string') {
                                                            const err1 = {
                                                                instancePath: instancePath +
                                                                    '/extensions/' +
                                                                    key1
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/' +
                                                                    key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err1];
                                                            }
                                                            else {
                                                                vErrors.push(err1);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid4 = _errs15 === errors;
                                                        if (!valid4) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    const err2 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err2];
                                                    }
                                                    else {
                                                        vErrors.push(err2);
                                                    }
                                                    errors++;
                                                }
                                            }
                                            var _valid0 = _errs12 === errors;
                                            valid3 = valid3 || _valid0;
                                            if (!valid3) {
                                                const _errs17 = errors;
                                                if (errors === _errs17) {
                                                    if (data2 &&
                                                        typeof data2 == 'object' &&
                                                        !Array.isArray(data2)) {
                                                        for (const key3 in data2) {
                                                            let data4 = data2[key3];
                                                            const _errs20 = errors;
                                                            if (errors === _errs20) {
                                                                if (data4 &&
                                                                    typeof data4 == 'object' &&
                                                                    !Array.isArray(data4)) {
                                                                    for (const key4 in data4) {
                                                                        const _errs23 = errors;
                                                                        if (typeof data4[key4] !== 'string') {
                                                                            const err3 = {
                                                                                instancePath: instancePath +
                                                                                    '/extensions/' +
                                                                                    key1
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err3];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err3);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid6 = _errs23 === errors;
                                                                        if (!valid6) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err4 = {
                                                                        instancePath: instancePath +
                                                                            '/extensions/' +
                                                                            key1
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err4];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err4);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var valid5 = _errs20 === errors;
                                                            if (!valid5) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        const err5 = {
                                                            instancePath: instancePath +
                                                                '/extensions/' +
                                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err5];
                                                        }
                                                        else {
                                                            vErrors.push(err5);
                                                        }
                                                        errors++;
                                                    }
                                                }
                                                var _valid0 = _errs17 === errors;
                                                valid3 = valid3 || _valid0;
                                            }
                                        }
                                        if (!valid3) {
                                            const err6 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                keyword: 'anyOf',
                                                params: {},
                                                message: 'must match a schema in anyOf',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err6];
                                            }
                                            else {
                                                vErrors.push(err6);
                                            }
                                            errors++;
                                            validate43.errors = vErrors;
                                            return false;
                                        }
                                        else {
                                            errors = _errs9;
                                            if (vErrors !== null) {
                                                if (_errs9) {
                                                    vErrors.length = _errs9;
                                                }
                                                else {
                                                    vErrors = null;
                                                }
                                            }
                                        }
                                        var valid2 = _errs8 === errors;
                                        if (!valid2) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate43.errors = [
                                        {
                                            instancePath: instancePath + '/extensions',
                                            schemaPath: '#/definitions/Extensions/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.name !== undefined) {
                                const _errs25 = errors;
                                if (typeof data.name !== 'string') {
                                    validate43.errors = [
                                        {
                                            instancePath: instancePath + '/name',
                                            schemaPath: '#/properties/name/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs25 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.tags !== undefined) {
                                    let data7 = data.tags;
                                    const _errs27 = errors;
                                    if (errors === _errs27) {
                                        if (Array.isArray(data7)) {
                                            var valid7 = true;
                                            const len0 = data7.length;
                                            for (let i0 = 0; i0 < len0; i0++) {
                                                const _errs29 = errors;
                                                if (typeof data7[i0] !== 'string') {
                                                    validate43.errors = [
                                                        {
                                                            instancePath: instancePath + '/tags/' + i0,
                                                            schemaPath: '#/properties/tags/items/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                                var valid7 = _errs29 === errors;
                                                if (!valid7) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            validate43.errors = [
                                                {
                                                    instancePath: instancePath + '/tags',
                                                    schemaPath: '#/properties/tags/type',
                                                    keyword: 'type',
                                                    params: { type: 'array' },
                                                    message: 'must be array',
                                                },
                                            ];
                                            return false;
                                        }
                                    }
                                    var valid0 = _errs27 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.uris !== undefined) {
                                        let data9 = data.uris;
                                        const _errs31 = errors;
                                        const _errs32 = errors;
                                        if (errors === _errs32) {
                                            if (data9 &&
                                                typeof data9 == 'object' &&
                                                !Array.isArray(data9)) {
                                                for (const key5 in data9) {
                                                    const _errs35 = errors;
                                                    if (typeof data9[key5] !== 'string') {
                                                        validate43.errors = [
                                                            {
                                                                instancePath: instancePath +
                                                                    '/uris/' +
                                                                    key5.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/URIs/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            },
                                                        ];
                                                        return false;
                                                    }
                                                    var valid9 = _errs35 === errors;
                                                    if (!valid9) {
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                validate43.errors = [
                                                    {
                                                        instancePath: instancePath + '/uris',
                                                        schemaPath: '#/definitions/URIs/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    },
                                                ];
                                                return false;
                                            }
                                        }
                                        var valid0 = _errs31 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate43.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate43.errors = vErrors;
    return errors === 0;
}
function validate45(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if (data.name === undefined && (missing0 = 'name')) {
                validate45.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!(key0 === 'description' ||
                        key0 === 'extensions' ||
                        key0 === 'name' ||
                        key0 === 'uris')) {
                        validate45.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.description !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.description !== 'string') {
                            validate45.errors = [
                                {
                                    instancePath: instancePath + '/description',
                                    schemaPath: '#/properties/description/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.extensions !== undefined) {
                            let data1 = data.extensions;
                            const _errs4 = errors;
                            const _errs5 = errors;
                            if (errors === _errs5) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        let data2 = data1[key1];
                                        const _errs8 = errors;
                                        const _errs9 = errors;
                                        let valid3 = false;
                                        const _errs10 = errors;
                                        if (typeof data2 !== 'string') {
                                            const err0 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                keyword: 'type',
                                                params: { type: 'string' },
                                                message: 'must be string',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err0];
                                            }
                                            else {
                                                vErrors.push(err0);
                                            }
                                            errors++;
                                        }
                                        var _valid0 = _errs10 === errors;
                                        valid3 = valid3 || _valid0;
                                        if (!valid3) {
                                            const _errs12 = errors;
                                            if (errors === _errs12) {
                                                if (data2 &&
                                                    typeof data2 == 'object' &&
                                                    !Array.isArray(data2)) {
                                                    for (const key2 in data2) {
                                                        const _errs15 = errors;
                                                        if (typeof data2[key2] !== 'string') {
                                                            const err1 = {
                                                                instancePath: instancePath +
                                                                    '/extensions/' +
                                                                    key1
                                                                        .replace(/~/g, '~0')
                                                                        .replace(/\//g, '~1') +
                                                                    '/' +
                                                                    key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err1];
                                                            }
                                                            else {
                                                                vErrors.push(err1);
                                                            }
                                                            errors++;
                                                        }
                                                        var valid4 = _errs15 === errors;
                                                        if (!valid4) {
                                                            break;
                                                        }
                                                    }
                                                }
                                                else {
                                                    const err2 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err2];
                                                    }
                                                    else {
                                                        vErrors.push(err2);
                                                    }
                                                    errors++;
                                                }
                                            }
                                            var _valid0 = _errs12 === errors;
                                            valid3 = valid3 || _valid0;
                                            if (!valid3) {
                                                const _errs17 = errors;
                                                if (errors === _errs17) {
                                                    if (data2 &&
                                                        typeof data2 == 'object' &&
                                                        !Array.isArray(data2)) {
                                                        for (const key3 in data2) {
                                                            let data4 = data2[key3];
                                                            const _errs20 = errors;
                                                            if (errors === _errs20) {
                                                                if (data4 &&
                                                                    typeof data4 == 'object' &&
                                                                    !Array.isArray(data4)) {
                                                                    for (const key4 in data4) {
                                                                        const _errs23 = errors;
                                                                        if (typeof data4[key4] !== 'string') {
                                                                            const err3 = {
                                                                                instancePath: instancePath +
                                                                                    '/extensions/' +
                                                                                    key1
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key3
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'string' },
                                                                                message: 'must be string',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err3];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err3);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                        var valid6 = _errs23 === errors;
                                                                        if (!valid6) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    const err4 = {
                                                                        instancePath: instancePath +
                                                                            '/extensions/' +
                                                                            key1
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err4];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err4);
                                                                    }
                                                                    errors++;
                                                                }
                                                            }
                                                            var valid5 = _errs20 === errors;
                                                            if (!valid5) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        const err5 = {
                                                            instancePath: instancePath +
                                                                '/extensions/' +
                                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                            keyword: 'type',
                                                            params: { type: 'object' },
                                                            message: 'must be object',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err5];
                                                        }
                                                        else {
                                                            vErrors.push(err5);
                                                        }
                                                        errors++;
                                                    }
                                                }
                                                var _valid0 = _errs17 === errors;
                                                valid3 = valid3 || _valid0;
                                            }
                                        }
                                        if (!valid3) {
                                            const err6 = {
                                                instancePath: instancePath +
                                                    '/extensions/' +
                                                    key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                keyword: 'anyOf',
                                                params: {},
                                                message: 'must match a schema in anyOf',
                                            };
                                            if (vErrors === null) {
                                                vErrors = [err6];
                                            }
                                            else {
                                                vErrors.push(err6);
                                            }
                                            errors++;
                                            validate45.errors = vErrors;
                                            return false;
                                        }
                                        else {
                                            errors = _errs9;
                                            if (vErrors !== null) {
                                                if (_errs9) {
                                                    vErrors.length = _errs9;
                                                }
                                                else {
                                                    vErrors = null;
                                                }
                                            }
                                        }
                                        var valid2 = _errs8 === errors;
                                        if (!valid2) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate45.errors = [
                                        {
                                            instancePath: instancePath + '/extensions',
                                            schemaPath: '#/definitions/Extensions/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.name !== undefined) {
                                const _errs25 = errors;
                                if (typeof data.name !== 'string') {
                                    validate45.errors = [
                                        {
                                            instancePath: instancePath + '/name',
                                            schemaPath: '#/properties/name/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs25 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.uris !== undefined) {
                                    let data7 = data.uris;
                                    const _errs27 = errors;
                                    const _errs28 = errors;
                                    if (errors === _errs28) {
                                        if (data7 &&
                                            typeof data7 == 'object' &&
                                            !Array.isArray(data7)) {
                                            for (const key5 in data7) {
                                                const _errs31 = errors;
                                                if (typeof data7[key5] !== 'string') {
                                                    validate45.errors = [
                                                        {
                                                            instancePath: instancePath +
                                                                '/uris/' +
                                                                key5.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                            schemaPath: '#/definitions/URIs/additionalProperties/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                                var valid8 = _errs31 === errors;
                                                if (!valid8) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            validate45.errors = [
                                                {
                                                    instancePath: instancePath + '/uris',
                                                    schemaPath: '#/definitions/URIs/type',
                                                    keyword: 'type',
                                                    params: { type: 'object' },
                                                    message: 'must be object',
                                                },
                                            ];
                                            return false;
                                        }
                                    }
                                    var valid0 = _errs27 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate45.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate45.errors = vErrors;
    return errors === 0;
}
function validate21(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
        if (data && typeof data == 'object' && !Array.isArray(data)) {
            let missing0;
            if ((data.version === undefined && (missing0 = 'version')) ||
                (data.latestRevision === undefined && (missing0 = 'latestRevision')) ||
                (data.registryIdentity === undefined && (missing0 = 'registryIdentity'))) {
                validate21.errors = [
                    {
                        instancePath,
                        schemaPath: '#/required',
                        keyword: 'required',
                        params: { missingProperty: missing0 },
                        message: "must have required property '" + missing0 + "'",
                    },
                ];
                return false;
            }
            else {
                const _errs1 = errors;
                for (const key0 in data) {
                    if (!func4.call(schema23.properties, key0)) {
                        validate21.errors = [
                            {
                                instancePath,
                                schemaPath: '#/additionalProperties',
                                keyword: 'additionalProperties',
                                params: { additionalProperty: key0 },
                                message: 'must NOT have additional properties',
                            },
                        ];
                        return false;
                    }
                }
                if (_errs1 === errors) {
                    if (data.$schema !== undefined) {
                        const _errs2 = errors;
                        if (typeof data.$schema !== 'string') {
                            validate21.errors = [
                                {
                                    instancePath: instancePath + '/$schema',
                                    schemaPath: '#/properties/%24schema/type',
                                    keyword: 'type',
                                    params: { type: 'string' },
                                    message: 'must be string',
                                },
                            ];
                            return false;
                        }
                        var valid0 = _errs2 === errors;
                    }
                    else {
                        var valid0 = true;
                    }
                    if (valid0) {
                        if (data.chains !== undefined) {
                            let data1 = data.chains;
                            const _errs4 = errors;
                            if (errors === _errs4) {
                                if (data1 &&
                                    typeof data1 == 'object' &&
                                    !Array.isArray(data1)) {
                                    for (const key1 in data1) {
                                        const _errs7 = errors;
                                        if (!validate22(data1[key1], {
                                            instancePath: instancePath +
                                                '/chains/' +
                                                key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                            parentData: data1,
                                            parentDataProperty: key1,
                                            rootData,
                                        })) {
                                            vErrors =
                                                vErrors === null
                                                    ? validate22.errors
                                                    : vErrors.concat(validate22.errors);
                                            errors = vErrors.length;
                                        }
                                        var valid1 = _errs7 === errors;
                                        if (!valid1) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    validate21.errors = [
                                        {
                                            instancePath: instancePath + '/chains',
                                            schemaPath: '#/properties/chains/type',
                                            keyword: 'type',
                                            params: { type: 'object' },
                                            message: 'must be object',
                                        },
                                    ];
                                    return false;
                                }
                            }
                            var valid0 = _errs4 === errors;
                        }
                        else {
                            var valid0 = true;
                        }
                        if (valid0) {
                            if (data.defaultChain !== undefined) {
                                const _errs8 = errors;
                                if (typeof data.defaultChain !== 'string') {
                                    validate21.errors = [
                                        {
                                            instancePath: instancePath + '/defaultChain',
                                            schemaPath: '#/properties/defaultChain/type',
                                            keyword: 'type',
                                            params: { type: 'string' },
                                            message: 'must be string',
                                        },
                                    ];
                                    return false;
                                }
                                var valid0 = _errs8 === errors;
                            }
                            else {
                                var valid0 = true;
                            }
                            if (valid0) {
                                if (data.extensions !== undefined) {
                                    let data4 = data.extensions;
                                    const _errs10 = errors;
                                    const _errs11 = errors;
                                    if (errors === _errs11) {
                                        if (data4 &&
                                            typeof data4 == 'object' &&
                                            !Array.isArray(data4)) {
                                            for (const key2 in data4) {
                                                let data5 = data4[key2];
                                                const _errs14 = errors;
                                                const _errs15 = errors;
                                                let valid4 = false;
                                                const _errs16 = errors;
                                                if (typeof data5 !== 'string') {
                                                    const err0 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/0/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err0];
                                                    }
                                                    else {
                                                        vErrors.push(err0);
                                                    }
                                                    errors++;
                                                }
                                                var _valid0 = _errs16 === errors;
                                                valid4 = valid4 || _valid0;
                                                if (!valid4) {
                                                    const _errs18 = errors;
                                                    if (errors === _errs18) {
                                                        if (data5 &&
                                                            typeof data5 == 'object' &&
                                                            !Array.isArray(data5)) {
                                                            for (const key3 in data5) {
                                                                const _errs21 = errors;
                                                                if (typeof data5[key3] !== 'string') {
                                                                    const err1 = {
                                                                        instancePath: instancePath +
                                                                            '/extensions/' +
                                                                            key2
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1') +
                                                                            '/' +
                                                                            key3
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/additionalProperties/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'string' },
                                                                        message: 'must be string',
                                                                    };
                                                                    if (vErrors === null) {
                                                                        vErrors = [err1];
                                                                    }
                                                                    else {
                                                                        vErrors.push(err1);
                                                                    }
                                                                    errors++;
                                                                }
                                                                var valid5 = _errs21 === errors;
                                                                if (!valid5) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        else {
                                                            const err2 = {
                                                                instancePath: instancePath +
                                                                    '/extensions/' +
                                                                    key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/1/type',
                                                                keyword: 'type',
                                                                params: { type: 'object' },
                                                                message: 'must be object',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err2];
                                                            }
                                                            else {
                                                                vErrors.push(err2);
                                                            }
                                                            errors++;
                                                        }
                                                    }
                                                    var _valid0 = _errs18 === errors;
                                                    valid4 = valid4 || _valid0;
                                                    if (!valid4) {
                                                        const _errs23 = errors;
                                                        if (errors === _errs23) {
                                                            if (data5 &&
                                                                typeof data5 == 'object' &&
                                                                !Array.isArray(data5)) {
                                                                for (const key4 in data5) {
                                                                    let data7 = data5[key4];
                                                                    const _errs26 = errors;
                                                                    if (errors === _errs26) {
                                                                        if (data7 &&
                                                                            typeof data7 == 'object' &&
                                                                            !Array.isArray(data7)) {
                                                                            for (const key5 in data7) {
                                                                                const _errs29 = errors;
                                                                                if (typeof data7[key5] !== 'string') {
                                                                                    const err3 = {
                                                                                        instancePath: instancePath +
                                                                                            '/extensions/' +
                                                                                            key2
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/' +
                                                                                            key4
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1') +
                                                                                            '/' +
                                                                                            key5
                                                                                                .replace(/~/g, '~0')
                                                                                                .replace(/\//g, '~1'),
                                                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/additionalProperties/type',
                                                                                        keyword: 'type',
                                                                                        params: { type: 'string' },
                                                                                        message: 'must be string',
                                                                                    };
                                                                                    if (vErrors === null) {
                                                                                        vErrors = [err3];
                                                                                    }
                                                                                    else {
                                                                                        vErrors.push(err3);
                                                                                    }
                                                                                    errors++;
                                                                                }
                                                                                var valid7 = _errs29 === errors;
                                                                                if (!valid7) {
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }
                                                                        else {
                                                                            const err4 = {
                                                                                instancePath: instancePath +
                                                                                    '/extensions/' +
                                                                                    key2
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1') +
                                                                                    '/' +
                                                                                    key4
                                                                                        .replace(/~/g, '~0')
                                                                                        .replace(/\//g, '~1'),
                                                                                schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/additionalProperties/type',
                                                                                keyword: 'type',
                                                                                params: { type: 'object' },
                                                                                message: 'must be object',
                                                                            };
                                                                            if (vErrors === null) {
                                                                                vErrors = [err4];
                                                                            }
                                                                            else {
                                                                                vErrors.push(err4);
                                                                            }
                                                                            errors++;
                                                                        }
                                                                    }
                                                                    var valid6 = _errs26 === errors;
                                                                    if (!valid6) {
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                const err5 = {
                                                                    instancePath: instancePath +
                                                                        '/extensions/' +
                                                                        key2
                                                                            .replace(/~/g, '~0')
                                                                            .replace(/\//g, '~1'),
                                                                    schemaPath: '#/definitions/Extensions/additionalProperties/anyOf/2/type',
                                                                    keyword: 'type',
                                                                    params: { type: 'object' },
                                                                    message: 'must be object',
                                                                };
                                                                if (vErrors === null) {
                                                                    vErrors = [err5];
                                                                }
                                                                else {
                                                                    vErrors.push(err5);
                                                                }
                                                                errors++;
                                                            }
                                                        }
                                                        var _valid0 = _errs23 === errors;
                                                        valid4 = valid4 || _valid0;
                                                    }
                                                }
                                                if (!valid4) {
                                                    const err6 = {
                                                        instancePath: instancePath +
                                                            '/extensions/' +
                                                            key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        schemaPath: '#/definitions/Extensions/additionalProperties/anyOf',
                                                        keyword: 'anyOf',
                                                        params: {},
                                                        message: 'must match a schema in anyOf',
                                                    };
                                                    if (vErrors === null) {
                                                        vErrors = [err6];
                                                    }
                                                    else {
                                                        vErrors.push(err6);
                                                    }
                                                    errors++;
                                                    validate21.errors = vErrors;
                                                    return false;
                                                }
                                                else {
                                                    errors = _errs15;
                                                    if (vErrors !== null) {
                                                        if (_errs15) {
                                                            vErrors.length = _errs15;
                                                        }
                                                        else {
                                                            vErrors = null;
                                                        }
                                                    }
                                                }
                                                var valid3 = _errs14 === errors;
                                                if (!valid3) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            validate21.errors = [
                                                {
                                                    instancePath: instancePath + '/extensions',
                                                    schemaPath: '#/definitions/Extensions/type',
                                                    keyword: 'type',
                                                    params: { type: 'object' },
                                                    message: 'must be object',
                                                },
                                            ];
                                            return false;
                                        }
                                    }
                                    var valid0 = _errs10 === errors;
                                }
                                else {
                                    var valid0 = true;
                                }
                                if (valid0) {
                                    if (data.identities !== undefined) {
                                        let data9 = data.identities;
                                        const _errs31 = errors;
                                        if (errors === _errs31) {
                                            if (data9 &&
                                                typeof data9 == 'object' &&
                                                !Array.isArray(data9)) {
                                                for (const key6 in data9) {
                                                    const _errs34 = errors;
                                                    if (!validate26(data9[key6], {
                                                        instancePath: instancePath +
                                                            '/identities/' +
                                                            key6.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                        parentData: data9,
                                                        parentDataProperty: key6,
                                                        rootData,
                                                    })) {
                                                        vErrors =
                                                            vErrors === null
                                                                ? validate26.errors
                                                                : vErrors.concat(validate26.errors);
                                                        errors = vErrors.length;
                                                    }
                                                    var valid8 = _errs34 === errors;
                                                    if (!valid8) {
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                validate21.errors = [
                                                    {
                                                        instancePath: instancePath + '/identities',
                                                        schemaPath: '#/properties/identities/type',
                                                        keyword: 'type',
                                                        params: { type: 'object' },
                                                        message: 'must be object',
                                                    },
                                                ];
                                                return false;
                                            }
                                        }
                                        var valid0 = _errs31 === errors;
                                    }
                                    else {
                                        var valid0 = true;
                                    }
                                    if (valid0) {
                                        if (data.latestRevision !== undefined) {
                                            const _errs35 = errors;
                                            if (typeof data.latestRevision !== 'string') {
                                                validate21.errors = [
                                                    {
                                                        instancePath: instancePath + '/latestRevision',
                                                        schemaPath: '#/properties/latestRevision/type',
                                                        keyword: 'type',
                                                        params: { type: 'string' },
                                                        message: 'must be string',
                                                    },
                                                ];
                                                return false;
                                            }
                                            var valid0 = _errs35 === errors;
                                        }
                                        else {
                                            var valid0 = true;
                                        }
                                        if (valid0) {
                                            if (data.license !== undefined) {
                                                const _errs37 = errors;
                                                if (typeof data.license !== 'string') {
                                                    validate21.errors = [
                                                        {
                                                            instancePath: instancePath + '/license',
                                                            schemaPath: '#/properties/license/type',
                                                            keyword: 'type',
                                                            params: { type: 'string' },
                                                            message: 'must be string',
                                                        },
                                                    ];
                                                    return false;
                                                }
                                                var valid0 = _errs37 === errors;
                                            }
                                            else {
                                                var valid0 = true;
                                            }
                                            if (valid0) {
                                                if (data.registryIdentity !== undefined) {
                                                    let data13 = data.registryIdentity;
                                                    const _errs39 = errors;
                                                    const _errs40 = errors;
                                                    let valid9 = false;
                                                    const _errs41 = errors;
                                                    if (!validate43(data13, {
                                                        instancePath: instancePath + '/registryIdentity',
                                                        parentData: data,
                                                        parentDataProperty: 'registryIdentity',
                                                        rootData,
                                                    })) {
                                                        vErrors =
                                                            vErrors === null
                                                                ? validate43.errors
                                                                : vErrors.concat(validate43.errors);
                                                        errors = vErrors.length;
                                                    }
                                                    var _valid1 = _errs41 === errors;
                                                    valid9 = valid9 || _valid1;
                                                    if (!valid9) {
                                                        const _errs42 = errors;
                                                        if (typeof data13 !== 'string') {
                                                            const err7 = {
                                                                instancePath: instancePath + '/registryIdentity',
                                                                schemaPath: '#/properties/registryIdentity/anyOf/1/type',
                                                                keyword: 'type',
                                                                params: { type: 'string' },
                                                                message: 'must be string',
                                                            };
                                                            if (vErrors === null) {
                                                                vErrors = [err7];
                                                            }
                                                            else {
                                                                vErrors.push(err7);
                                                            }
                                                            errors++;
                                                        }
                                                        var _valid1 = _errs42 === errors;
                                                        valid9 = valid9 || _valid1;
                                                    }
                                                    if (!valid9) {
                                                        const err8 = {
                                                            instancePath: instancePath + '/registryIdentity',
                                                            schemaPath: '#/properties/registryIdentity/anyOf',
                                                            keyword: 'anyOf',
                                                            params: {},
                                                            message: 'must match a schema in anyOf',
                                                        };
                                                        if (vErrors === null) {
                                                            vErrors = [err8];
                                                        }
                                                        else {
                                                            vErrors.push(err8);
                                                        }
                                                        errors++;
                                                        validate21.errors = vErrors;
                                                        return false;
                                                    }
                                                    else {
                                                        errors = _errs40;
                                                        if (vErrors !== null) {
                                                            if (_errs40) {
                                                                vErrors.length = _errs40;
                                                            }
                                                            else {
                                                                vErrors = null;
                                                            }
                                                        }
                                                    }
                                                    var valid0 = _errs39 === errors;
                                                }
                                                else {
                                                    var valid0 = true;
                                                }
                                                if (valid0) {
                                                    if (data.tags !== undefined) {
                                                        let data14 = data.tags;
                                                        const _errs44 = errors;
                                                        if (errors === _errs44) {
                                                            if (data14 &&
                                                                typeof data14 == 'object' &&
                                                                !Array.isArray(data14)) {
                                                                for (const key7 in data14) {
                                                                    const _errs47 = errors;
                                                                    if (!validate45(data14[key7], {
                                                                        instancePath: instancePath +
                                                                            '/tags/' +
                                                                            key7
                                                                                .replace(/~/g, '~0')
                                                                                .replace(/\//g, '~1'),
                                                                        parentData: data14,
                                                                        parentDataProperty: key7,
                                                                        rootData,
                                                                    })) {
                                                                        vErrors =
                                                                            vErrors === null
                                                                                ? validate45.errors
                                                                                : vErrors.concat(validate45.errors);
                                                                        errors = vErrors.length;
                                                                    }
                                                                    var valid10 = _errs47 === errors;
                                                                    if (!valid10) {
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                validate21.errors = [
                                                                    {
                                                                        instancePath: instancePath + '/tags',
                                                                        schemaPath: '#/properties/tags/type',
                                                                        keyword: 'type',
                                                                        params: { type: 'object' },
                                                                        message: 'must be object',
                                                                    },
                                                                ];
                                                                return false;
                                                            }
                                                        }
                                                        var valid0 = _errs44 === errors;
                                                    }
                                                    else {
                                                        var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                        if (data.version !== undefined) {
                                                            let data16 = data.version;
                                                            const _errs48 = errors;
                                                            if (errors === _errs48) {
                                                                if (data16 &&
                                                                    typeof data16 == 'object' &&
                                                                    !Array.isArray(data16)) {
                                                                    let missing1;
                                                                    if ((data16.major === undefined &&
                                                                        (missing1 = 'major')) ||
                                                                        (data16.minor === undefined &&
                                                                            (missing1 = 'minor')) ||
                                                                        (data16.patch === undefined &&
                                                                            (missing1 = 'patch'))) {
                                                                        validate21.errors = [
                                                                            {
                                                                                instancePath: instancePath + '/version',
                                                                                schemaPath: '#/properties/version/required',
                                                                                keyword: 'required',
                                                                                params: { missingProperty: missing1 },
                                                                                message: "must have required property '" +
                                                                                    missing1 +
                                                                                    "'",
                                                                            },
                                                                        ];
                                                                        return false;
                                                                    }
                                                                    else {
                                                                        const _errs50 = errors;
                                                                        for (const key8 in data16) {
                                                                            if (!(key8 === 'major' ||
                                                                                key8 === 'minor' ||
                                                                                key8 === 'patch')) {
                                                                                validate21.errors = [
                                                                                    {
                                                                                        instancePath: instancePath + '/version',
                                                                                        schemaPath: '#/properties/version/additionalProperties',
                                                                                        keyword: 'additionalProperties',
                                                                                        params: {
                                                                                            additionalProperty: key8,
                                                                                        },
                                                                                        message: 'must NOT have additional properties',
                                                                                    },
                                                                                ];
                                                                                return false;
                                                                            }
                                                                        }
                                                                        if (_errs50 === errors) {
                                                                            if (data16.major !== undefined) {
                                                                                let data17 = data16.major;
                                                                                const _errs51 = errors;
                                                                                if (!(typeof data17 == 'number' &&
                                                                                    isFinite(data17))) {
                                                                                    validate21.errors = [
                                                                                        {
                                                                                            instancePath: instancePath + '/version/major',
                                                                                            schemaPath: '#/properties/version/properties/major/type',
                                                                                            keyword: 'type',
                                                                                            params: { type: 'number' },
                                                                                            message: 'must be number',
                                                                                        },
                                                                                    ];
                                                                                    return false;
                                                                                }
                                                                                var valid11 = _errs51 === errors;
                                                                            }
                                                                            else {
                                                                                var valid11 = true;
                                                                            }
                                                                            if (valid11) {
                                                                                if (data16.minor !== undefined) {
                                                                                    let data18 = data16.minor;
                                                                                    const _errs53 = errors;
                                                                                    if (!(typeof data18 == 'number' &&
                                                                                        isFinite(data18))) {
                                                                                        validate21.errors = [
                                                                                            {
                                                                                                instancePath: instancePath +
                                                                                                    '/version/minor',
                                                                                                schemaPath: '#/properties/version/properties/minor/type',
                                                                                                keyword: 'type',
                                                                                                params: { type: 'number' },
                                                                                                message: 'must be number',
                                                                                            },
                                                                                        ];
                                                                                        return false;
                                                                                    }
                                                                                    var valid11 = _errs53 === errors;
                                                                                }
                                                                                else {
                                                                                    var valid11 = true;
                                                                                }
                                                                                if (valid11) {
                                                                                    if (data16.patch !== undefined) {
                                                                                        let data19 = data16.patch;
                                                                                        const _errs55 = errors;
                                                                                        if (!(typeof data19 == 'number' &&
                                                                                            isFinite(data19))) {
                                                                                            validate21.errors = [
                                                                                                {
                                                                                                    instancePath: instancePath +
                                                                                                        '/version/patch',
                                                                                                    schemaPath: '#/properties/version/properties/patch/type',
                                                                                                    keyword: 'type',
                                                                                                    params: { type: 'number' },
                                                                                                    message: 'must be number',
                                                                                                },
                                                                                            ];
                                                                                            return false;
                                                                                        }
                                                                                        var valid11 = _errs55 === errors;
                                                                                    }
                                                                                    else {
                                                                                        var valid11 = true;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                else {
                                                                    validate21.errors = [
                                                                        {
                                                                            instancePath: instancePath + '/version',
                                                                            schemaPath: '#/properties/version/type',
                                                                            keyword: 'type',
                                                                            params: { type: 'object' },
                                                                            message: 'must be object',
                                                                        },
                                                                    ];
                                                                    return false;
                                                                }
                                                            }
                                                            var valid0 = _errs48 === errors;
                                                        }
                                                        else {
                                                            var valid0 = true;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            validate21.errors = [
                {
                    instancePath,
                    schemaPath: '#/type',
                    keyword: 'type',
                    params: { type: 'object' },
                    message: 'must be object',
                },
            ];
            return false;
        }
    }
    validate21.errors = vErrors;
    return errors === 0;
}
function validate20(data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (!validate21(data, {
        instancePath,
        parentData,
        parentDataProperty,
        rootData,
    })) {
        vErrors =
            vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
        errors = vErrors.length;
    }
    validate20.errors = vErrors;
    return errors === 0;
}

/**
 * Safely parse and validate a Bitcoin Cash Metadata Registry (BCMR), returning
 * either an error message as a string or a valid {@link MetadataRegistry}. The
 * registry may be provided either as an untrusted JSON string or as a
 * pre-parsed object.
 *
 * This method validates both the structure and the contents of a registry:
 * - All properties and sub-properties are verified to be of the expected type.
 * - The registry contains no unknown properties.
 *
 * @param untrustedJsonOrObject - the JSON string or object to validate as
 * metadata registry
 */
const importMetadataRegistry = (untrustedJsonOrObject) => {
    const errorPrefix = `Metadata Registry import failed:`;
    const registry = ajvStandaloneJsonParse(untrustedJsonOrObject, validate20);
    if (typeof registry === 'string') {
        return `${errorPrefix}${registry}`;
    }
    // TODO: additional validation?
    return registry;
};

/**
 * Safely parse and validate a wallet template, returning either an
 * error message as a string or a valid {@link WalletTemplate}. The
 * template may be provided either as an untrusted JSON string or as a
 * pre-parsed object.
 *
 * This method validates both the structure and the contents of a template:
 * - All properties and sub-properties are verified to be of the expected type.
 * - The template contains no unknown properties.
 * - The ID of each entity, script, and scenario is confirmed to be unique.
 * - Script IDs referenced by entities and other scripts (via `unlocks`) are
 * confirmed to exist.
 * - The derivation paths of each HdKey are validated against each other.
 *
 * This method does not validate the CashAssembly contents of scripts (by
 * attempting compilation, evaluating {@link WalletTemplateScriptTest}s,
 * or testing scenario generation).
 *
 * @param untrustedJsonOrObject - the JSON string or object to validate as a
 * wallet template
 */
const importWalletTemplate = (untrustedJsonOrObject) => {
    const errorPrefix = `Wallet template import failed:`;
    const template = ajvStandaloneJsonParse(untrustedJsonOrObject, validate20$1);
    if (typeof template === 'string') {
        return `${errorPrefix}${template}`;
    }
    // TODO: add back other validation
    return template;
};

const returnFailedCompilationDirective = ({ index, result, type, }) => ({
    errors: result.errors.map((error) => ({
        ...error,
        error: `Failed compilation of ${type} directive at index "${index}": ${error.error}`,
    })),
    index,
    ...(result.errorType === 'parse' ? {} : { resolved: result.resolve }),
    type,
});
// eslint-disable-next-line complexity
const compileOutputTemplate = ({ outputTemplate, index, }) => {
    if ('script' in outputTemplate.lockingBytecode) {
        const directive = outputTemplate.lockingBytecode;
        const data = directive.data ?? {};
        const result = directive.compiler.generateBytecode({
            data,
            debug: true,
            scriptId: directive.script,
        });
        return result.success
            ? {
                lockingBytecode: result.bytecode,
                ...(outputTemplate.token === undefined
                    ? {}
                    : { token: outputTemplate.token }),
                valueSatoshis: outputTemplate.valueSatoshis,
            }
            : returnFailedCompilationDirective({ index, result, type: 'locking' });
    }
    return {
        lockingBytecode: outputTemplate.lockingBytecode.slice(),
        ...(outputTemplate.token === undefined
            ? {}
            : { token: outputTemplate.token }),
        valueSatoshis: outputTemplate.valueSatoshis,
    };
};
const compileInputTemplate = ({ inputTemplate, index, template, outputs, }) => {
    if ('script' in inputTemplate.unlockingBytecode) {
        const directive = inputTemplate.unlockingBytecode;
        // TODO: workaround, replace by migrating to PST format
        const sourceOutputs = [];
        // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data
        sourceOutputs[index] = {
            lockingBytecode: Uint8Array.of(),
            ...(inputTemplate.unlockingBytecode.token === undefined
                ? {}
                : { token: inputTemplate.unlockingBytecode.token }),
            valueSatoshis: inputTemplate.unlockingBytecode.valueSatoshis,
        };
        const result = directive.compiler.generateBytecode({
            data: {
                ...directive.data,
                compilationContext: {
                    inputIndex: index,
                    sourceOutputs,
                    transaction: {
                        inputs: template.inputs,
                        locktime: template.locktime,
                        outputs,
                        version: template.version,
                    },
                },
            },
            debug: true,
            scriptId: directive.script,
        });
        return result.success
            ? {
                outpointIndex: inputTemplate.outpointIndex,
                outpointTransactionHash: inputTemplate.outpointTransactionHash.slice(),
                sequenceNumber: inputTemplate.sequenceNumber,
                unlockingBytecode: result.bytecode,
            }
            : returnFailedCompilationDirective({ index, result, type: 'unlocking' });
    }
    return {
        outpointIndex: inputTemplate.outpointIndex,
        outpointTransactionHash: inputTemplate.outpointTransactionHash.slice(),
        sequenceNumber: inputTemplate.sequenceNumber,
        unlockingBytecode: inputTemplate.unlockingBytecode.slice(),
    };
};
/**
 * Generate a `Transaction` given a `TransactionTemplate` and any applicable
 * compilers and compilation data.
 *
 * Returns either a `Transaction` or an array of compilation errors.
 *
 * For each `CompilationDirective`, the `compilationContext` property will be
 * automatically provided to the compiler. All other necessary `CompilationData`
 * properties must be specified in the `TransactionTemplate`.
 *
 * @param template - the `TransactionTemplate` from which to create the
 * `Transaction`
 */
const generateTransaction = (template) => {
    const outputResults = template.outputs.map((outputTemplate, index) => compileOutputTemplate({
        index,
        outputTemplate,
    }));
    const outputCompilationErrors = outputResults.filter((result) => 'errors' in result);
    if (outputCompilationErrors.length > 0) {
        const outputCompletions = outputResults
            .map((result, index) => 'lockingBytecode' in result
            ? { index, output: result, type: 'output' }
            : result)
            .filter((result) => 'output' in result);
        return {
            completions: outputCompletions,
            errors: outputCompilationErrors,
            stage: 'outputs',
            success: false,
        };
    }
    const outputs = outputResults;
    const inputResults = template.inputs.map((inputTemplate, index) => compileInputTemplate({
        index,
        inputTemplate,
        outputs,
        template,
    }));
    const inputCompilationErrors = inputResults.filter((result) => 'errors' in result);
    if (inputCompilationErrors.length > 0) {
        const inputCompletions = inputResults
            .map((result, index) => 'unlockingBytecode' in result
            ? { index, input: result, type: 'input' }
            : result)
            .filter((result) => 'input' in result);
        return {
            completions: inputCompletions,
            errors: inputCompilationErrors,
            stage: 'inputs',
            success: false,
        };
    }
    const inputs = inputResults;
    return {
        success: true,
        transaction: {
            inputs,
            locktime: template.locktime,
            outputs,
            version: template.version,
        },
    };
};
/**
 * TODO: fundamentally unsound, migrate to PST format
 *
 * Extract a map of successfully resolved variables to their resolved bytecode.
 *
 * @param transactionGenerationError - a transaction generation attempt where
 * `success` is `false`
 */
const extractResolvedVariables = (transactionGenerationError) => transactionGenerationError.errors.reduce((all, error) => error.resolved === undefined
    ? all
    : { ...all, ...extractResolvedVariableBytecodeMap(error.resolved) }, {});
/**
 * TODO: fundamentally unsound, migrate to PST format
 *
 * Given an unsuccessful transaction generation result, extract a map of the
 * identifiers missing from the compilation mapped to the entity that owns each
 * variable.
 *
 * Returns `false` if any errors are fatal (the error either cannot be resolved
 * by providing a variable, or the entity ownership of the required variable was
 * not provided in the compilation data).
 *
 * @param transactionGenerationError - a transaction generation result where
 * `success` is `false`
 */
const extractMissingVariables = (transactionGenerationError) => {
    const allErrors = transactionGenerationError.errors.reduce((all, error) => [...all, ...error.errors], []);
    if (!allErrorsAreRecoverable(allErrors)) {
        return false;
    }
    return allErrors.reduce((all, error) => ({
        ...all,
        [error.missingIdentifier]: error.owningEntity,
    }), {});
};
/**
 * TODO: fundamentally unsound, migrate to PST format
 *
 * Safely extend a compilation data with resolutions provided by other entities
 * (via `extractResolvedVariables`).
 *
 * It is security-critical that compilation data only be extended with expected
 * identifiers from the proper owning entity of each variable. See
 * `CompilationData.bytecode` for details.
 *
 * Returns `false` if any errors are fatal (the error either cannot be resolved
 * by providing a variable, or the entity ownership of the required variable was
 * not provided in the compilation data).
 *
 * @remarks
 * To determine which identifiers are required by a given compilation, the
 * compilation is first attempted with only trusted variables: variables owned
 * or previously verified (like `WalletData`) by the compiling entity. If this
 * compilation produces a `TransactionGenerationError`, the error can be
 * provided to `safelyExtendCompilationData`, along with the trusted compilation
 * data and a mapping of untrusted resolutions (where the result of
 * `extractResolvedVariables` is assigned to the entity ID of the entity from
 * which they were received).
 *
 * The first compilation must use only trusted compilation data
 */
const safelyExtendCompilationData = (transactionGenerationError, trustedCompilationData, untrustedResolutions) => {
    const missing = extractMissingVariables(transactionGenerationError);
    if (missing === false)
        return false;
    const selectedResolutions = Object.entries(missing).reduce((all, [identifier, entityId]) => {
        const entityResolution = untrustedResolutions[entityId];
        if (entityResolution === undefined) {
            return all;
        }
        const resolution = entityResolution[identifier];
        if (resolution === undefined) {
            return all;
        }
        return { ...all, [identifier]: resolution };
    }, {});
    return {
        ...trustedCompilationData,
        bytecode: {
            ...selectedResolutions,
            ...trustedCompilationData.bytecode,
        },
    };
};

const simpleP2pkhOutput = {
    lockingBytecode: { script: 'lockP2pkh' },
    valueSatoshis: 10000,
};
const simpleP2pkhInput = {
    unlockingBytecode: { script: 'unlockP2pkh' },
};
const vmbTestOutput = {
    lockingBytecode: { script: 'vmbTestNullData' },
    valueSatoshis: 0,
};
const slotOutput = {
    lockingBytecode: ['slot'],
    valueSatoshis: 10000,
};
const slotInput = {
    unlockingBytecode: ['slot'],
};
const slot1Scenario = {
    sourceOutputs: [simpleP2pkhOutput, slotOutput],
    transaction: {
        inputs: [simpleP2pkhInput, slotInput],
        outputs: [vmbTestOutput],
    },
};

/**
 * This script generates all bch_vmb_tests, run it with: `yarn gen:tests`.
 */
/**
 * Not used currently, but these are the defaults that inform
 * {@link supportedTestSetOverridesBCH}.
 */
const vmbTestDefinitionDefaultBehaviorBCH = [
    'nop2sh_nonstandard',
    'p2sh20_standard',
    'p2sh32_ignore',
];
/**
 * Given one of these values and the
 * {@link vmbTestDefinitionDefaultBehaviorBCH}, return these test plans.
 */
const supportedTestSetOverridesBCH = {
    /* eslint-disable camelcase */
    '': [
        { mode: 'nonP2SH', sets: ['2022_nonstandard'] },
        { mode: 'P2SH20', sets: ['2022_standard'] },
    ],
    /**
     * `chip_*` values exclude the marked test from
     * {@link vmbTestDefinitionDefaultBehaviorBCH}.
     */
    chip_cashtokens: [
        {
            mode: 'nonP2SH',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard'],
        },
        {
            mode: 'P2SH20',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_standard'],
        },
        {
            mode: 'P2SH32',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_standard'],
        },
    ],
    'chip_cashtokens,2022_p2sh32_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard'],
        },
        {
            mode: 'P2SH20',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_standard'],
        },
        {
            mode: 'P2SH32',
            sets: ['before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard'],
        },
    ],
    chip_cashtokens_invalid: [
        {
            mode: 'nonP2SH',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid'],
        },
        {
            mode: 'P2SH20',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid'],
        },
        {
            mode: 'P2SH32',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid'],
        },
    ],
    'chip_cashtokens_invalid,2022_p2sh32_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid'],
        },
        {
            mode: 'P2SH20',
            sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid'],
        },
        {
            mode: 'P2SH32',
            sets: ['before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid'],
        },
    ],
    chip_loops: [
        { mode: 'nonP2SH', sets: ['chip_loops_nonstandard'] },
        { mode: 'P2SH20', sets: ['chip_loops_standard'] },
    ],
    chip_loops_invalid: [
        { mode: 'nonP2SH', sets: ['chip_loops_invalid'] },
        { mode: 'P2SH20', sets: ['chip_loops_invalid'] },
    ],
    'default,chip_cashtokens': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_standard',
                'before_chip_cashtokens_standard',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: ['chip_cashtokens_standard'],
        },
    ],
    invalid: [
        { mode: 'nonP2SH', sets: ['2022_invalid'] },
        { mode: 'P2SH20', sets: ['2022_invalid'] },
    ],
    'invalid,2022_p2sh32_nonstandard,chip_cashtokens': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_standard',
            ],
        },
    ],
    'invalid,2022_p2sh32_nonstandard,chip_cashtokens_invalid': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_invalid',
            ],
        },
    ],
    'invalid,2022_p2sh32_nonstandard,chip_cashtokens_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
    ],
    'invalid,chip_cashtokens': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_standard',
            ],
        },
    ],
    'invalid,chip_cashtokens,chip_cashtokens_p2sh20_nonstandard,chip_cashtokens_p2sh32_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
    ],
    'invalid,chip_cashtokens,chip_cashtokens_p2sh32_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
    ],
    'invalid,chip_cashtokens,nop2sh_invalid': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_standard',
            ],
        },
    ],
    'invalid,chip_cashtokens,p2sh_ignore': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
    ],
    'invalid,chip_cashtokens_invalid': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
    ],
    'invalid,chip_cashtokens_invalid,p2sh_ignore': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
    ],
    'invalid,nop2sh_nonstandard': [
        { mode: 'nonP2SH', sets: ['2022_nonstandard'] },
        { mode: 'P2SH20', sets: ['2022_invalid'] },
    ],
    'invalid,p2sh20_standard': [
        { mode: 'nonP2SH', sets: ['2022_invalid'] },
        { mode: 'P2SH20', sets: ['2022_standard'] },
    ],
    'invalid,p2sh_ignore': [{ mode: 'nonP2SH', sets: ['2022_invalid'] }],
    'invalid,p2sh_nonstandard,chip_cashtokens': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_standard',
            ],
        },
    ],
    'invalid,p2sh_nonstandard,chip_cashtokens_invalid': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_invalid',
                'before_chip_cashtokens_invalid',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_invalid',
            ],
        },
    ],
    'invalid,p2sh_standard': [
        { mode: 'nonP2SH', sets: ['2022_invalid'] },
        { mode: 'P2SH20', sets: ['2022_standard'] },
    ],
    nonstandard: [
        { mode: 'nonP2SH', sets: ['2022_nonstandard'] },
        { mode: 'P2SH20', sets: ['2022_nonstandard'] },
    ],
    'nonstandard,chip_cashtokens': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_standard',
            ],
        },
    ],
    'nonstandard,chip_cashtokens,chip_cashtokens_p2sh20_nonstandard,chip_cashtokens_p2sh32_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
    ],
    'nonstandard,chip_cashtokens,chip_cashtokens_p2sh32_nonstandard': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_standard',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_nonstandard',
            ],
        },
    ],
    'nonstandard,chip_cashtokens_invalid': [
        {
            mode: 'nonP2SH',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH20',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_invalid',
            ],
        },
        {
            mode: 'P2SH32',
            sets: [
                '2022_nonstandard',
                'before_chip_cashtokens_nonstandard',
                'chip_cashtokens_invalid',
            ],
        },
    ],
    'nonstandard,p2sh_ignore': [{ mode: 'nonP2SH', sets: ['2022_nonstandard'] }],
    'nonstandard,p2sh_invalid': [
        { mode: 'nonP2SH', sets: ['2022_nonstandard'] },
        { mode: 'P2SH20', sets: ['2022_invalid'] },
    ],
    nop2sh_invalid: [
        { mode: 'nonP2SH', sets: ['2022_invalid'] },
        { mode: 'P2SH20', sets: ['2022_standard'] },
    ],
    p2sh_ignore: [{ mode: 'nonP2SH', sets: ['2022_nonstandard'] }],
    p2sh_invalid: [
        { mode: 'nonP2SH', sets: ['2022_nonstandard'] },
        { mode: 'P2SH20', sets: ['2022_invalid'] },
    ],
    /* eslint-enable camelcase */
};
/**
 * Short IDs use bech32 encoding, so birthday collisions will happen
 * approximately every `Math.sqrt(2 * (32 ** defaultShortIdLength))` tests.
 */
const defaultShortIdLength = 5;
const planTestsBCH = (labels) => supportedTestSetOverridesBCH[(labels ?? []).join(',')];
/**
 * Given a VMB test definition, generate a full VMB test vector. Note, this
 * method throws immediately on the first test vector generation failure.
 */
const vmbTestDefinitionToVmbTests = (testDefinition, groupName = '', shortIdLength = defaultShortIdLength) => {
    const [unlockingScript, redeemOrLockingScript, testDescription, testSetOverrideLabels, scenarioOverride, additionalScripts,] = testDefinition;
    const scenarioId = 'test';
    const testGenerationPlan = planTestsBCH(testSetOverrideLabels);
    const scenarioDefinition = { extends: 'vmb_default', ...scenarioOverride };
    const configuration = walletTemplateToCompilerConfiguration({
        entities: {
            tester: {
                variables: {
                    key1: { type: 'HdKey' },
                    key2: { privateDerivationPath: 'm/2/i', type: 'HdKey' },
                    key3: { privateDerivationPath: 'm/3/i', type: 'HdKey' },
                },
            },
        },
        scenarios: {
            [scenarioId]: scenarioDefinition,
            // eslint-disable-next-line @typescript-eslint/naming-convention, camelcase
            vmb_default: slot1Scenario,
        },
        scripts: {
            ...additionalScripts,
            lockEmptyP2sh20: { lockingType: 'p2sh20', script: '' },
            lockP2pkh: {
                lockingType: 'standard',
                script: 'OP_DUP OP_HASH160 <$(<key1.public_key> OP_HASH160)> OP_EQUALVERIFY OP_CHECKSIG',
            },
            lockP2sh20: { lockingType: 'p2sh20', script: redeemOrLockingScript },
            lockP2sh32: { lockingType: 'p2sh32', script: redeemOrLockingScript },
            lockStandard: { lockingType: 'standard', script: redeemOrLockingScript },
            unlockEmptyP2sh20: { script: '<1>', unlocks: 'lockEmptyP2sh20' },
            unlockP2pkh: {
                /**
                 * Uses `corresponding_output_single_input` to reuse the same signature
                 * as much as possible (making VMB test files more compressible).
                 */
                script: '<key1.schnorr_signature.corresponding_output_single_input> <key1.public_key>',
                unlocks: 'lockP2pkh',
            },
            unlockP2sh20: { script: unlockingScript, unlocks: 'lockP2sh20' },
            unlockP2sh32: { script: unlockingScript, unlocks: 'lockP2sh32' },
            unlockStandard: { script: unlockingScript, unlocks: 'lockStandard' },
            vmbTestNullData: {
                lockingType: 'standard',
                script: 'OP_RETURN <"vmb_test">',
            },
        }});
    const compiler = createCompilerBCH(configuration);
    const tests = testGenerationPlan.map((planItem) => {
        const description = `${groupName}: ${testDescription} (${planItem.mode})`;
        const result = compiler.generateScenario({
            debug: true,
            scenarioId,
            unlockingScriptId: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                P2SH20: 'unlockP2sh20',
                // eslint-disable-next-line @typescript-eslint/naming-convention
                P2SH32: 'unlockP2sh32',
                nonP2SH: 'unlockStandard',
            }[planItem.mode],
        });
        if (typeof result === 'string') {
            // eslint-disable-next-line functional/no-throw-statements
            throw new Error(`Error while generating "${description}" - ${result}`);
        }
        if (typeof result.scenario === 'string') {
            // eslint-disable-next-line functional/no-throw-statements
            throw new Error(`Error while generating "${description}" - ${result.scenario}`);
        }
        const encodedTx = encodeTransaction(result.scenario.program.transaction);
        const encodedSourceOutputs = encodeTransactionOutputs(result.scenario.program.sourceOutputs);
        const shortId = encodeBech32(regroupBits({
            bin: sha256.hash(flattenBinArray([encodedTx, encodedSourceOutputs])),
            resultWordLength: 5,
            sourceWordLength: 8,
        })).slice(0, shortIdLength);
        const testCase = [
            shortId,
            description,
            unlockingScript,
            redeemOrLockingScript,
            binToHex(encodedTx),
            binToHex(encodedSourceOutputs),
            planItem.sets,
        ];
        return (result.scenario.program.inputIndex === 0
            ? testCase
            : [...testCase, result.scenario.program.inputIndex]);
    });
    return tests;
};
const vmbTestGroupToVmbTests = (testGroup) => testGroup[1].map((testDefinition) => vmbTestDefinitionToVmbTests(testDefinition, testGroup[0]));
/**
 * Partition a master test list (produced by {@link vmbTestGroupToVmbTests} or
 * {@link vmbTestDefinitionToVmbTests}) into sets. E.g.:
 * ```ts
 * const definitions: VmbTestDefinitionGroup[] = [...]
 * const master = [
 *   vmbTestDefinitionToVmbTests(...),
 *   vmbTestDefinitionToVmbTests(...),
 * ];
 * const partitioned = vmbTestPartitionMasterTestList(master);
 * ```
 * Or:
 * ```ts
 * const definitions: VmbTestDefinitionGroup[] = [...]
 * const master = definitions.map(vmbTestGroupToVmbTests).flat(2);
 * const partitioned = vmbTestPartitionMasterTestList(master);
 * ```
 * Tests are aggregated by set into a map of test sets (e.g. to export to
 * separate files).
 */
const vmbTestPartitionMasterTestList = (masterTestList) => masterTestList.reduce((accumulatedTestSets, testCase) => {
    const [shortId, testDescription, unlockingScriptAsm, redeemOrLockingScriptAsm, testTransactionHex, sourceOutputsHex, testSets, inputIndex,] = testCase;
    const withoutSets = [
        shortId,
        testDescription,
        unlockingScriptAsm,
        redeemOrLockingScriptAsm,
        testTransactionHex,
        sourceOutputsHex,
        ...(inputIndex === undefined ? [] : [inputIndex]),
    ];
    // eslint-disable-next-line functional/no-return-void, functional/no-expression-statements
    testSets.forEach((testSet) => {
        // eslint-disable-next-line functional/immutable-data, functional/no-expression-statements
        accumulatedTestSets[testSet] = [
            ...(accumulatedTestSets[testSet] ?? []),
            withoutSets,
        ];
    });
    return accumulatedTestSets;
}, {});

var libauth = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AuthenticationErrorBCH: AuthenticationErrorBCH,
    get AuthenticationErrorBCH2022 () { return AuthenticationErrorBCH2022; },
    get AuthenticationErrorBCH2023 () { return AuthenticationErrorBCH2023; },
    get AuthenticationErrorBCHCHIPs () { return AuthenticationErrorBCHCHIPs; },
    get AuthenticationErrorCommon () { return AuthenticationErrorCommon; },
    get Base58AddressError () { return Base58AddressError; },
    get Base58AddressFormatVersion () { return Base58AddressFormatVersion; },
    get BaseConversionError () { return BaseConversionError; },
    get BaseConverterCreationError () { return BaseConverterCreationError; },
    get Bech32DecodingError () { return Bech32DecodingError; },
    get Bip39Error () { return Bip39Error; },
    get BitRegroupingError () { return BitRegroupingError; },
    get BuiltInVariables () { return BuiltInVariables; },
    get CashAddressDecodingError () { return CashAddressDecodingError; },
    get CashAddressEncodingError () { return CashAddressEncodingError; },
    get CashAddressFormatCorrectionError () { return CashAddressFormatCorrectionError; },
    get CashAddressFormatEncodingError () { return CashAddressFormatEncodingError; },
    get CashAddressNetworkPrefix () { return CashAddressNetworkPrefix; },
    get CashAddressType () { return CashAddressType; },
    get CashAddressTypeBits () { return CashAddressTypeBits; },
    get CashAddressVersionByte () { return CashAddressVersionByte; },
    get CashAddressVersionByteDecodingError () { return CashAddressVersionByteDecodingError; },
    get CashTokenDecodingError () { return CashTokenDecodingError; },
    get CompactUintError () { return CompactUintError; },
    get CompactUintPrefixedBinError () { return CompactUintPrefixedBinError; },
    get CompilerDefaults () { return CompilerDefaults; },
    get CompressionFlag () { return CompressionFlag; },
    ConsensusBCH: ConsensusBCH,
    get ConsensusBCH2023 () { return ConsensusBCH2023; },
    get ConsensusBCHCHIPs () { return ConsensusBCHCHIPs; },
    get ConsensusCommon () { return ConsensusCommon; },
    get ConsensusXEC () { return ConsensusXEC; },
    get ContextFlag () { return ContextFlag; },
    get EntropyGenerationError () { return EntropyGenerationError; },
    get HdKeyDecodingError () { return HdKeyDecodingError; },
    get HdKeyEncodingError () { return HdKeyEncodingError; },
    get HdKeyVersion () { return HdKeyVersion; },
    get HdNodeCrackingError () { return HdNodeCrackingError; },
    get HdNodeDerivationError () { return HdNodeDerivationError; },
    get IdentifierResolutionErrorType () { return IdentifierResolutionErrorType; },
    get IdentifierResolutionType () { return IdentifierResolutionType; },
    get LockingBytecodeType () { return LockingBytecodeType; },
    get LocktimeError () { return LocktimeError; },
    get NonFungibleTokenCapability () { return NonFungibleTokenCapability; },
    OpcodeDescriptions: OpcodeDescriptions,
    OpcodeDescriptionsBCH: OpcodeDescriptionsBCH,
    get OpcodeDescriptionsBCH2022 () { return OpcodeDescriptionsBCH2022; },
    get OpcodeDescriptionsBCH2023 () { return OpcodeDescriptionsBCH2023; },
    get OpcodeDescriptionsBCHCHIPs () { return OpcodeDescriptionsBCHCHIPs; },
    get OpcodeDescriptionsBTC () { return OpcodeDescriptionsBTC; },
    get OpcodeDescriptionsXEC () { return OpcodeDescriptionsXEC; },
    Opcodes: Opcodes,
    OpcodesBCH: OpcodesBCH,
    get OpcodesBCH2022 () { return OpcodesBCH2022; },
    get OpcodesBCH2023 () { return OpcodesBCH2023; },
    get OpcodesBCHCHIPs () { return OpcodesBCHCHIPs; },
    get OpcodesBTC () { return OpcodesBTC; },
    get OpcodesXEC () { return OpcodesXEC; },
    get P2pkhUtilityError () { return P2pkhUtilityError; },
    get Pbkdf2Error () { return Pbkdf2Error; },
    get ReadBytesError () { return ReadBytesError; },
    get ReadItemCountError () { return ReadItemCountError; },
    get ReadUint32LEError () { return ReadUint32LEError; },
    get ReadUint64LEError () { return ReadUint64LEError; },
    get Secp256k1Error () { return Secp256k1Error; },
    get SigningSerializationAlgorithmIdentifier () { return SigningSerializationAlgorithmIdentifier; },
    get SigningSerializationFlag () { return SigningSerializationFlag; },
    get SigningSerializationType () { return SigningSerializationType; },
    SigningSerializationTypeBCH: SigningSerializationTypeBCH,
    SigningSerializationTypesBCH: SigningSerializationTypesBCH,
    SigningSerializationTypesBCH2023: SigningSerializationTypesBCH2023,
    SigningSerializationTypesCommon: SigningSerializationTypesCommon,
    get TransactionDecodingError () { return TransactionDecodingError; },
    get VmNumberError () { return VmNumberError; },
    get WalletImportFormatError () { return WalletImportFormatError; },
    addressContentsToLockingBytecode: addressContentsToLockingBytecode,
    allErrorsAreRecoverable: allErrorsAreRecoverable,
    applyError: applyError,
    assembleBitcoinSatoshiScript: assembleBitcoinSatoshiScript,
    assembleBytecode: assembleBytecode,
    assembleBytecodeBCH: assembleBytecodeBCH,
    assembleBytecodeBTC: assembleBytecodeBTC,
    assertSuccess: assertSuccess,
    attemptBip39MnemonicErrorCorrection: attemptBip39MnemonicErrorCorrection,
    attemptCashAddressFormatErrorCorrection: attemptCashAddressFormatErrorCorrection,
    attemptCompilerOperations: attemptCompilerOperations,
    authenticationInstructionIsMalformed: authenticationInstructionIsMalformed,
    authenticationInstructionsAreMalformed: authenticationInstructionsAreMalformed,
    authenticationInstructionsArePushInstructions: authenticationInstructionsArePushInstructions,
    base58AddressToLockingBytecode: base58AddressToLockingBytecode,
    base58ToBin: base58ToBin,
    base64ToBin: base64ToBin,
    bech32CharacterSet: bech32CharacterSet,
    bech32CharacterSetIndex: bech32CharacterSetIndex,
    bech32PaddedToBin: bech32PaddedToBin,
    bigIntToBinUint256BEClamped: bigIntToBinUint256BEClamped,
    bigIntToBinUint64LE: bigIntToBinUint64LE,
    bigIntToBinUint64LEClamped: bigIntToBinUint64LEClamped,
    bigIntToBinUintBE: bigIntToBinUintBE,
    bigIntToBinUintLE: bigIntToBinUintLE,
    bigIntToCompactUint: bigIntToCompactUint,
    bigIntToVmNumber: bigIntToVmNumber,
    binStringToBin: binStringToBin,
    binToBase58: binToBase58,
    binToBase64: binToBase64,
    binToBech32Padded: binToBech32Padded,
    binToBigIntUint256BE: binToBigIntUint256BE,
    binToBigIntUint64LE: binToBigIntUint64LE,
    binToBigIntUintBE: binToBigIntUintBE,
    binToBigIntUintLE: binToBigIntUintLE,
    binToBinString: binToBinString,
    binToFixedLength: binToFixedLength,
    binToHex: binToHex,
    binToNumberInt16LE: binToNumberInt16LE,
    binToNumberInt32LE: binToNumberInt32LE,
    binToNumberUint16LE: binToNumberUint16LE,
    binToNumberUint32LE: binToNumberUint32LE,
    binToNumberUintLE: binToNumberUintLE,
    binToUtf8: binToUtf8,
    binToValueSatoshis: binToValueSatoshis,
    binsAreEqual: binsAreEqual,
    bip32HmacSha512Key: bip32HmacSha512Key,
    bip39WordListChineseSimplified: bip39WordListChineseSimplified,
    bip39WordListChineseTraditional: bip39WordListChineseTraditional,
    bip39WordListCzech: bip39WordListCzech,
    bip39WordListEnglish: bip39WordListEnglish,
    bip39WordListFrench: bip39WordListFrench,
    bip39WordListItalian: bip39WordListItalian,
    bip39WordListJapanese: bip39WordListJapanese,
    bip39WordListKorean: bip39WordListKorean,
    bip39WordListPortuguese: bip39WordListPortuguese,
    bip39WordListSpanish: bip39WordListSpanish,
    bitcoinBase58Alphabet: bitcoinBase58Alphabet,
    bitcoinSatoshiOpcodes: bitcoinSatoshiOpcodes,
    bitwiseOperation: bitwiseOperation,
    booleanToVmNumber: booleanToVmNumber,
    cashAddressChecksumToUint5Array: cashAddressChecksumToUint5Array,
    cashAddressLengthBitsToLength: cashAddressLengthBitsToLength,
    cashAddressLengthToLengthBits: cashAddressLengthToLengthBits,
    cashAddressPolynomialModulo: cashAddressPolynomialModulo,
    cashAddressPolynomialToCashAddress: cashAddressPolynomialToCashAddress,
    cashAddressToLockingBytecode: cashAddressToLockingBytecode,
    cashAddressTypeBitsToType: cashAddressTypeBitsToType,
    cashAddressTypeToTypeBits: cashAddressTypeToTypeBits,
    cashAssemblyToBin: cashAssemblyToBin,
    checkLimitsCommon: checkLimitsCommon,
    cloneAuthenticationInstruction: cloneAuthenticationInstruction,
    cloneAuthenticationProgramCommon: cloneAuthenticationProgramCommon,
    cloneAuthenticationProgramState: cloneAuthenticationProgramState,
    cloneAuthenticationProgramStateBCH: cloneAuthenticationProgramStateBCH,
    cloneAuthenticationProgramStateBCHCHIPs: cloneAuthenticationProgramStateBCHCHIPs,
    cloneAuthenticationProgramStateCommon: cloneAuthenticationProgramStateCommon,
    cloneStack: cloneStack,
    cloneTransactionCommon: cloneTransactionCommon,
    cloneTransactionInputsCommon: cloneTransactionInputsCommon,
    cloneTransactionOutputsCommon: cloneTransactionOutputsCommon,
    combineOperations: combineOperations,
    compactUintPrefixToLength: compactUintPrefixToLength,
    compactUintToBigInt: compactUintToBigInt,
    compileCashAssembly: compileCashAssembly,
    compileInputTemplate: compileInputTemplate,
    compileOutputTemplate: compileOutputTemplate,
    compileScenarioOutputTokenData: compileScenarioOutputTokenData,
    compileScript: compileScript,
    compileScriptContents: compileScriptContents,
    compileScriptRaw: compileScriptRaw,
    compileWalletTemplateScenarioBytecode: compileWalletTemplateScenarioBytecode,
    compileWalletTemplateScenarioValueSatoshis: compileWalletTemplateScenarioValueSatoshis,
    compilerConfigurationToCompiler: compilerConfigurationToCompiler,
    compilerConfigurationToCompilerBCH: compilerConfigurationToCompilerBCH,
    compilerOperationAddressData: compilerOperationAddressData,
    compilerOperationAttemptBytecodeResolution: compilerOperationAttemptBytecodeResolution,
    compilerOperationCurrentBlockHeight: compilerOperationCurrentBlockHeight,
    compilerOperationCurrentBlockTime: compilerOperationCurrentBlockTime,
    compilerOperationDataSignatureRenamed: compilerOperationDataSignatureRenamed,
    compilerOperationHdKeyEcdsaDataSignatureBCH: compilerOperationHdKeyEcdsaDataSignatureBCH,
    compilerOperationHdKeyEcdsaSignatureBCH: compilerOperationHdKeyEcdsaSignatureBCH,
    compilerOperationHdKeyPublicKeyCommon: compilerOperationHdKeyPublicKeyCommon,
    compilerOperationHdKeySchnorrDataSignatureBCH: compilerOperationHdKeySchnorrDataSignatureBCH,
    compilerOperationHdKeySchnorrSignatureBCH: compilerOperationHdKeySchnorrSignatureBCH,
    compilerOperationHelperAddressIndex: compilerOperationHelperAddressIndex,
    compilerOperationHelperCompileScript: compilerOperationHelperCompileScript,
    compilerOperationHelperComputeDataSignatureBCH: compilerOperationHelperComputeDataSignatureBCH,
    compilerOperationHelperComputeSignatureBCH: compilerOperationHelperComputeSignatureBCH,
    compilerOperationHelperDeriveHdKeyPrivate: compilerOperationHelperDeriveHdKeyPrivate,
    compilerOperationHelperDeriveHdPrivateNode: compilerOperationHelperDeriveHdPrivateNode,
    compilerOperationHelperGenerateCoveredBytecode: compilerOperationHelperGenerateCoveredBytecode,
    compilerOperationHelperHdKeyDataSignatureBCH: compilerOperationHelperHdKeyDataSignatureBCH,
    compilerOperationHelperHdKeySignatureBCH: compilerOperationHelperHdKeySignatureBCH,
    compilerOperationHelperKeyDataSignatureBCH: compilerOperationHelperKeyDataSignatureBCH,
    compilerOperationHelperKeySignatureBCH: compilerOperationHelperKeySignatureBCH,
    compilerOperationHelperUnknownEntity: compilerOperationHelperUnknownEntity,
    compilerOperationKeyEcdsaDataSignatureBCH: compilerOperationKeyEcdsaDataSignatureBCH,
    compilerOperationKeyEcdsaSignatureBCH: compilerOperationKeyEcdsaSignatureBCH,
    compilerOperationKeyPublicKeyCommon: compilerOperationKeyPublicKeyCommon,
    compilerOperationKeySchnorrDataSignatureBCH: compilerOperationKeySchnorrDataSignatureBCH,
    compilerOperationKeySchnorrSignatureBCH: compilerOperationKeySchnorrSignatureBCH,
    compilerOperationRequires: compilerOperationRequires,
    compilerOperationSignatureRenamed: compilerOperationSignatureRenamed,
    compilerOperationSigningSerializationCorrespondingOutput: compilerOperationSigningSerializationCorrespondingOutput,
    compilerOperationSigningSerializationCorrespondingOutputHash: compilerOperationSigningSerializationCorrespondingOutputHash,
    compilerOperationSigningSerializationCoveredBytecode: compilerOperationSigningSerializationCoveredBytecode,
    compilerOperationSigningSerializationCoveredBytecodeLength: compilerOperationSigningSerializationCoveredBytecodeLength,
    compilerOperationSigningSerializationFullBCH: compilerOperationSigningSerializationFullBCH,
    compilerOperationSigningSerializationLocktime: compilerOperationSigningSerializationLocktime,
    compilerOperationSigningSerializationOutpointIndex: compilerOperationSigningSerializationOutpointIndex,
    compilerOperationSigningSerializationOutpointTransactionHash: compilerOperationSigningSerializationOutpointTransactionHash,
    compilerOperationSigningSerializationOutputValue: compilerOperationSigningSerializationOutputValue,
    compilerOperationSigningSerializationSequenceNumber: compilerOperationSigningSerializationSequenceNumber,
    compilerOperationSigningSerializationTokenPrefix: compilerOperationSigningSerializationTokenPrefix,
    compilerOperationSigningSerializationTransactionOutpoints: compilerOperationSigningSerializationTransactionOutpoints,
    compilerOperationSigningSerializationTransactionOutpointsHash: compilerOperationSigningSerializationTransactionOutpointsHash,
    compilerOperationSigningSerializationTransactionOutputs: compilerOperationSigningSerializationTransactionOutputs,
    compilerOperationSigningSerializationTransactionOutputsHash: compilerOperationSigningSerializationTransactionOutputsHash,
    compilerOperationSigningSerializationTransactionSequenceNumbers: compilerOperationSigningSerializationTransactionSequenceNumbers,
    compilerOperationSigningSerializationTransactionSequenceNumbersHash: compilerOperationSigningSerializationTransactionSequenceNumbersHash,
    compilerOperationSigningSerializationVersion: compilerOperationSigningSerializationVersion,
    compilerOperationWalletData: compilerOperationWalletData,
    compilerOperationsBCH: compilerOperationsBCH,
    compilerOperationsCommon: compilerOperationsCommon,
    conditionallyEvaluate: conditionallyEvaluate,
    conditionallyEvaluateChipLoops: conditionallyEvaluateChipLoops,
    containsRange: containsRange,
    crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode: crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode,
    createAuthenticationProgramEvaluationCommon: createAuthenticationProgramEvaluationCommon,
    createAuthenticationProgramStateBCHCHIPs: createAuthenticationProgramStateBCHCHIPs,
    createAuthenticationProgramStateCommon: createAuthenticationProgramStateCommon,
    createAuthenticationVirtualMachine: createAuthenticationVirtualMachine,
    createBaseConverter: createBaseConverter,
    createCompilationContextCommonTesting: createCompilationContextCommonTesting,
    createCompiler: createCompiler,
    createCompilerBCH: createCompilerBCH,
    createCompilerCommon: createCompilerCommon,
    createCompilerGenerateBytecodeFunction: createCompilerGenerateBytecodeFunction,
    createEmptyRange: createEmptyRange,
    createIdentifierResolver: createIdentifierResolver,
    createInstructionSetBCH: createInstructionSetBCH,
    createInstructionSetBCH2022: createInstructionSetBCH2022,
    createInstructionSetBCH2023: createInstructionSetBCH2023,
    createInstructionSetBCHCHIPs: createInstructionSetBCHCHIPs,
    createInstructionSetXEC: createInstructionSetXEC,
    createTestAuthenticationProgramBCH: createTestAuthenticationProgramBCH,
    createVirtualMachine: createVirtualMachine,
    createVirtualMachineBCH: createVirtualMachineBCH,
    createVirtualMachineBCH2022: createVirtualMachineBCH2022,
    createVirtualMachineBCH2023: createVirtualMachineBCH2023,
    createVirtualMachineBCHCHIPs: createVirtualMachineBCHCHIPs,
    createVirtualMachineXEC: createVirtualMachineXEC,
    dateToLocktime: dateToLocktime,
    dateToLocktimeBin: dateToLocktimeBin,
    decodeAuthenticationInstructions: decodeAuthenticationInstructions,
    decodeBase58Address: decodeBase58Address,
    decodeBase58AddressFormat: decodeBase58AddressFormat,
    decodeBech32: decodeBech32,
    decodeBip39Mnemonic: decodeBip39Mnemonic,
    decodeBip39MnemonicNonStandard: decodeBip39MnemonicNonStandard,
    decodeBitcoinSignature: decodeBitcoinSignature,
    decodeCashAddress: decodeCashAddress,
    decodeCashAddressFormat: decodeCashAddressFormat,
    decodeCashAddressFormatWithoutPrefix: decodeCashAddressFormatWithoutPrefix,
    decodeCashAddressNonStandard: decodeCashAddressNonStandard,
    decodeCashAddressVersionByte: decodeCashAddressVersionByte,
    decodeHdKey: decodeHdKey,
    decodeHdKeyUnchecked: decodeHdKeyUnchecked,
    decodeHdPrivateKey: decodeHdPrivateKey,
    decodeHdPublicKey: decodeHdPublicKey,
    decodeLocktime: decodeLocktime,
    decodePrivateKeyWif: decodePrivateKeyWif,
    decodeTransaction: decodeTransaction,
    decodeTransactionBCH: decodeTransactionBCH,
    decodeTransactionCommon: decodeTransactionCommon,
    decodeTransactionOutputs: decodeTransactionOutputs,
    decodeTransactionUnsafe: decodeTransactionUnsafe,
    decodeTransactionUnsafeBCH: decodeTransactionUnsafeBCH,
    decodeTransactionUnsafeCommon: decodeTransactionUnsafeCommon,
    deriveBip39ChecksumBits: deriveBip39ChecksumBits,
    deriveHdPath: deriveHdPath,
    deriveHdPathRelative: deriveHdPathRelative,
    deriveHdPrivateNodeChild: deriveHdPrivateNodeChild,
    deriveHdPrivateNodeFromBip39Mnemonic: deriveHdPrivateNodeFromBip39Mnemonic,
    deriveHdPrivateNodeFromSeed: deriveHdPrivateNodeFromSeed,
    deriveHdPrivateNodeIdentifier: deriveHdPrivateNodeIdentifier,
    deriveHdPublicKey: deriveHdPublicKey,
    deriveHdPublicNode: deriveHdPublicNode,
    deriveHdPublicNodeChild: deriveHdPublicNodeChild,
    deriveHdPublicNodeIdentifier: deriveHdPublicNodeIdentifier,
    deriveSeedFromBip39Mnemonic: deriveSeedFromBip39Mnemonic,
    describeExpectedInput: describeExpectedInput,
    disabledOperation: disabledOperation,
    disassembleAuthenticationInstruction: disassembleAuthenticationInstruction,
    disassembleAuthenticationInstructionMalformed: disassembleAuthenticationInstructionMalformed,
    disassembleAuthenticationInstructionMaybeMalformed: disassembleAuthenticationInstructionMaybeMalformed,
    disassembleAuthenticationInstructionsMaybeMalformed: disassembleAuthenticationInstructionsMaybeMalformed,
    disassembleBytecode: disassembleBytecode,
    disassembleBytecodeBCH: disassembleBytecodeBCH,
    disassembleBytecodeBTC: disassembleBytecodeBTC,
    encodeAuthenticationInstruction: encodeAuthenticationInstruction,
    encodeAuthenticationInstructionMalformed: encodeAuthenticationInstructionMalformed,
    encodeAuthenticationInstructionMaybeMalformed: encodeAuthenticationInstructionMaybeMalformed,
    encodeAuthenticationInstructions: encodeAuthenticationInstructions,
    encodeAuthenticationInstructionsMaybeMalformed: encodeAuthenticationInstructionsMaybeMalformed,
    encodeBase58Address: encodeBase58Address,
    encodeBase58AddressFormat: encodeBase58AddressFormat,
    encodeBech32: encodeBech32,
    encodeBip39Mnemonic: encodeBip39Mnemonic,
    encodeBip39MnemonicNonStandard: encodeBip39MnemonicNonStandard,
    encodeCashAddress: encodeCashAddress,
    encodeCashAddressFormat: encodeCashAddressFormat,
    encodeCashAddressNonStandard: encodeCashAddressNonStandard,
    encodeCashAddressVersionByte: encodeCashAddressVersionByte,
    encodeDataPush: encodeDataPush,
    encodeHdKeyPayloadMetadata: encodeHdKeyPayloadMetadata,
    encodeHdKeyPayloadWithChecksum: encodeHdKeyPayloadWithChecksum,
    encodeHdPrivateKey: encodeHdPrivateKey,
    encodeHdPrivateKeyPayload: encodeHdPrivateKeyPayload,
    encodeHdPublicKey: encodeHdPublicKey,
    encodeHdPublicKeyPayload: encodeHdPublicKeyPayload,
    encodeLockingBytecodeP2pk: encodeLockingBytecodeP2pk,
    encodeLockingBytecodeP2pkh: encodeLockingBytecodeP2pkh,
    encodeLockingBytecodeP2sh20: encodeLockingBytecodeP2sh20,
    encodeLockingBytecodeP2sh32: encodeLockingBytecodeP2sh32,
    encodePrivateKeyWif: encodePrivateKeyWif,
    encodeSigningSerializationBCH: encodeSigningSerializationBCH,
    encodeTokenPrefix: encodeTokenPrefix,
    encodeTransaction: encodeTransaction,
    encodeTransactionBCH: encodeTransactionBCH,
    encodeTransactionCommon: encodeTransactionCommon,
    encodeTransactionInput: encodeTransactionInput,
    encodeTransactionInputSequenceNumbersForSigning: encodeTransactionInputSequenceNumbersForSigning,
    encodeTransactionInputs: encodeTransactionInputs,
    encodeTransactionOutpoints: encodeTransactionOutpoints,
    encodeTransactionOutput: encodeTransactionOutput,
    encodeTransactionOutputs: encodeTransactionOutputs,
    encodeTransactionOutputsForSigning: encodeTransactionOutputsForSigning,
    excessiveSatoshis: excessiveSatoshis,
    extendCompilationDataWithScenarioBytecode: extendCompilationDataWithScenarioBytecode,
    extendScenarioDefinition: extendScenarioDefinition,
    extendScenarioDefinitionData: extendScenarioDefinitionData,
    extendedScenarioDefinitionToCompilationData: extendedScenarioDefinitionToCompilationData,
    extractBytecodeResolutions: extractBytecodeResolutions,
    extractEvaluationSamples: extractEvaluationSamples,
    extractEvaluationSamplesRecursive: extractEvaluationSamplesRecursive,
    extractGenesisCategories: extractGenesisCategories,
    extractMissingVariables: extractMissingVariables,
    extractNonBech32Characters: extractNonBech32Characters,
    extractResolvedVariableBytecodeMap: extractResolvedVariableBytecodeMap,
    extractResolvedVariables: extractResolvedVariables,
    extractSourceOutputTokenData: extractSourceOutputTokenData,
    extractTransactionOutputTokenData: extractTransactionOutputTokenData,
    extractUnexecutedRanges: extractUnexecutedRanges,
    flattenBinArray: flattenBinArray,
    formatError: formatError,
    generateBip39Mnemonic: generateBip39Mnemonic,
    generateBip39MnemonicNonStandard: generateBip39MnemonicNonStandard,
    generateBytecodeMap: generateBytecodeMap,
    generateDefaultScenarioDefinition: generateDefaultScenarioDefinition,
    generateDeterministicEntropy: generateDeterministicEntropy,
    generateExtendedScenario: generateExtendedScenario,
    generateHdPrivateNode: generateHdPrivateNode,
    generatePrivateKey: generatePrivateKey,
    generateRandomBytes: generateRandomBytes,
    generateRandomBytesUnchecked: generateRandomBytesUnchecked,
    generateRandomSeed: generateRandomSeed,
    generateScenarioBCH: generateScenarioBCH,
    generateSigningSerializationBCH: generateSigningSerializationBCH,
    generateSigningSerializationComponentsBCH: generateSigningSerializationComponentsBCH,
    generateTransaction: generateTransaction,
    getDustThreshold: getDustThreshold,
    getDustThresholdForLength: getDustThresholdForLength,
    getEmbeddedRipemd160Binary: getEmbeddedRipemd160Binary,
    getEmbeddedSecp256k1Binary: getEmbeddedSecp256k1Binary,
    getEmbeddedSha1Binary: getEmbeddedSha1Binary,
    getEmbeddedSha256Binary: getEmbeddedSha256Binary,
    getEmbeddedSha512Binary: getEmbeddedSha512Binary,
    getMinimumFee: getMinimumFee,
    getResolutionErrors: getResolutionErrors,
    hash160: hash160,
    hash256: hash256,
    hashDigestIterations: hashDigestIterations,
    hashOutputs: hashOutputs,
    hashPrevouts: hashPrevouts,
    hashSequence: hashSequence,
    hashTransaction: hashTransaction,
    hashTransactionP2pOrder: hashTransactionP2pOrder,
    hashTransactionUiOrder: hashTransactionUiOrder,
    hashUtxos: hashUtxos,
    hdKeyVersionIsPrivateKey: hdKeyVersionIsPrivateKey,
    hdKeyVersionIsPublicKey: hdKeyVersionIsPublicKey,
    hdPrivateKeyToIdentifier: hdPrivateKeyToIdentifier,
    hdPrivateKeyToP2pkhCashAddress: hdPrivateKeyToP2pkhCashAddress,
    hdPrivateKeyToP2pkhLockingBytecode: hdPrivateKeyToP2pkhLockingBytecode,
    hdPublicKeyToIdentifier: hdPublicKeyToIdentifier,
    hdPublicKeyToP2pkhCashAddress: hdPublicKeyToP2pkhCashAddress,
    hdPublicKeyToP2pkhLockingBytecode: hdPublicKeyToP2pkhLockingBytecode,
    hexToBin: hexToBin,
    hmacSha256: hmacSha256,
    hmacSha512: hmacSha512,
    importMetadataRegistry: importMetadataRegistry,
    importWalletTemplate: importWalletTemplate,
    incrementHashDigestIterations: incrementHashDigestIterations,
    incrementOperationCount: incrementOperationCount,
    instantiateHmacFunction: instantiateHmacFunction,
    instantiatePbkdf2Function: instantiatePbkdf2Function,
    instantiateRipemd160: instantiateRipemd160,
    instantiateRipemd160Bytes: instantiateRipemd160Bytes,
    instantiateRustWasm: instantiateRustWasm,
    instantiateSecp256k1: instantiateSecp256k1,
    instantiateSecp256k1Bytes: instantiateSecp256k1Bytes,
    instantiateSecp256k1Wasm: instantiateSecp256k1Wasm,
    instantiateSecp256k1WasmBytes: instantiateSecp256k1WasmBytes,
    instantiateSha1: instantiateSha1,
    instantiateSha1Bytes: instantiateSha1Bytes,
    instantiateSha256: instantiateSha256,
    instantiateSha256Bytes: instantiateSha256Bytes,
    instantiateSha512: instantiateSha512,
    instantiateSha512Bytes: instantiateSha512Bytes,
    int32SignedToUnsigned: int32SignedToUnsigned,
    int32UnsignedToSigned: int32UnsignedToSigned,
    isArbitraryDataOutput: isArbitraryDataOutput,
    isBase64: isBase64,
    isBech32CharacterSet: isBech32CharacterSet,
    isBinString: isBinString,
    isDustOutput: isDustOutput,
    isHex: isHex,
    isLegacySigningSerialization: isLegacySigningSerialization,
    isMinimalDataPush: isMinimalDataPush,
    isPayToPublicKey: isPayToPublicKey,
    isPayToPublicKeyCompressed: isPayToPublicKeyCompressed,
    isPayToPublicKeyHash: isPayToPublicKeyHash,
    isPayToPublicKeyUncompressed: isPayToPublicKeyUncompressed,
    isPayToScriptHash20: isPayToScriptHash20,
    isPayToScriptHash32: isPayToScriptHash32,
    isPushOnly: isPushOnly,
    isPushOnlyAccurate: isPushOnlyAccurate,
    isPushOperation: isPushOperation,
    isSimpleMultisig: isSimpleMultisig,
    isStandardMultisig: isStandardMultisig,
    isStandardOutputBytecode: isStandardOutputBytecode,
    isStandardOutputBytecode2023: isStandardOutputBytecode2023,
    isValidBip39EntropyLength: isValidBip39EntropyLength,
    isValidBip39WordList: isValidBip39WordList,
    isValidCashAddressPayloadLength: isValidCashAddressPayloadLength,
    isValidCompressedPublicKeyEncoding: isValidCompressedPublicKeyEncoding,
    isValidPublicKeyEncoding: isValidPublicKeyEncoding,
    isValidSignatureEncodingBCHRaw: isValidSignatureEncodingBCHRaw,
    isValidSignatureEncodingBCHTransaction: isValidSignatureEncodingBCHTransaction,
    isValidSignatureEncodingDER: isValidSignatureEncodingDER,
    isValidUncompressedPublicKeyEncoding: isValidUncompressedPublicKeyEncoding,
    isVmNumberError: isVmNumberError,
    isWitnessProgram: isWitnessProgram,
    length: length,
    lockingBytecodeToAddressContents: lockingBytecodeToAddressContents,
    lockingBytecodeToBase58Address: lockingBytecodeToBase58Address,
    lockingBytecodeToCashAddress: lockingBytecodeToCashAddress,
    locktimeToDate: locktimeToDate,
    lossyNormalize: lossyNormalize,
    mapOverOperations: mapOverOperations,
    maskCashAddressPrefix: maskCashAddressPrefix,
    maximumLocktimeDate: maximumLocktimeDate,
    maximumLocktimeTimestamp: maximumLocktimeTimestamp,
    mergeRanges: mergeRanges,
    minimumEventsPerEntropyBits: minimumEventsPerEntropyBits,
    minimumLocktimeDate: minimumLocktimeDate,
    minimumLocktimeTimestamp: minimumLocktimeTimestamp,
    nftCapabilityLabelToNumber: nftCapabilityLabelToNumber,
    nftCapabilityNumberToLabel: nftCapabilityNumberToLabel,
    numberToBinInt16LE: numberToBinInt16LE,
    numberToBinInt32LE: numberToBinInt32LE,
    numberToBinInt32TwosCompliment: numberToBinInt32TwosCompliment,
    numberToBinUint16BE: numberToBinUint16BE,
    numberToBinUint16LE: numberToBinUint16LE,
    numberToBinUint16LEClamped: numberToBinUint16LEClamped,
    numberToBinUint32BE: numberToBinUint32BE,
    numberToBinUint32LE: numberToBinUint32LE,
    numberToBinUint32LEClamped: numberToBinUint32LEClamped,
    numberToBinUintLE: numberToBinUintLE,
    op0NotEqual: op0NotEqual,
    op1Add: op1Add,
    op1Sub: op1Sub,
    op2Drop: op2Drop,
    op2Dup: op2Dup,
    op2Over: op2Over,
    op2Rot: op2Rot,
    op2Swap: op2Swap,
    op3Dup: op3Dup,
    opAbs: opAbs,
    opActiveBytecode: opActiveBytecode,
    opAdd: opAdd,
    opAnd: opAnd,
    opBegin: opBegin,
    opBin2Num: opBin2Num,
    opBoolAnd: opBoolAnd,
    opBoolOr: opBoolOr,
    opCat: opCat,
    opCheckDataSig: opCheckDataSig,
    opCheckDataSigChipLimits: opCheckDataSigChipLimits,
    opCheckDataSigVerify: opCheckDataSigVerify,
    opCheckDataSigVerifyChipLimits: opCheckDataSigVerifyChipLimits,
    opCheckLockTimeVerify: opCheckLockTimeVerify,
    opCheckMultiSig: opCheckMultiSig,
    opCheckMultiSigBCH2023: opCheckMultiSigBCH2023,
    opCheckMultiSigChipLimits: opCheckMultiSigChipLimits,
    opCheckMultiSigVerify: opCheckMultiSigVerify,
    opCheckMultiSigVerifyBCH2023: opCheckMultiSigVerifyBCH2023,
    opCheckMultiSigVerifyChipLimits: opCheckMultiSigVerifyChipLimits,
    opCheckSequenceVerify: opCheckSequenceVerify,
    opCheckSig: opCheckSig,
    opCheckSigBCH2023: opCheckSigBCH2023,
    opCheckSigChipLimits: opCheckSigChipLimits,
    opCheckSigVerify: opCheckSigVerify,
    opCheckSigVerifyBCH2023: opCheckSigVerifyBCH2023,
    opCheckSigVerifyChipLimits: opCheckSigVerifyChipLimits,
    opCodeSeparator: opCodeSeparator,
    opDepth: opDepth,
    opDiv: opDiv,
    opDrop: opDrop,
    opDup: opDup,
    opElse: opElse,
    opElseChipLoops: opElseChipLoops,
    opEndIf: opEndIf,
    opEndIfChipLoops: opEndIfChipLoops,
    opEqual: opEqual,
    opEqualVerify: opEqualVerify,
    opFromAltStack: opFromAltStack,
    opGreaterThan: opGreaterThan,
    opGreaterThanOrEqual: opGreaterThanOrEqual,
    opHash160: opHash160,
    opHash160ChipLimits: opHash160ChipLimits,
    opHash256: opHash256,
    opHash256ChipLimits: opHash256ChipLimits,
    opIf: opIf,
    opIfChipLoops: opIfChipLoops,
    opIfDup: opIfDup,
    opInputBytecode: opInputBytecode,
    opInputIndex: opInputIndex,
    opInputSequenceNumber: opInputSequenceNumber,
    opLessThan: opLessThan,
    opLessThanOrEqual: opLessThanOrEqual,
    opMax: opMax,
    opMin: opMin,
    opMod: opMod,
    opMul: opMul,
    opNegate: opNegate,
    opNip: opNip,
    opNop: opNop,
    opNopDisallowed: opNopDisallowed,
    opNot: opNot,
    opNotIf: opNotIf,
    opNotIfChipLoops: opNotIfChipLoops,
    opNum2Bin: opNum2Bin,
    opNumEqual: opNumEqual,
    opNumEqualVerify: opNumEqualVerify,
    opNumNotEqual: opNumNotEqual,
    opOr: opOr,
    opOutpointIndex: opOutpointIndex,
    opOutpointTxHash: opOutpointTxHash,
    opOutputBytecode: opOutputBytecode,
    opOutputTokenAmount: opOutputTokenAmount,
    opOutputTokenCategory: opOutputTokenCategory,
    opOutputTokenCommitment: opOutputTokenCommitment,
    opOutputValue: opOutputValue,
    opOver: opOver,
    opPick: opPick,
    opReturn: opReturn,
    opReverseBytes: opReverseBytes,
    opRipemd160: opRipemd160,
    opRipemd160ChipLimits: opRipemd160ChipLimits,
    opRoll: opRoll,
    opRot: opRot,
    opSha1: opSha1,
    opSha1ChipLimits: opSha1ChipLimits,
    opSha256: opSha256,
    opSha256ChipLimits: opSha256ChipLimits,
    opSize: opSize,
    opSplit: opSplit,
    opSub: opSub,
    opSwap: opSwap,
    opToAltStack: opToAltStack,
    opTuck: opTuck,
    opTxInputCount: opTxInputCount,
    opTxLocktime: opTxLocktime,
    opTxOutputCount: opTxOutputCount,
    opTxVersion: opTxVersion,
    opUntil: opUntil,
    opUtxoBytecode: opUtxoBytecode,
    opUtxoTokenAmount: opUtxoTokenAmount,
    opUtxoTokenCategory: opUtxoTokenCategory,
    opUtxoTokenCommitment: opUtxoTokenCommitment,
    opUtxoValue: opUtxoValue,
    opVerify: opVerify,
    opWithin: opWithin,
    opXor: opXor,
    opcodeToPushLength: opcodeToPushLength,
    padMinimallyEncodedVmNumber: padMinimallyEncodedVmNumber,
    parseScript: parseScript,
    pbkdf2HmacSha256: pbkdf2HmacSha256,
    pbkdf2HmacSha512: pbkdf2HmacSha512,
    privateKeyToP2pkhCashAddress: privateKeyToP2pkhCashAddress,
    privateKeyToP2pkhLockingBytecode: privateKeyToP2pkhLockingBytecode,
    publicKeyToP2pkhCashAddress: publicKeyToP2pkhCashAddress,
    publicKeyToP2pkhLockingBytecode: publicKeyToP2pkhLockingBytecode,
    pushNumberOpcodeToNumber: pushNumberOpcodeToNumber,
    pushNumberOperation: pushNumberOperation,
    pushOperation: pushOperation,
    pushOperationChipLoops: pushOperationChipLoops,
    pushToControlStackChipLoops: pushToControlStackChipLoops,
    pushToStack: pushToStack,
    pushToStackChecked: pushToStackChecked,
    pushToStackVmNumber: pushToStackVmNumber,
    pushToStackVmNumberChecked: pushToStackVmNumberChecked,
    pushTokenAmount: pushTokenAmount,
    pushTokenCommitment: pushTokenCommitment,
    pushTokenExtendedCategory: pushTokenExtendedCategory,
    range: range,
    readAuthenticationInstruction: readAuthenticationInstruction,
    readBytes: readBytes,
    readCompactUint: readCompactUint,
    readCompactUintMinimal: readCompactUintMinimal,
    readCompactUintPrefixedBin: readCompactUintPrefixedBin,
    readItemCount: readItemCount,
    readLittleEndianNumber: readLittleEndianNumber,
    readLockingBytecodeWithPrefix: readLockingBytecodeWithPrefix,
    readMultiple: readMultiple,
    readRemainingBytes: readRemainingBytes,
    readTokenAmount: readTokenAmount,
    readTokenPrefix: readTokenPrefix,
    readTransaction: readTransaction,
    readTransactionCommon: readTransactionCommon,
    readTransactionInput: readTransactionInput,
    readTransactionInputs: readTransactionInputs,
    readTransactionNonTokenAware: readTransactionNonTokenAware,
    readTransactionOutput: readTransactionOutput,
    readTransactionOutputNonTokenAware: readTransactionOutputNonTokenAware,
    readTransactionOutputs: readTransactionOutputs,
    readTransactionOutputsNonTokenAware: readTransactionOutputsNonTokenAware,
    readUint32LE: readUint32LE,
    readUint64LE: readUint64LE,
    reduceScript: reduceScript,
    regroupBits: regroupBits,
    reservedOperation: reservedOperation,
    resolveScriptIdentifier: resolveScriptIdentifier,
    resolveScriptSegment: resolveScriptSegment,
    resolveVariableIdentifier: resolveVariableIdentifier,
    ripemd160: ripemd160,
    ripemd160Base64Bytes: ripemd160Base64Bytes,
    safelyExtendCompilationData: safelyExtendCompilationData,
    secp256k1: secp256k1,
    segment: segment,
    sha1: sha1,
    sha1Base64Bytes: sha1Base64Bytes,
    sha256: sha256,
    sha256Base64Bytes: sha256Base64Bytes,
    sha512: sha512,
    sha512Base64Bytes: sha512Base64Bytes,
    shannonEntropyPerEvent: shannonEntropyPerEvent,
    sortObjectKeys: sortObjectKeys,
    splitEvery: splitEvery,
    stackItemIsTruthy: stackItemIsTruthy,
    stringify: stringify,
    stringifyDebugTraceSummary: stringifyDebugTraceSummary,
    stringifyErrors: stringifyErrors,
    stringifyTestVector: stringifyTestVector,
    summarizeDebugTrace: summarizeDebugTrace,
    summarizeStack: summarizeStack,
    supportedTestSetOverridesBCH: supportedTestSetOverridesBCH,
    swapEndianness: swapEndianness,
    undefinedOperation: undefinedOperation,
    undefinedOperationChipLoops: undefinedOperationChipLoops,
    unknownValue: unknownValue,
    useFourStackItems: useFourStackItems,
    useLocktime: useLocktime,
    useOneStackItem: useOneStackItem,
    useOneVmNumber: useOneVmNumber,
    useSixStackItems: useSixStackItems,
    useThreeStackItems: useThreeStackItems,
    useThreeVmNumbers: useThreeVmNumbers,
    useTransactionInput: useTransactionInput,
    useTransactionOutput: useTransactionOutput,
    useTransactionUtxo: useTransactionUtxo,
    useTwoStackItems: useTwoStackItems,
    useTwoVmNumbers: useTwoVmNumbers,
    utf8ToBin: utf8ToBin,
    validateCompilationData: validateCompilationData,
    validateSecp256k1PrivateKey: validateSecp256k1PrivateKey,
    valueSatoshisToBin: valueSatoshisToBin,
    verifyCashAssemblyEvaluationState: verifyCashAssemblyEvaluationState,
    verifyTransactionTokens: verifyTransactionTokens,
    vmNumberToBigInt: vmNumberToBigInt,
    vmbTestDefinitionDefaultBehaviorBCH: vmbTestDefinitionDefaultBehaviorBCH,
    vmbTestDefinitionToVmbTests: vmbTestDefinitionToVmbTests,
    vmbTestGroupToVmbTests: vmbTestGroupToVmbTests,
    vmbTestPartitionMasterTestList: vmbTestPartitionMasterTestList,
    walletTemplateP2pkh: walletTemplateP2pkh,
    walletTemplateP2pkhNonHd: walletTemplateP2pkhNonHd,
    walletTemplateToCompilerBCH: walletTemplateToCompilerBCH,
    walletTemplateToCompilerConfiguration: walletTemplateToCompilerConfiguration
});

/**
 * Minimal JSON-RPC bridge for libauth.
 *
 * IN -- from python to JS:
 * from python side, bytes must be marked as "hexbytes", bigint must be marked as "bigint".
 * (maps to Uint8array and Bigint)
 *
 * OUT -- from JS to python:
 * outgoing bytes (Uint8array) get marked as "hexbytes" and bigint is marked as "bigint".
 * 
 * (These are JSON markers).
 */
 

/** You must explicitly declare methods from libauth you want. */
const LIBAUTH_ALLOWLIST = new Set([
  "hexToBin",
  "binToHex",
  "privateKeyToP2pkhCashAddress",
  "publicKeyToP2pkhCashAddress",
  "decodeCashAddress", 
  "decodeTransactionCommon",
  "encodeTransactionCommon",
  "compileCashAssembly",
  "secp256k1.derivePublicKeyCompressed",  // dotted paths allowed.
  "secp256k1.derivePublicKeyUncompressed",
]);

function writeLine(obj) {
  process.stdout.write(JSON.stringify(obj) + "\n");
}

function writeOk(id, result) {
  writeLine({ id, ok: true, result });
}

function writeErr(id, message, details) {
  writeLine({ id, ok: false, error: { message, details } });
}

function isPlainObject(v) {
  return v !== null && typeof v === "object" && !Array.isArray(v) && !(v instanceof Uint8Array);
}

/** IN: Convert explicit transport markers recursively. */
function reviveMarkers(value) {
  if (value === null || value === undefined) return value;
  if (Array.isArray(value)) return value.map(reviveMarkers);

  if (isPlainObject(value)) {
    const keys = Object.keys(value);

    if (keys.length === 1 && keys[0] === "hexbytes") {
      const hex = value.hexbytes;
      if (typeof hex !== "string") throw new Error("hexbytes marker must be a string");
      return hexToBin(hex);
    }

    if (keys.length === 1 && keys[0] === "bigint") {
      const dec = value.bigint;
      if (typeof dec !== "string") throw new Error("bigint marker must be a string (decimal)");
      if (!/^-?\d+$/.test(dec)) throw new Error("bigint marker must be a base-10 integer string");
      return BigInt(dec);
    }

    const out = {};
    for (const [k, v] of Object.entries(value)) out[k] = reviveMarkers(v);
    return out;
  }

  return value;
}

/** OUT: Make libauth return values JSON-safe by encoding non-JSON types. */
function toJsonSafe(value) {
  if (value === null || value === undefined) return value;

  if (value instanceof Uint8Array) return { hexbytes: binToHex(value) };
  if (typeof value === "bigint") return { bigint: value.toString(10) };

  if (Array.isArray(value)) return value.map(toJsonSafe);

  if (isPlainObject(value)) {
    const out = {};
    for (const [k, v] of Object.entries(value)) out[k] = toJsonSafe(v);
    return out;
  }

  return value;
}



// helper
function resolveLibauthCallable(path) {
  const parts = path.split(".");
  let cur = libauth;
  for (const p of parts) {
    if (cur == null) return null;
    cur = cur[p];
  }
  return cur;
}


/**
 * The only RPC method:
 * params: { fn: string, args: any[] | any }
 */

async function handle_libauthCall(params) {
  const { fn, args } = params || {};
  if (typeof fn !== "string" || fn.length === 0) throw new Error("fn is required");

  if (!LIBAUTH_ALLOWLIST.has(fn)) {
    throw new Error(`libauth fn not allowed: ${fn}`);
  }

  const target = resolveLibauthCallable(fn);
  if (typeof target !== "function") {
    throw new Error(`libauth export is not a function: ${fn}`);
  }

  const revivedArgs = reviveMarkers(args);
  const raw = Array.isArray(revivedArgs) ? target(...revivedArgs) : target(revivedArgs);
  const awaited = raw && typeof raw.then === "function" ? await raw : raw;
  return toJsonSafe(awaited);
}

 
/* Stdin messaging with framing.  This reads a stream of bytes from stdin,
splits it into newline separated JSON messages, dispatches each
message to the handler and writes a JSON response to stdout. */

 
let buffer = "";
process.stdin.setEncoding("utf8");

process.stdin.on("data", (chunk) => {
  buffer += chunk;

  while (true) {
    const nl = buffer.indexOf("\n");
    if (nl === -1) break;

    const line = buffer.slice(0, nl).trim();
    buffer = buffer.slice(nl + 1);
    if (!line) continue;

    let msg;
    try {
      msg = JSON.parse(line);
    } catch (e) {
      writeErr(null, "Invalid JSON", { line });
      continue;
    }

    const id = Object.prototype.hasOwnProperty.call(msg, "id") ? msg.id : null;

    // The method in this RPC: 
    if (msg.method !== "libauthCall") {
      writeErr(id, "Unknown method", {
        got: msg.method,
        allowed: ["libauthCall"], 
      });
      continue;
    }

    (async () => {
      try {
        const result = await handle_libauthCall(msg.params);
        writeOk(id, result);
      } catch (e) {
        writeErr(id, "Exception", {
          name: e?.name,
          message: e?.message ?? String(e),
          stack: e?.stack,
        });
      }
    })();
  }
});

process.stdin.on("end", () => process.exit(0));
